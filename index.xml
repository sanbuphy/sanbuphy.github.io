<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>散步的小屋</title>
        <link>https://sanbuphy.github.io/</link>
        <description>Recent content on 散步的小屋</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 14 Oct 2022 19:48:48 +0800</lastBuildDate><atom:link href="https://sanbuphy.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>计算机各类神奇的小问题大全</title>
        <link>https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/</link>
        <pubDate>Fri, 14 Oct 2022 19:48:48 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/</guid>
        <description>&lt;p&gt;作为一个很多奇怪问题&amp;amp;bug体质的人，此处用于记录平时的奇思妙想。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/83454344&#34;  title=&#34;https://zhuanlan.zhihu.com/p/83454344&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/83454344&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;编译与链接相关&#34;&gt;编译与链接相关&lt;/h2&gt;
&lt;p&gt;windows动态连接库dll居然是用lib导入符号信息（windows专门的编译器）（此时的lib不表示静态连接库），还是linux香啊。。&lt;/p&gt;
&lt;p&gt;【手把手教你编写 年轻人的第一个动态链接库-哔哩哔哩】 &lt;a class=&#34;link&#34; href=&#34;https://b23.tv/6pddFSv&#34;  title=&#34;https://b23.tv/6pddFSv&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://b23.tv/6pddFSv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Q：&lt;strong&gt;编译器前后端之区别是不是只在中间代码翻译的职责部分？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如clang负责转换成机器无关的中间代码。然后llvm后端把它可以转换成机器相关汇编代码&lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;h2 id=&#34;操作系统相关&#34;&gt;操作系统相关&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yajin.org/os2018fall/&#34;  title=&#34;https://yajin.org/os2018fall/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yajin.org/os2018fall/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yajin.org/os2018fall/02_os_structures.pdf&#34;  title=&#34;https://yajin.org/os2018fall/02_os_structures.pdf&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yajin.org/os2018fall/02_os_structures.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：用户线程为什么不能独立于内核线程存在？至少要有一个内核线程“与他关联”？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;p&gt;群友的看法：&lt;/p&gt;
&lt;p&gt;我的理解是,如果在微内核, 比如fs模块在user层, 用户程序只需要调用fs模块, 那用户程序逻辑上是没有调用内核task, 但是物理上微内核fs模块肯定会调用微内核内核层的vm的task的, 所以用户线程不能独立存在。如果用户程序和操作系统在一个物理机中, 如果用户程序和操作系统要独立, 首先资源要独立, 内存可以协商独立, 比如0x00000a-0x0000fff是操作系统的, 然后0x0001ffff0-0xffffffff是用户程序的. cpu0是给操作系统的, cpu1是给用户程序的.  然后通信用网络, eth0是操作系统的, eth1是用户程序的. 这样的话应该能设计出用户线程是独立的。&lt;/p&gt;
&lt;p&gt;我的看法：&lt;/p&gt;
&lt;p&gt;（不同操作系统实现不同，这里只针对比较现代的linux。)&lt;/p&gt;
&lt;p&gt;首先要注意这东西由于不同操作系统和不同年代的教材众说纷纭，很容易出现概念混淆和理解错误，这里我们以最新的linux手册为准。&lt;/p&gt;
&lt;p&gt;在讨论这个问题之前首先要明确几个概念（什么是线程、什么是用户线程。），我们看到有很多地方说到多对一模型，其实这里的用户线程更应该叫协程（你看到很多地方会说这东西不需要syscall就可以创建，process内负责执行流切换无需os）。而我们常说的用户态创建的线程就是一对一模型（pthreads手册中明确提到&lt;code&gt;Both  of  these  are  so-called  1:1 implementations, meaning that each thread maps to a kernel scheduling entity&lt;/code&gt;），本身需要和内核线程挂钩（创建过程需要syscall和内核线程绑定），而进程本身的主线程必定是和内核线程挂钩；另外在linux中我们用task去称呼会更加合适，linux系统层面没必要分进程线程只需要task就好。只有在我们执行的程序里有需求开pthread 这里才要强调，它会将对应的函数入口给内核线程以便切换。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 153; 
			flex-basis: 369px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_wTLPrj0JQe.png&#34; data-size=&#34;1077x700&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_wTLPrj0JQe.png&#34;
			width=&#34;1077&#34;
			height=&#34;700&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_wTLPrj0JQe_hu77e70b1231fb602373c63163edd2f0ad_133635_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_wTLPrj0JQe_hu77e70b1231fb602373c63163edd2f0ad_133635_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，在xv6，内核初始化完了切换init后就进入了用户态，此后fork、exec的都是子task，但是需要调度流切换得需要和cpu联系，这就需要内核task才能够运作。（其实这里的子task本身就是可以被调度到的，因为就是PCB）&lt;/p&gt;
&lt;p&gt;回答这个问题的关键是理解所谓的线程是怎么拿到cpu资源的，拿到资源意味着被调度器调度。（为什么不讨论进程？因为实际上进程只是一些共享内存的task，而且在linux中PCB就是task_struct）。首先之所以是线程而不是函数是因为他能作为调度单元（可以被调度器切换上下文），在任务调度器（比如pa中的schedule）的眼里，只有task才是调度单元，即处理器上运行的每个任务都是调度器给分配的执行流，只要成为执行流就能够独立上处理器运行了，而内核task可以被内核直接调度，他可以直接做到操作页表，维护cache, 读写系统寄存器等操作。如果用户task（比如协程）不需要内核线程管理，容易出现一些意外现象（虽然还是可以让系统发指令杀死）。这里概念最坑的就是可能混淆协程和在用户态用pthread api 创建的线程以及LWP轻量化进程，实际上前者可以通过是否syscall是否需要和内核互动来区分；而LWP轻量化进程在linux中有时是内核线程的另一种称呼。&lt;/p&gt;
&lt;p&gt;为什么说linux中用户态可以/需要绑定一个内核线程？具体看syscall，我们创建线程的过程会调用clone然后和一个内核线程“绑定”（大概是把上下文存储到内核线程task块中这样可以被os看到和调度。）用户task实际上用的是内核task的pcb块，需要一些高级权限的时候就保存上下文内陷然后在内核中处理即可。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 190; 
			flex-basis: 457px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_PlhP7kl7xh.png&#34; data-size=&#34;1067x560&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_PlhP7kl7xh.png&#34;
			width=&#34;1067&#34;
			height=&#34;560&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_PlhP7kl7xh_hua3d6b73d8163f70255d79f03af46b33f_115046_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_PlhP7kl7xh_hua3d6b73d8163f70255d79f03af46b33f_115046_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果想要最单纯的用户线程也有执行的权限，关键是你能够怎么切换他的执行流，此时应该只有协程能满足这个需求了，否则要提权的话就是内核线程了，因为能被内核直接schedule。所以严格来说独立的用户线程是不存在的，就算是协程也需要进程调度，而进程的cpu资源源于对应内核task的被调度。&lt;/p&gt;
&lt;p&gt;（有趣的是，linux2.6才完全支持了我们现在意义上的用户态线程，linux2.6是2003年的内核版本，由此可见计算机确实是一门很新的学科:)   ）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 680; 
			flex-basis: 1634px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/53381f68-a93c-41fa-9c67-25c27e9af926_7QuK94AMj2.jpg&#34; data-size=&#34;1280x188&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/53381f68-a93c-41fa-9c67-25c27e9af926_7QuK94AMj2.jpg&#34;
			width=&#34;1280&#34;
			height=&#34;188&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/53381f68-a93c-41fa-9c67-25c27e9af926_7QuK94AMj2_huef019d814597c441b5e32bcd828a55c7_101184_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/53381f68-a93c-41fa-9c67-25c27e9af926_7QuK94AMj2_huef019d814597c441b5e32bcd828a55c7_101184_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 124; 
			flex-basis: 298px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_2_NY7oq6J9.png&#34; data-size=&#34;1044x840&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_2_NY7oq6J9.png&#34;
			width=&#34;1044&#34;
			height=&#34;840&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_2_NY7oq6J9_hub74cdf44b70179d2c1769d9182128b32_148981_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_2_NY7oq6J9_hub74cdf44b70179d2c1769d9182128b32_148981_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;reference：&lt;/p&gt;
&lt;p&gt;浙大课件Light-Weight Processes: Dissecting Linux Threads：&lt;a class=&#34;link&#34; href=&#34;https://yajin.org/os2018fall/04_thread_b.pdf&#34;  title=&#34;https://yajin.org/os2018fall/04_thread_b.pdf&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yajin.org/os2018fall/04_thread_b.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入理解Linux内核之内核线程（上）：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/364898425&#34;  title=&#34;https://zhuanlan.zhihu.com/p/364898425&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/364898425&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于“内核线程”、“用户线程”概念的理解：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u012927281/article/details/51602898&#34;  title=&#34;https://blog.csdn.net/u012927281/article/details/51602898&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/u012927281/article/details/51602898&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图解进程、线程：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/fuzhongmin05/article/details/119448800&#34;  title=&#34;https://blog.csdn.net/fuzhongmin05/article/details/119448800&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/fuzhongmin05/article/details/119448800&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Light-Weight Processes: Dissecting Linux Threads：&lt;a class=&#34;link&#34; href=&#34;https://www.opensourceforu.com/2011/08/light-weight-processes-dissecting-linux-threads/&#34;  title=&#34;https://www.opensourceforu.com/2011/08/light-weight-processes-dissecting-linux-threads/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.opensourceforu.com/2011/08/light-weight-processes-dissecting-linux-threads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;What are Linux Processes, Threads, Light Weight Processes, and Process State:&lt;a class=&#34;link&#34; href=&#34;https://www.thegeekstuff.com/2013/11/linux-process-and-threads/&#34;  title=&#34;https://www.thegeekstuff.com/2013/11/linux-process-and-threads/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.thegeekstuff.com/2013/11/linux-process-and-threads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;man pthreads:&lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man7/pthreads.7.html&#34;  title=&#34;https://man7.org/linux/man-pages/man7/pthreads.7.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://man7.org/linux/man-pages/man7/pthreads.7.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：linux&lt;/strong&gt;线程的生命周期是怎么样的？怎么被创建和销毁？内核task能不能被复用？&lt;/p&gt;
&lt;p&gt;A: 这个说的比较清楚：&lt;a class=&#34;link&#34; href=&#34;https://xieyu.github.io/blog/pthread/glibc-pthread-implement-thread-life-cycle.html&#34;  title=&#34;https://xieyu.github.io/blog/pthread/glibc-pthread-implement-thread-life-cycle.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://xieyu.github.io/blog/pthread/glibc-pthread-implement-thread-life-cycle.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;pthread_join&lt;/code&gt; 发生在结束后不久，资源还未被回收，函数会立即返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;pthread_join&lt;/code&gt; 发生在结束以后一段时间，可能会得到 &lt;code&gt;ESRCH&lt;/code&gt; (no such thread) 错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;pthread_join&lt;/code&gt; 发生在之后很久很久很久很久，资源被释放又被再次复用 (&lt;code&gt;pthread_t&lt;/code&gt; 是一个的确可能被复用的整数)，我不就 join 了另一个线程了吗？这恐怕要出大问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特别的：（其他情况exit后都会被资源回收）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 559; 
			flex-basis: 1342px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_kscuOP_aW9.png&#34; data-size=&#34;923x165&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_kscuOP_aW9.png&#34;
			width=&#34;923&#34;
			height=&#34;165&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_kscuOP_aW9_hu2ab4a8651298f44b964671e6da706e60_59405_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%B1%BB%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%E5%A4%A7%E5%85%A8/image/image_kscuOP_aW9_hu2ab4a8651298f44b964671e6da706e60_59405_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;没有task复用的说法。&lt;/p&gt;
&lt;p&gt;reference:&lt;/p&gt;
&lt;p&gt;jyy:&lt;a class=&#34;link&#34; href=&#34;http://jyywiki.cn/OS/2022/labs/M2&#34;  title=&#34;http://jyywiki.cn/OS/2022/labs/M2&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jyywiki.cn/OS/2022/labs/M2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;网络相关&#34;&gt;网络相关&lt;/h2&gt;
&lt;h2 id=&#34;python相关&#34;&gt;python相关&lt;/h2&gt;
&lt;p&gt;Q:为什么开了multiprocessing的pool再开process就不会出现信息？&lt;/p&gt;
&lt;p&gt;A：不知道，但你记住要多次fork只能一直process就对了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>pybind11生成的so无法被import问题</title>
        <link>https://sanbuphy.github.io/p/pybind11%E7%94%9F%E6%88%90%E7%9A%84so%E6%97%A0%E6%B3%95%E8%A2%ABimport%E9%97%AE%E9%A2%98/</link>
        <pubDate>Fri, 14 Oct 2022 19:08:27 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/pybind11%E7%94%9F%E6%88%90%E7%9A%84so%E6%97%A0%E6%B3%95%E8%A2%ABimport%E9%97%AE%E9%A2%98/</guid>
        <description>&lt;p&gt;最近在使用python调用pybind11生成的so发现了一个问题，对于一个python环境下生成的so，另一个环境用不了。（刚开始也还没发现是环境的问题）&lt;/p&gt;
&lt;p&gt;一开始发现的现象是能用vscode生成能使用，但在pycharm下使用不能；一开始怀疑的是pycharm配置问题导致库不能被import（import了会提示找不到这个库）。&lt;/p&gt;
&lt;p&gt;后面发现换到某指定环境下就可以成功运行（和python版本有关），再之后发现只有特定python版本用&lt;code&gt;python setup.py build&lt;/code&gt; 后产生的so能用特定python进行调用。&lt;/p&gt;
&lt;p&gt;为什么呢？我们仔细观察后发现不同so涉及到python版本的前缀是不一样的（比如3.7生成就是37），在编译过程中我们也能看到setup的编译选项中涉及到了指定的python版本信息；所以我们确定了他就是解释器版本相关的，那为什么版本不同的so不可以被python读取呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在import一个so库里的类或函数时，有时发现so文件分明就在那路径下，可是总是报错ModuleNotFoundError: No module named，这种错误的可能原因有:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.首先要确保so所在的路径已经包含在sys.path里了，如果so所在目录已经是在python默认的系统路径里，例如/usr/lib/python3.6/dist-packages/或者/usr/local/lib/python3.6/dist-packages/之下的任何层级的目录，不用做任何设置，如果是其他路径，可以通过设置PYTHONPATH或者程序里使用sys.path.insert()或sys.path.append()把路径添加到sys.path里来。&lt;/p&gt;
&lt;p&gt;2.路径包含正确了，检查so库的命名的前缀和import是否不一致，这种so库的命名是有一定规则的，例如，Linux上一般是&amp;lt;so_name&amp;gt;.cpython-&lt;!-- raw HTML omitted --&gt;-&lt;!-- raw HTML omitted --&gt;-linux-gnu.so，在import时指定的名字需要和&amp;lt;so_name&amp;gt;保持一致。&lt;/p&gt;
&lt;p&gt;3.命名正确了，检查后面的后缀cpython-&lt;!-- raw HTML omitted --&gt;-&lt;!-- raw HTML omitted --&gt;-linux-gnu.so是否在你当前使用的python版本的支持范围内，例如，你的so库是python3的，可你在误操作下在使用python2运行程序，或者你的so库是针对python3.5的(so后缀里的python-version=35m)，但你当前使用的是python3.6，也不行，所以如果不是在只安装了一种版本的python的环境里，运行python程序前，最好检查一下python版本是否是你所希望的，这个是在安装了多个版本的python的环境下或者升级了python版本后经常不经意下易犯的错误，有时还被坑浪费很多时间查找原因，除了so库分明在那里却总是报ModuleNotFoundError，还有其他七七八八奇怪的错误，查找原因最后发现是python版本用错了，气得血冲脑门。&lt;/p&gt;
&lt;p&gt;4.路径存在冲突，so分明在某个已包含的目录下存在，没有其他的错误，可还总是报错ModuleNotFoundError，这种情况也是很坑人的，花费了很久时间想不出原因来，就是没想到可能路径上存在重名的冲突，例如，我第一次使用python代码调用mediapipe时出现报错ModuleNotFoundError: No module named &amp;lsquo;mediapipe.python._framework_bindings&amp;rsquo;，其他什么错误原因都没发现，郁闷地熬夜，最后发现虽然/usr/local/lib/python3.6/site-packages/mediapipe/python/_framework_bindings.cpython-36m-x86_64-linux-gnu.so是存在的，但是在运行程序的工作目录下也有个使用过用来build出meaidpipe的wheel包的源码目录，由于当前工作目录加入了sys.path里最前面，于是python搜索路径时自然是优先找的/workspace/mediapipe/python/&amp;hellip;，这个下面确实是没有那个so文件，于是把这里的mediapipe目录改名或者移走，问题就消失了。&lt;/p&gt;
&lt;p&gt;5.最后，如果是自己实现的so库，要想能被python import，so库的内部实现按规范来。&lt;/p&gt;
&lt;p&gt;怎么确认你当前使用的python版本支持哪些后缀的库能被import呢，很简单，执行下面的代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;importlib.machinery&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;importlib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;machinery&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;all_suffixes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;此时你就能看到上述so熟悉的身影，这就是为什么有些so能够被import的底层原因。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reference&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/XCCCCZ/article/details/111089151&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/XCCCCZ/article/details/111089151&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>利用Nginx的转推流http-flv</title>
        <link>https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8nginx%E7%9A%84%E8%BD%AC%E6%8E%A8%E6%B5%81http-flv/</link>
        <pubDate>Fri, 14 Oct 2022 17:56:50 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8nginx%E7%9A%84%E8%BD%AC%E6%8E%A8%E6%B5%81http-flv/</guid>
        <description>&lt;p&gt;最近遇到要让rtmp在前端展示的问题，我们知道flash已经不再被支持了，现在支持的是http传输协议。&lt;/p&gt;
&lt;p&gt;如果要浏览器前端展示除了异步直接展示的方法就是用http-flv。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 247; 
			flex-basis: 594px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8nginx%E7%9A%84%E8%BD%AC%E6%8E%A8%E6%B5%81http-flv/ceshi.png&#34; data-size=&#34;943x381&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8nginx%E7%9A%84%E8%BD%AC%E6%8E%A8%E6%B5%81http-flv/ceshi.png&#34;
			width=&#34;943&#34;
			height=&#34;381&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8nginx%E7%9A%84%E8%BD%AC%E6%8E%A8%E6%B5%81http-flv/ceshi_hue572d18e6a9fd5003657f6c8c8854c9a_323767_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8nginx%E7%9A%84%E8%BD%AC%E6%8E%A8%E6%B5%81http-flv/ceshi_hue572d18e6a9fd5003657f6c8c8854c9a_323767_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;一安装http-flv版的nginx&#34;&gt;一、安装http-flv版的nginx&lt;/h2&gt;
&lt;p&gt;参考我之前的文章&lt;a class=&#34;link&#34; href=&#34;https://sanbuphy.github.io/p/opencv%e8%af%bb%e5%8f%96%e8%a7%86%e9%a2%91%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e5%90%8e%e6%8e%a8%e6%b5%81rtmp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://sanbuphy.github.io/p/opencv读取视频图像处理后推流rtmp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以进行基础的配置，唯一的差别就是安装的时候选取的包为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/winshining/nginx-http-flv-module.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也和我们之前的rtmp包一样放在同级目录，然后进入nginx：&lt;/p&gt;
&lt;p&gt;（注意，不需要带上rtmp的附加模块，因为httpflv模块包含了rtmp包的基础功能）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;./configure --add-module&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;../nginx-http-flv-module
make -j8
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装结束后用同样的方法点亮nginx的初始化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你已经安装了nginx，你只需要whereis nginx，然后rm -rf对应的文件夹即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二修改nginx配置&#34;&gt;二、修改nginx配置&lt;/h2&gt;
&lt;p&gt;按之前文章同样的方法用code或者其他方式进入nginx.conf，按照如下规则修改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;# 在server内的location /stat.xsl之下加入如下字样，同时别忘了把stat.xsl的root地址改成http-flv的
location /live{
    flv_live on; #打开 HTTP 播放 FLV 直播流功能
    chunked_transfer_encoding on; #支持 &amp;#39;Transfer-Encoding: chunked&amp;#39; 方式回复

    add_header &amp;#39;Access-Control-Allow-Origin&amp;#39; &amp;#39;*&amp;#39;; #添加额外的 HTTP 头
    add_header &amp;#39;Access-Control-Allow-Credentials&amp;#39; &amp;#39;true&amp;#39;; #添加额外的 HTTP 头
}

# 在原来rtmp配置的地方加入如下字样
application http_flv{
  live on;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;特别注意的是，每次修改完配置一定要记得&lt;code&gt;sudo /usr/local/nginx/sbin/nginx -s reload&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ps:这里有个坑就是我改了worker_processes后就不能运行了。。这个具体细节可以搜索，实际上比较复杂。&lt;/p&gt;
&lt;h2 id=&#34;三开始推流&#34;&gt;三、开始推流&lt;/h2&gt;
&lt;p&gt;按照前文同样的方式你可以直接推送成rtmp流，如果你想要推送成http-flv支持的格式则修改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;n&#34;&gt;rtmp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;rtmp://localhost:1935/mylive/test&amp;#39;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#把原来的rtmp推送地址修改为如下:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;rtmp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;rtmp://localhost:1935/http_flv/test&amp;#39;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再使用html模板进行直接查看（flv.js）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;【此处需要修改&lt;code&gt;url: &#39;http://你的ip/live?port=1935&amp;amp;app=http_flv&amp;amp;stream=test&#39;,&lt;/code&gt;为你的ip】（这个是给前端拉流的地址）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-HTML&#34; data-lang=&#34;HTML&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
 &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
  
 &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;meta&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;text/html; charset=utf-8&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;http-equiv&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;flv.js demo&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;mainContainer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;640&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;px&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
         &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;urlInput&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;margin-top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;px&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;margin-bottom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;px&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
         &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;centeredVideo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;320&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;px&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
         &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;controls&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;text-align&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
  
 &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;div&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mainContainer&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;video&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;videoElement&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;centeredVideo&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;controls&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;autoplay&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;640&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;320&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Your browser is too
             old which doesn&amp;#39;t support HTML5 video.&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;video&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;div&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;br&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;div&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;controls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;onclick&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;flv_start()&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;开始&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;onclick&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;flv_pause()&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;暂停&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;onclick&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;flv_destroy()&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;停止&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;input&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;style&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;width:100px&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;seekpoint&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;/&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;onclick&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;flv_seekto()&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;跳转&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;button&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;div&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;https://cdn.bootcdn.net/ajax/libs/flv.js/1.5.0/flv.min.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
         &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getElementById&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;videoElement&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;flvjs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;isSupported&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flvPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flvjs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;createPlayer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;
                 &lt;span class=&#34;nx&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;flv&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                 &lt;span class=&#34;nx&#34;&gt;isLive&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                 &lt;span class=&#34;nx&#34;&gt;enableWorker&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                 &lt;span class=&#34;nx&#34;&gt;enableStashBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                 &lt;span class=&#34;nx&#34;&gt;stashInitialSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                 &lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://你的ip/live?port=1935&amp;amp;app=http_flv&amp;amp;stream=test&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  
             &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;flvPlayer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;attachMediaElement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;videoElement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;flvPlayer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;flv_start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
         &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flv_start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
         &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flv_pause&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pause&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
         &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flv_destroy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pause&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;detachMediaElement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;destroy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
         &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flv_seekto&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentTime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;parseFloat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;document&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getElementsByName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;seekpoint&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;script&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
  
 &lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;点击开始播放，此时你已经可以看到页面上呈现了！&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;rtmp、http-flv视频直播以及配合视频处理算法的实现&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/375548523&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/375548523&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FFmpeg + nginx-http-flv-module + flv.js 实现视频流播放&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://hasaik.com/posts/358f95d9.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hasaik.com/posts/358f95d9.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不依赖flashrtsp流通过ffmpeg+nginx-http-flv转成rtmp以及http-flv流并通过flv.js在页面播放(附带所用的工具下载)&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.361shipin.com/blog/1542511538894536704&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.361shipin.com/blog/1542511538894536704&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git完整工具流教程</title>
        <link>https://sanbuphy.github.io/p/git%E5%AE%8C%E6%95%B4%E5%B7%A5%E5%85%B7%E6%B5%81%E6%95%99%E7%A8%8B/</link>
        <pubDate>Fri, 14 Oct 2022 15:00:59 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/git%E5%AE%8C%E6%95%B4%E5%B7%A5%E5%85%B7%E6%B5%81%E6%95%99%E7%A8%8B/</guid>
        <description>&lt;p&gt;本文搬运自评论区（但是够用了）&lt;/p&gt;
&lt;p&gt;具体请看视频&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV19e4y1q7JJ/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV19e4y1q7JJ/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1ne4y1S7S9/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1ne4y1S7S9/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.git clone // 到本地    &lt;br&gt;
2.git checkout -b xxx 切换至新分支xxx    &lt;br&gt;
（相当于复制了remote的仓库到本地的xxx分支上  &lt;br&gt;
3.修改或者添加本地代码（部署在硬盘的源文件上）   &lt;br&gt;
4.git diff 查看自己对代码做出的改变  &lt;br&gt;
5.git add 上传更新后的代码至暂存区   &lt;br&gt;
6.git commit 可以将暂存区里更新后的代码更新到本地git     &lt;br&gt;
7.git push origin xxx 将本地的xxxgit分支上传至github上的git&lt;/p&gt;
&lt;p&gt;（如果在写自己的代码过程中发现远端GitHub上代码出现改变）     &lt;br&gt;
1.git checkout main 切换回main分支   &lt;br&gt;
2.git pull origin master(main) 将远端修改过的代码再更新到本地    &lt;br&gt;
3.git checkout xxx 回到xxx分支   &lt;br&gt;
4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容  &lt;br&gt;
（中途可能会出现，rebase conflict &amp;mdash;&amp;ndash;》手动选择保留哪段代码）      &lt;br&gt;
5.&lt;strong&gt;git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上&lt;/strong&gt;  &lt;br&gt;
（-f &amp;mdash;》强行）【一定要记得先更新最新的代码分支】&lt;br&gt;
6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit&lt;/p&gt;
&lt;p&gt;远端完成更新后&lt;/p&gt;
&lt;p&gt;1.git branch -d xxx 删除本地的git分支&lt;/p&gt;
&lt;p&gt;2.git pull origin master 再把远端的最新代码拉至本地&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;评论区：说的很好，刚入大厂的我表示就是用的这套流程，刚进来就犯了一次错误，自己的分支上面很多commit然后中间merge了一遍master的代码之后又commit了，结果导致最后PR的时候rebase非常困难，太多冲突了，commit数量太多被diss了。最后还是删除了分支，重新建立一个分支，把所有的改变重新再一个commit上面实现了一遍。&lt;strong&gt;后来知道了，千万不要在自己分支没有pr前merge，可以rebase。。。而且每次pr之前我们都要求用rebase -i命令在本地压缩commit到一个，然后再去PR&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;git checkout -b xxx：git checkout xxx是指切换到xxx（用local区的xxx替换disk区文件），-b意味着branch，即创建新分支，这条指令合起来意思是创建并切换到xxx。 
git diff：查看暂存区与disk区文件的差异。 &lt;br&gt;
git add xxx：将xxx文件添加到暂存区。 &lt;br&gt;
git commit：将暂存区内容添加到local区的当前分支中。 
git push &lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt;：将local区的LocalBranchName分支推送到RemoteHostName主机的同名分支。（若加-f表示无视本地与远程分支的差异强行push）&lt;br&gt;
git pull &lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt;：同上，不过改成从远程主机下载远程分支并与本地同名分支合并。 &lt;br&gt;
git rebase xxx：假设当前分支与xxx分支存在共同部分common，该指令用xxx分支包括common在内的整体替换当前分支的common部分（原先xxx分支内容为common-&amp;gt;diversityA，当前分支内容为common-&amp;gt;diversityB，执行完该指令后当前分支内容为common-&amp;gt;diversityA-&amp;gt;diversityB）。 
git branch -D xxx：不加-D表示创建新local分支xxx，加-D表示强制删除local分支xxx。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>我的计算机学习网站集合</title>
        <link>https://sanbuphy.github.io/p/%E6%88%91%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E9%9B%86%E5%90%88/</link>
        <pubDate>Fri, 14 Oct 2022 12:08:27 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%88%91%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E9%9B%86%E5%90%88/</guid>
        <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;收录了个人喜好觉得品味好的网站（也有一些小工具），&lt;/p&gt;
&lt;p&gt;如果有其他好的建议也欢迎提出，非常感谢。&lt;/p&gt;
&lt;p&gt;不定期更新&lt;/p&gt;
&lt;p&gt;带目录边栏（电脑上可看）：&lt;a class=&#34;link&#34; href=&#34;https://sanbuphy.github.io/p/%e6%88%91%e7%9a%84%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%ad%a6%e4%b9%a0%e7%bd%91%e7%ab%99%e9%9b%86%e5%90%88/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://sanbuphy.github.io/p/我的计算机学习网站集合/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github开源仓库地址： &lt;a class=&#34;link&#34; href=&#34;https://github.com/sanbuphy/my-awesome-cs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sanbuphy/my-awesome-cs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础素质要求（自勉用，参考NJUPA内的要求）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提问的艺术&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不像弱智一样提问&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分内容出自以下参考网站，也欢迎关注他们&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PPRP：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/pprp/p/8880493.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/pprp/p/8880493.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如需转载请注释原出处即可，谢谢&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;数学&#34;&gt;数学&lt;/h2&gt;
&lt;p&gt;机器学习相关数学基础&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1iW411T781?p=34&amp;amp;share_medium=iphone&amp;amp;share_plat=ios&amp;amp;share_session_id=918760D9-B272-4504-8DD6-82E44AFA8672&amp;amp;share_source=WEIXIN&amp;amp;share_tag=s_i&amp;amp;timestamp=1641652920&amp;amp;unique_k=aGspGLd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;直观理解机器学习的数学过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1xk4y1B7RQ?p=1&amp;amp;share_medium=iphone&amp;amp;share_plat=ios&amp;amp;share_session_id=1F101D5C-2880-4C53-A556-3D2777F6AFC8&amp;amp;share_source=WEIXIN&amp;amp;share_tag=s_i&amp;amp;timestamp=1641653070&amp;amp;unique_k=GcJNM2u&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;矩阵求导入门&lt;/a&gt; 或者你也可以参考我整理的文章：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://sanbuphy.github.io/p/%e7%9f%a9%e9%98%b5%e6%b1%82%e5%af%bc%e7%ae%80%e6%98%93%e5%85%a5%e9%97%a8%e6%89%8b%e5%86%8c/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://sanbuphy.github.io/p/矩阵求导简易入门手册/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1o5411p7H2?p=8&amp;amp;share_medium=iphone&amp;amp;share_plat=ios&amp;amp;share_session_id=3AD6E589-C577-4D7A-88C6-6A3FAB1E41F1&amp;amp;share_source=WEIXIN&amp;amp;share_tag=s_i&amp;amp;timestamp=1641653147&amp;amp;unique_k=abvhCWL&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;李航统计学习基础第一章补数学基础&lt;/a&gt; 只需要第一张 补基础，其他有问题再找&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.deeplearningbook.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Deep Learning An MIT Press book&lt;/a&gt;参考第一章即可，&lt;a class=&#34;link&#34; href=&#34;https://github.com/exacity/deeplearningbook-chinese/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;中文版在这&lt;/a&gt;或者直接下载附件中dlbook_cn_v0.5-beta。&lt;/p&gt;
&lt;h3 id=&#34;概率论与数理统计&#34;&gt;概率论与数理统计&lt;/h3&gt;
&lt;p&gt;陈希孺 概率论与数理统计基础 &lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV12k4y1m78w&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考课程视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【概率统计课程学习总结】1. 台大概率与台湾交通大学统计课 - 奶油煎蛋红烧肉的文章 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/86071634&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/86071634&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1nK4y1U7QM&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;台湾大学 - 頑想學概率：機率一 (Probability (1))&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1CX4y1V7oN?p=23&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;台湾大学 - 頑想學概率：機率二 (Probability (2))&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ocw.nctu.edu.tw/course_detail-v.php?bgid=1&amp;amp;gid=1&amp;amp;nid=270&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;台湾交通大学 - 統計學 Statistics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ocw.nctu.edu.tw/course_detail-v.php?bgid=1&amp;amp;gid=4&amp;amp;nid=536&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;台湾交通大学 - 高等統計學 Advanced Statistics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他&lt;/p&gt;
&lt;p&gt;线代启示录（一位掌握了线代灵魂的老师）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ccjou.wordpress.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ccjou.wordpress.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;immersive linear algebra 线性代数可视化&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://immersivemath.com/ila/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://immersivemath.com/ila/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cs大类&#34;&gt;CS大类&lt;/h2&gt;
&lt;p&gt;CS自学指南【必看】&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://csdiy.wiki/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://csdiy.wiki/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【北美名校CS课程集锦】2.加州大学伯克利分校CS课程全集 - 文兄的文章 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/102083014&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/102083014&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;基本操作&#34;&gt;基本操作&lt;/h3&gt;
&lt;p&gt;GDB、VIM、GIT、SHELL等常见linux操作基础（慢慢来，在使用中学&lt;/p&gt;
&lt;p&gt;The Missing Semester of Your CS Education 中文版（强烈推荐）&lt;/p&gt;
&lt;p&gt;官方中文站点：&lt;a class=&#34;link&#34; href=&#34;https://missing-semester-cn.github.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://missing-semester-cn.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B站：&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1x7411H7wa?t=2829&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1x7411H7wa?t=2829&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;南大PA教程最下面的一些简单入门和材料&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git相关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;git常见操作整理&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的git ssh秘钥教程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/helloasimo/article/details/123778112&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/helloasimo/article/details/123778112&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的pr教程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mmcv.readthedocs.io/zh_CN/latest/community/pr.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mmcv.readthedocs.io/zh_CN/latest/community/pr.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github linux下的desktop版&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/shiftkey/desktop/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/shiftkey/desktop/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;快速下载ubuntu镜像: 找到官网下载链接后使用wget下载&lt;/p&gt;
&lt;p&gt;简单安装双系统&lt;/p&gt;
&lt;p&gt;1、安装windows（因为windows的boot优先级比较高）&lt;/p&gt;
&lt;p&gt;2、安装ubuntu，他能检测到和windows并存的状态，选择那个安装即可&lt;/p&gt;
&lt;p&gt;简单更换ubuntu镜像源&lt;/p&gt;
&lt;p&gt;Settings→About→Software Updates→Download from&lt;/p&gt;
&lt;p&gt;选择其他服务器，然后找到中国，选择进行测试以便找到最快的站点。&lt;/p&gt;
&lt;p&gt;有关win家的镜像源以及VS等的纯净安装文件，以及各种网络工程师能用到的软件程序安装包&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://msdn.itellyou.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msdn.itellyou.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图吧工具箱（给自己电脑做硬件分析等等&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.tbtool.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.tbtool.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不知道变量怎么命名就可以看看：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://unbug.github.io/codelf/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://unbug.github.io/codelf/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正则表达式相关&lt;/p&gt;
&lt;p&gt;正则表达式入门与练习&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正则表达式可视化浏览&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://regexr.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://regexr.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;长正则表达式结构可视化&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://regexper.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://regexper.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;常用正则表达式汇总（车牌号手机号姓名IP等等）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://obkoro1.com/web_accumulate/codeBlack/%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e6%94%b6%e9%9b%86.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://obkoro1.com/web_accumulate/codeBlack/正则表达式收集.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他有趣的文章&#34;&gt;其他有趣的文章&lt;/h3&gt;
&lt;p&gt;有关linux的基础讲解，有配图和自己的理解，推荐一读。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/u/public0821&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://segmentfault.com/u/public0821&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个对cpu和网络了解都非常深入的工程师&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://plantegg.github.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://plantegg.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中最好的一类文章（有关cpu的讲解）&lt;a class=&#34;link&#34; href=&#34;https://plantegg.github.io/2021/06/01/CPU%e7%9a%84%e5%88%b6%e9%80%a0%e5%92%8c%e6%a6%82%e5%bf%b5/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://plantegg.github.io/2021/06/01/CPU的制造和概念/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个关于各种生成网络和编码器小论文通读的博主，有些写的还可以（比较基础入门）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@falconives&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/@falconives&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;java相关技术栈资料大全博主（还有一些三大件相关的资料，还挺多&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://learn.lianglianglee.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://learn.lianglianglee.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linux性能分析工具大全（Linux/BSD性能专家Brendan Gregg）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.brendangregg.com/linuxperf.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.brendangregg.com/linuxperf.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;面向程序员的各类调用库清单（主要是C/C++ PYTHON)&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/programthink/opensource&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/programthink/opensource&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub中文排行榜&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/GrowingGit/GitHub-Chinese-Top-Charts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/GrowingGit/GitHub-Chinese-Top-Charts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub 上有趣、入门级的开源项目&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/521xueweihan/HelloGitHub&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/521xueweihan/HelloGitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;美化自己的github界面&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/454597068&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/454597068&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://github.com/rzashakeri/beautify-github-profile&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com/rzashakeri/beautify-github-profile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bowenyoung.cn/posts/githubBeautify&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bowenyoung.cn/posts/githubBeautify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;社区制作的一键生成界面：&lt;a class=&#34;link&#34; href=&#34;https://rahuldkjain.github.io/gh-profile-readme-generator/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://rahuldkjain.github.io/gh-profile-readme-generator/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号 / 真没什么逻辑的作者（为什么这么设计系列文章）涉及网络、数据库、操作系统等&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/whys-the-design/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://draveness.me/whys-the-design/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roadmap to becoming a developer&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kamranahmedse/developer-roadmap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/kamranahmedse/developer-roadmap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小林 x 图解计算机基础（国内最好的八股文整理之一）（图解网络和操作系统）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://xiaolincoding.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;操作系统学习&#34;&gt;操作系统学习&lt;/h3&gt;
&lt;p&gt;南京大学计算机基础（袁春风）CSAPP的青春版，但比csapp好懂得多（强烈不建议一开始就读csapp&lt;/p&gt;
&lt;p&gt;赶时间可以直接看配套书。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.icourse163.org/course/nju-1001625001#/info&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.icourse163.org/course/nju-1001625001#/info&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前置：南京大学计算机基础实验（做了能让你真的变强）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2022 南京大学拔尖计划《操作系统：设计与实现》&lt;/p&gt;
&lt;p&gt;(蒋炎岩 我永远的超级无敌酷炫宝藏男神，还有什么好说的呢？没有他我就永远不懂计算机的美丽&lt;/p&gt;
&lt;p&gt;当然包云岗老师也是我的男神哈哈哈哈哈哈)&lt;/p&gt;
&lt;p&gt;课程主页：&lt;a class=&#34;link&#34; href=&#34;http://jyywiki.cn/OS/2022/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jyywiki.cn/OS/2022/&lt;/a&gt; (slides、示例代码)&lt;/p&gt;
&lt;p&gt;视频地址： &lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1Cm4y1d7Ur/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1Cm4y1d7Ur/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作系统（哈工大李治军老师）课件可在下方链接获取。&lt;/p&gt;
&lt;p&gt;慕课网: &lt;a class=&#34;link&#34; href=&#34;http://www.feemic.cn/mooc/icourse163/1002692015#%e3%80%82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.feemic.cn/mooc/icourse163/1002692015#。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;百度云链接：&lt;a class=&#34;link&#34; href=&#34;https://pan.baidu.com/s/1h2aEk6A_DGpXkZvRtNmeUw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pan.baidu.com/s/1h2aEk6A_DGpXkZvRtNmeUw&lt;/a&gt; 提取码：qoll&lt;/p&gt;
&lt;p&gt;配套实验课：&lt;a class=&#34;link&#34; href=&#34;https://www.shiyanlou.com/courses/115&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.shiyanlou.com/courses/115&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MIT 6.S081: Operating System Engineering&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://csdiy.wiki/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f/MIT6.S081/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://csdiy.wiki/操作系统/MIT6.S081/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;浙江大学周亚金老师的操作系统课课件（写的很好，有操作和现代的一些规范备注，我很喜欢）&lt;/p&gt;
&lt;p&gt;在Schedule中可以获取到全部课件&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yajin.org/os2018fall/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yajin.org/os2018fall/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;南京大学软件分析课程：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tai-e.pascal-lab.net/pa1.html#_1-%e4%bd%9c%e4%b8%9a%e5%af%bc%e8%a7%88&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://tai-e.pascal-lab.net/pa1.html#_1-作业导览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://space.bilibili.com/2919428/channel/series&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://space.bilibili.com/2919428/channel/series&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他文章:&lt;/p&gt;
&lt;p&gt;如何实现一个elf的loader：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/GoolyOh/article/details/119801160&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/GoolyOh/article/details/119801160&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从一个ELF程序的加载窥探操作系统内核:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/goolyoh/category_11298420.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/goolyoh/category_11298420.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何实现最小的hello world?&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cjting.me/2020/12/10/tiny-x64-helloworld/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cjting.me/2020/12/10/tiny-x64-helloworld/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;计算机网络学习&#34;&gt;计算机网络学习&lt;/h3&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;p&gt;其他文章：&lt;/p&gt;
&lt;p&gt;tcp高级疑难汇总案例分析：&lt;a class=&#34;link&#34; href=&#34;http://plantegg.github.io/2021/02/14/TCP%e7%96%91%e9%9a%be%e9%97%ae%e9%a2%98%e6%a1%88%e4%be%8b%e6%b1%87%e6%80%bb/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;plantegg.github.io/2021/02/14/TCP疑难问题案例汇总/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个博主写了网络编程相关的一系列文章：&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/user/862486453028888/posts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://juejin.cn/user/862486453028888/posts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中我最喜欢：Nginx一网打尽：动静分离、压缩、缓存、黑白名单、跨域、高可用、性能优化：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/7112826654291918855&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://juejin.cn/post/7112826654291918855&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有前端Nginx服务器在线配置，及大改善修改nginx的配置体验&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目来源：&lt;a class=&#34;link&#34; href=&#34;https://github.com/digitalocean/nginxconfig.io&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/digitalocean/nginxconfig.io&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据结构与算法&#34;&gt;数据结构与算法&lt;/h3&gt;
&lt;p&gt;程序员如何准备面试中的算法&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/00.01.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/00.01.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;labuladong 的算法小抄&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/labuladong/fucking-algorithm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/labuladong/fucking-algorithm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ACWING的课&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.acwing.com/activity/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.acwing.com/activity/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;深度学习大类&#34;&gt;深度学习大类&lt;/h3&gt;
&lt;h4 id=&#34;有关理论基础但我还是建议直接看李宏毅&#34;&gt;有关理论基础（但我还是建议直接看李宏毅）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;周志华&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;南瓜书主页&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://datawhalechina.github.io/pumpkin-book/#/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://datawhalechina.github.io/pumpkin-book/#/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周志华《机器学习》手推笔记 by Sophia-11&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Sophia-11/Machine-Learning-Notes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Sophia-11/Machine-Learning-Notes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周志华《机器学习》笔记（主要是文本） by yv.l1.pnn&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/134089340&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/134089340&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;李宏毅相关课程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0. 李宏毅老师的课程主页：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://speech.ee.ntu.edu.tw/~hylee/index.php&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://speech.ee.ntu.edu.tw/~hylee/index.php&lt;/a&gt; 这是李老师的个人主页，可以找到每年ML的课程主页，然后获取作业代码和Kaggle链接&lt;/p&gt;
&lt;p&gt;1.李宏毅《机器学习》：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1Ht411g7Ef&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1Ht411g7Ef&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.李宏毅机器学习笔记：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/datawhalechina/leeml-notes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gitee.com/datawhalechina/leeml-notes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.李宏毅《机器学习/深度学习》2021课程：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1JA411c7VT?p=34&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1JA411c7VT?p=34&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.李宏毅2022课程：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1JK4y1D7Wb/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1JK4y1D7Wb/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;李沐动手学深度学习（适合速成，打基础建议李宏毅）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.d2l.ai/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zh.d2l.ai/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;李沐深度学习精读&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/mli/paper-reading&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/mli/paper-reading&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个网站给出了不同模型的排名及其开源代码&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://paperswithcode.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://paperswithcode.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;开源库项目&#34;&gt;开源库/项目&lt;/h4&gt;
&lt;p&gt;OpenMMLab&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://openmmlab.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://openmmlab.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/open-mmlab&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/open-mmlab&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;paddle&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PaddlePaddle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PaddlePaddle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Deep Learning Paper Implementations&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/labmlai/annotated_deep_learning_paper_implementations&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/labmlai/annotated_deep_learning_paper_implementations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Awesome Machine Learning&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/josephmisiti/awesome-machine-learning&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/josephmisiti/awesome-machine-learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Awesome Deep Learning&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ChristosChristofidis/awesome-deep-learning&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ChristosChristofidis/awesome-deep-learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【杂谈】GitHub上的机器学习/深度学习综述项目合集 - 言有三的文章 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/60245227&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/60245227&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;手写深度学习项目&#34;&gt;手写深度学习项目&lt;/h4&gt;
&lt;p&gt;小土堆 pytorch学习&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://space.bilibili.com/203989554?spm_id_from=333.337.search-card.all.click&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://space.bilibili.com/203989554&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;霹雳吧啦Wz 图像分类篇章 以及目标检测&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://space.bilibili.com/18161609/channel/collectiondetail?sid=48290&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://space.bilibili.com/18161609/channel/collectiondetail?sid=48290&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;手写YOLO系列和fast rcnn系列：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1JR4y1g77H?spm_id_from=333.999.0.0&amp;amp;vd_source=a6509cab8ccb8b81d6a70af693cc008f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1JR4y1g77H&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://space.bilibili.com/472467171&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://space.bilibili.com/472467171&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;3d感知相关&#34;&gt;3D感知相关&lt;/h4&gt;
&lt;p&gt;从零开始搭一套激光SLAM出来, 通过代码的角度一点一点地深入学习激光SLAM.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/xiangli0608/Creating-2D-laser-slam-from-scratch&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;深度学习的杂物间&#34;&gt;深度学习的杂物间&lt;/h4&gt;
&lt;p&gt;显卡驱动安装快速方法：&lt;/p&gt;
&lt;p&gt;ubuntu-drivers devices&lt;/p&gt;
&lt;p&gt;sudo apt install  输入显示的推荐版本&lt;/p&gt;
&lt;p&gt;CUDA与cvDNN的安装：（直接官网选择）&lt;/p&gt;
&lt;p&gt;教程可参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/tangjiahao10/article/details/125227005&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/tangjiahao10/article/details/125227005&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.nvidia.com/cuda-downloads&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.nvidia.com/cuda-downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.nvidia.com/rdp/cudnn-archive&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.nvidia.com/rdp/cudnn-archive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决nvcc版本不一致问题（更换runtime映射&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://qiyuan-z.github.io/2022/01/06/%e8%a7%a3%e5%86%b3nvidia-smi%e5%92%8cnvcc%e6%98%be%e7%a4%ba%e4%bf%a1%e6%81%af%e4%b8%8e%e6%89%80%e5%ae%89%e8%a3%85CUDA%e7%89%88%e6%9c%ac%e4%b8%8d%e4%b8%80%e8%87%b4%e9%97%ae%e9%a2%98/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qiyuan-z.github.io/2022/01/06/解决nvidia-smi和nvcc显示信息与所安装CUDA版本不一致问题/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;孪生神经网络的相关实现：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_44791964/article/details/107406072&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_44791964/article/details/107406072&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/lx_ros/article/details/124439120&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/lx_ros/article/details/124439120&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深度学习500问&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/shliang0603/Awesome-DeepLearning-500FAQ&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/shliang0603/Awesome-DeepLearning-500FAQ&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;深度学习部署&#34;&gt;深度学习部署&lt;/h3&gt;
&lt;p&gt;GiantPandaCV&lt;/p&gt;
&lt;p&gt;国内最好的部署相关公众平台之一，涉及部署的内容比较多且硬核，五星推荐。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://giantpandacv.com/resources/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://giantpandacv.com/resources/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://giantpandacv.com/project/%e9%83%a8%e7%bd%b2%e4%bc%98%e5%8c%96/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://giantpandacv.com/project/部署优化/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ncnn推理框架开发版测试&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/458139435&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/458139435&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Build &amp;amp; Share Delightful Machine Learning Apps&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gradio.app/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gradio.app/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;推理框架&#34;&gt;推理框架&lt;/h4&gt;
&lt;p&gt;ncnn&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Tencent/ncnn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Tencent/ncnn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ncnn源码阅读学习&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/sinat_31425585/category_9312419.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/sinat_31425585/category_9312419.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;openvino&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://space.bilibili.com/38566875&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://space.bilibili.com/38566875&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;bbuf老师的onnx学习笔记&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/346511883&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ONNX学习笔记 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;实例参考&#34;&gt;实例参考&lt;/h4&gt;
&lt;p&gt;各种开发版的基础功能调通&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/sxj731533730&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/sxj731533730&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待测试&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/people/li-li-fu-70/posts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;成蹊 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;有趣的深度学习小程序与应用&#34;&gt;有趣的深度学习小程序与应用&lt;/h3&gt;
&lt;p&gt;比disco diffusion更强大的绘制工具SD：&lt;/p&gt;
&lt;p&gt;在自己电脑运行Stable Diffusion和完整项目下载&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/syEkqbBSmTwdi_cPB6Kd3g&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/syEkqbBSmTwdi_cPB6Kd3g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;StableDiffusion Int8量化教程与ONNX导出推理&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/18EIga7w9y1FG0oWcnysIw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/18EIga7w9y1FG0oWcnysIw&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;c与汇编&#34;&gt;C与汇编&lt;/h2&gt;
&lt;p&gt;翁恺的相关视频(入门和进阶)&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.icourse163.org/u/wengkai?userId=318013&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.icourse163.org/u/wengkai?userId=318013&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;100个GDB小技巧：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wizardforcel.gitbooks.io/100-gdb-tips/content/part1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wizardforcel.gitbooks.io/100-gdb-tips/content/part1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标准库收录网站&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cplusplus.com/reference/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cplusplus.com/reference/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;汇编语言在线解析网站&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://godbolt.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://godbolt.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内联汇编学习&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://baijiahao.baidu.com/s?id=1722268508697136684&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://baijiahao.baidu.com/s?id=1722268508697136684&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/1782e14a0766&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/1782e14a0766&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;undefined reference to XXX&amp;quot;问题总结&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Captain1986/CaptainBlackboard/blob/master/D#0001-undefined_reference_to_XXX/D#0001.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Captain1986/CaptainBlackboard/blob/master/D%230001-undefined_reference_to_XXX/D%230001.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有关硬件开发（嵌入式）的推荐个人博客列表&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/JesseGuoX/DoHard&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/JesseGuoX/DoHard&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;python&#34;&gt;python&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;anaconda基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;国内的anaconda镜像下载&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(windows)anaconda与Jupyter notebook安装教程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/37093476&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/37093476&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(linux)anaconda安装教程
- 下载deb格式的anaconda安装包
- 安装后在终端使用source ~/.bashrc即可在终端看到(base)标识（不要在管理员模式下运行）&lt;/p&gt;
&lt;p&gt;anaconda 换源(记得更换源的时候删去default 以及备份原来的）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_33590958/article/details/103291206&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/qq_33590958/article/details/103291206&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pip -i镜像源合集（个人喜欢用百度的）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/sunnydou/p/5801760.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/sunnydou/p/5801760.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;requirements.txt的生成教程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/lvjinfeng/articles/16333180.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/lvjinfeng/articles/16333180.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;conda与pip虚拟环境导出与转移（方便移植）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_42272869/article/details/122471357&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_42272869/article/details/122471357&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;awesome项目（包含了绝大部分的python相关资源）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/vinta/awesome-python&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/vinta/awesome-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jobbole.github.io/awesome-python-cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jobbole.github.io/awesome-python-cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python Cookbook 3rd Edition&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python并行编程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python 3 标准库实例教程(真正现代、进阶的python教程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learnku.com/docs/pymotw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learnku.com/docs/pymotw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pandas教程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pandas.pydata.org/docs/getting_started/install.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pandas.pydata.org/docs/getting_started/install.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者可以看看datawhale的教程&lt;/p&gt;
&lt;p&gt;Scipy Lecture Notes//Advanced Python Constructs//Advanced NumP&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://scipy-lectures.org/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://scipy-lectures.org/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SICP Python 描述 中文版&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wizardforcel.gitbooks.io/sicp-py/content/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wizardforcel.gitbooks.io/sicp-py/content/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;opencv图像处理100问，可用来查缺补漏（有些格式问题但不影响&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gzr2017/ImageProcessing100Wen&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gzr2017/ImageProcessing100Wen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有趣的Python爬虫和Python数据分析小项目（有些方法可能因为是3年前的东西会失效&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Alfred1984/interesting-python&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Alfred1984/interesting-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;requests库官方手册（交互常用，主要需理解请求头等）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://requests.readthedocs.io/en/latest/user/quickstart/#make-a-request&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://requests.readthedocs.io/en/latest/user/quickstart/#make-a-request&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;实例项目等&#34;&gt;实例项目等&lt;/h3&gt;
&lt;p&gt;supervisor + gunicorn + flask 高并发的接口 + 完整（标准）的日志部署&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/79227989&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/79227989&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;教你阅读 Python 开源项目代码（里面有一些基础开源项目可以参考）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learnku.com/articles/23010/teach-you-to-read-the-python-open-source-project-code&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learnku.com/articles/23010/teach-you-to-read-the-python-open-source-project-code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很不错的python状态机（可以画成图）展示工具：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/laike9m/Cyberbrain&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/laike9m/Cyberbrain&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;c&#34;&gt;C++&lt;/h2&gt;
&lt;p&gt;c++入门学习（建议直接看书加上翁恺或侯捷）&lt;/p&gt;
&lt;p&gt;可以b站搜索翁恺的c++&lt;/p&gt;
&lt;p&gt;awesome项目（包含了绝大部分的c++相关资源）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/fffaraz/awesome-cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/fffaraz/awesome-cpp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jobbole.github.io/awesome-python-cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jobbole.github.io/awesome-python-cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C++ reference（字典）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.cppreference.com/w/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;c++并发编程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://paul.pub/cpp-concurrency/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://paul.pub/cpp-concurrency/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;双笙子佯谬    图形学大佬，Zeno和Taichi Blend的作者&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://space.bilibili.com/263032155&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://space.bilibili.com/263032155&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C++ Core Guidelines&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/isocpp/CppCoreGuidelines&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/isocpp/CppCoreGuidelines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;c++手写数据库练习 CMU 15-445: Database Systems&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://csdiy.wiki/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f/15445/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://csdiy.wiki/数据库系统/15445/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;c的杂物间&#34;&gt;C++的杂物间&lt;/h3&gt;
&lt;p&gt;DJI thermal analysis tool  相关教程（日文&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://qiita.com/tutu/items/b5cf2b39dd30786d9064&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qiita.com/tutu/items/b5cf2b39dd30786d9064&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;学术论文&#34;&gt;学术论文&lt;/h2&gt;
&lt;p&gt;查询接受率的网站:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.openresearch.org/wiki/Main_Page&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.openresearch.org/wiki/Main_Page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LaTeX 图片转代码&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mathf.itewqq.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;点这里mathF&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://web.baimiaoapp.com/image-to-latex&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://web.baimiaoapp.com/image-to-latex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LaTeX手写字符识别（不知道字符的代码是什么的时候）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://detexify.kirelabs.org/classify.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://detexify.kirelabs.org/classify.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;论文翻译&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tongtianta.site/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://tongtianta.site/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一文网尽CV/Robotics顶会论文常用高级词汇/句式！ by 叶小飞（推荐关注）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/415926905&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/415926905&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他日常使用网站&#34;&gt;其他日常使用网站&lt;/h2&gt;
&lt;p&gt;有关思维导图的代码（类似markdown）生成：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xzmind.xuanzi.ltd/apps.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://xzmind.xuanzi.ltd/apps.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;流程图绘制：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://app.diagrams.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://app.diagrams.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;快速文件传输（随意分享给人不用网盘）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wenshushu.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wenshushu.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;偏极客的新闻网，无广告，而且有一套防刷热度算法，也不搞推荐算法&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://news.ycombinator.com/news&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://news.ycombinator.com/news&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;有趣的故事&#34;&gt;有趣的故事&lt;/h2&gt;
&lt;p&gt;谷歌背后的数学&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.changhai.org/articles/technology/misc/google_math.php&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.changhai.org/articles/technology/misc/google_math.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;火光摇曳(数学科普) Rickjin(靳志辉)   （非常好传递了统计之美）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://uploads.cosx.org/2014/07/gamma.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://uploads.cosx.org/2014/07/gamma.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;计算的极限&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://fwjmath.wordpress.com/recommended-list/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://fwjmath.wordpress.com/recommended-list/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;心理健康建设&#34;&gt;心理健康建设&lt;/h2&gt;
&lt;p&gt;如何在工作中学习（好的方法论）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://plantegg.github.io/2018/05/24/%e5%a6%82%e4%bd%95%e5%9c%a8%e5%b7%a5%e4%bd%9c%e4%b8%ad%e5%ad%a6%e4%b9%a0V1.1/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://plantegg.github.io/2018/05/24/如何在工作中学习V1.1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2017年买房经历总结出来的买房购房知识&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/houshanren/hangzhou_house_knowledge&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/houshanren/hangzhou_house_knowledge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2022年杭州购房指南&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://github.com/zkqiang/hangzhou-house-guide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com/zkqiang/hangzhou-house-guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2020年11月上海购房指南&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://github.com/ayuer/shanghai_house_knowledge&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com/ayuer/shanghai_house_knowledge&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;英语&#34;&gt;英语&lt;/h2&gt;
&lt;h3 id=&#34;英文语法在线修改&#34;&gt;英文语法在线修改&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.grammarly.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.grammarly.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nounplus.net/grammarcheck/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nounplus.net/grammarcheck/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://virtualwritingtutor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://virtualwritingtutor.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;英文论文好用工具&#34;&gt;英文论文好用工具&lt;/h3&gt;
&lt;p&gt;TextRanch 句子参考&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://textranch.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://textranch.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QuillBot 文段改写&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://quillbot.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://quillbot.com/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>优雅的调试—在vscode上完美调试xv6（完结）</title>
        <link>https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/</link>
        <pubDate>Thu, 29 Sep 2022 08:50:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言：&lt;/h2&gt;
&lt;p&gt;整个探索过程源于两句话：&lt;/p&gt;
&lt;p&gt;1、计算机世界没有魔法，机器永远是对的，让自己舒服才会有动力（比如调试）——jyy&lt;/p&gt;
&lt;p&gt;2、从今天开始, 不要偷懒了；RTFM + STFW ——yzh&lt;/p&gt;
&lt;p&gt;stackoverflow真心救大命- -&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可以选择使用ubuntu20.04系统环境，&lt;strong&gt;最好使用ubuntu22.04&lt;/strong&gt;（这个可以省去第四步），而且在20上不能显示csr寄存器，22上可以完美观察mepc等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;经过我的充分测试（包括测试了云服务器），最好的体验是22.04版本的ubuntu（wsl和虚拟机都可以）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你想用ubuntu20完成&lt;strong&gt;也可以&lt;/strong&gt;，只要在&lt;strong&gt;想要看csr相关寄存器的时候关闭xml&lt;/strong&gt;（第四步提到的target xml）就可以用gdb命令打印出相关csr或设置监视点（监视点后面加上,x可以变成十六进制如$mepc,x）。如果开启xml只能看到基础的32个寄存器，并且不能用监视点和打印出csr寄存器的相关内容，但这也足够陪伴你一段时间了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“Get out of your comfort zone.”       
不要惧怕调试任何一部分      
一定要相信是可以优雅地做到的        &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一准备工作&#34;&gt;一、准备工作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;💡为了能有一个流畅愉快的旅途，你应该拥有并安装以下依赖程序:    &lt;br&gt;
1、&lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.828/2021/tools.html&#34;  title=&#34;https://pdos.csail.mit.edu/6.828/2021/tools.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.828/2021/tools.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们可能会反复使用“根目录”，他的意思是直接在xv6-labs-2021文件夹下进行操作。&lt;/p&gt;
&lt;p&gt;💡注意：如果你想要用vscode远程调试服务器上的xv6，可以参考这个链接的教程&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://hitsz-cslab.gitee.io/os-labs/remote_env_gdb/&#34;  title=&#34;http://hitsz-cslab.gitee.io/os-labs/remote_env_gdb/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://hitsz-cslab.gitee.io/os-labs/remote_env_gdb/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;二第一次运行&#34;&gt;二、第一次运行&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;💡     &lt;br&gt;
1、你需要根据lab0：&lt;a class=&#34;link&#34; href=&#34;https://pdos.csail.mit.edu/6.828/2022/labs/util.html&#34;  title=&#34;https://pdos.csail.mit.edu/6.828/2022/labs/util.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pdos.csail.mit.edu/6.828/2022/labs/util.html&lt;/a&gt;  成功在命令行运行qemu   &lt;br&gt;
2、根据在根目录下创建.vscode文件夹，并创建如下内容的两个文件：launch.json、tasks.json  &lt;br&gt;
3、修改.gdbinit.tmpl-riscv文件内容     &lt;br&gt;
4、用虔诚的心态按下键盘上的F5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 107; 
			flex-basis: 258px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_N44gGAV10W.png&#34; data-size=&#34;351x326&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_N44gGAV10W.png&#34;
			width=&#34;351&#34;
			height=&#34;326&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_N44gGAV10W_hu6318207374a48bbe8cb65c104b4eb631_20444_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_N44gGAV10W_hu6318207374a48bbe8cb65c104b4eb631_20444_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//launch.json
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;configurations&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;debug xv6&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;cppdbg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;program&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;${workspaceFolder}/kernel/kernel&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;args&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;stopAtEntry&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;cwd&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;${workspaceFolder}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;miDebuggerServerAddress&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;127.0.0.1:26000&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//这里实际上可以用各种能调试的gdb，如果找不到你可以使用which gdb-multiarch
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//但要注意的是，为了能在ubuntu20.04调出寄存器，强烈建议使用riscv64的gdb
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;miDebuggerPath&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/usr/bin/gdb-multiarch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;environment&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;externalConsole&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;MIMode&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;gdb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;preLaunchTask&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;xv6build&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;setupCommands&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;pretty printing&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;-enable-pretty-printing&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;ignoreFailures&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//用于gdb调试的工具，可以发现gdb出错的原因
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// &amp;#34;logging&amp;#34;: {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//     &amp;#34;engineLogging&amp;#34;: true,
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//     &amp;#34;programOutput&amp;#34;: true,
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// tasks.json
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2.0.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;tasks&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;label&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;xv6build&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;shell&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;isBackground&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;command&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;make qemu-gdb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;problemMatcher&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;pattern&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;regexp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;file&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;location&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                            &lt;span class=&#34;nt&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
                        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;background&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;beginsPattern&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;.*Now run &amp;#39;gdb&amp;#39; in another window.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                        &lt;span class=&#34;c1&#34;&gt;// 要对应编译成功后,一句echo的内容. 此处对应 Makefile Line:170
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;endsPattern&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;都创建后我们发现直接F5会报错，原因是.gdbinit中的target remote问题，为了解决我们直接修改.gdbinit.tmpl-riscv文件内容（从makefile中我们能够知道是他创造了.gdbinit）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 273; 
			flex-basis: 655px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KYhbhMdHR_.png&#34; data-size=&#34;530x194&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KYhbhMdHR_.png&#34;
			width=&#34;530&#34;
			height=&#34;194&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KYhbhMdHR__huf8d1fb2689129fe483fc68b8b6324fd2_29497_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KYhbhMdHR__huf8d1fb2689129fe483fc68b8b6324fd2_29497_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后make clean再次f5后即可发现他安静的停在了main！&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 143; 
			flex-basis: 344px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_D9X3G5LBNc.png&#34; data-size=&#34;579x403&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_D9X3G5LBNc.png&#34;
			width=&#34;579&#34;
			height=&#34;403&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_D9X3G5LBNc_huc83877ec3fae9c1624602ebc2c3e5881_61978_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_D9X3G5LBNc_huc83877ec3fae9c1624602ebc2c3e5881_61978_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;三运行用户程序&#34;&gt;三、运行用户程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;💡     &lt;br&gt;
按照以下步骤即可得到结果，或者参考jyy的方法：&lt;a class=&#34;link&#34; href=&#34;https://jyywiki.cn/OS/2022/slides/18.slides#/2/2&#34;  title=&#34;https://jyywiki.cn/OS/2022/slides/18.slides#/2/2&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://jyywiki.cn/OS/2022/slides/18.slides#/2/2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在参考“MIT 6.S081 xv6调试不完全指北”后成功找到了最简单的方法，当我们直接f5点亮后，先不要做任何操作，我们以ls程序为例，&lt;strong&gt;首先进入ls.c的main处打下断点&lt;/strong&gt;（一定要在main有）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 77; 
			flex-basis: 187px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_mk6HHdHXDE.png&#34; data-size=&#34;503x645&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_mk6HHdHXDE.png&#34;
			width=&#34;503&#34;
			height=&#34;645&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_mk6HHdHXDE_hu70e8436a27d205fd655dab9ef544d718_67933_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_mk6HHdHXDE_hu70e8436a27d205fd655dab9ef544d718_67933_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时的断点是没有生效的，我们在左下角的断点也可以看到他是灰色的：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 210; 
			flex-basis: 504px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KE_NIx71iD.png&#34; data-size=&#34;332x158&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KE_NIx71iD.png&#34;
			width=&#34;332&#34;
			height=&#34;158&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KE_NIx71iD_hu6b56c9f77d3ad3eb3025a9b1d7277e11_6616_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_KE_NIx71iD_hu6b56c9f77d3ad3eb3025a9b1d7277e11_6616_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来我们在调试控制台输入&lt;code&gt;-exec file ./user/_ls&lt;/code&gt; （他的相对地址），此时我们发现他读取到了符号表信息：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 255; 
			flex-basis: 612px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_OJGJ3wZ00O.png&#34; data-size=&#34;761x298&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_OJGJ3wZ00O.png&#34;
			width=&#34;761&#34;
			height=&#34;298&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_OJGJ3wZ00O_hue2b1bc892887be8909230f98e39aabac_56342_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_OJGJ3wZ00O_hue2b1bc892887be8909230f98e39aabac_56342_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;让我们按下“播放”让程序跑到输入处，然后在终端输入ls并回车，你会发现他已经停在了用户程序中，也可以进入汇编文件：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 117; 
			flex-basis: 281px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_LspLktEPEP.png&#34; data-size=&#34;831x709&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_LspLktEPEP.png&#34;
			width=&#34;831&#34;
			height=&#34;709&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_LspLktEPEP_huded4870f65cd2ccbc0dc064860f81c59_85161_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_LspLktEPEP_huded4870f65cd2ccbc0dc064860f81c59_85161_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时已经可以愉快的调试用户程序了~你可以参考reference1中的不完全指北，用vscode尝试调试第一个用户程序。&lt;/p&gt;
&lt;p&gt;如果你发现这ls停止还没有成功，请按照类似的步骤先停在init，再尝试停在ls（具体什么是init请RTSC）&lt;/p&gt;
&lt;h2 id=&#34;四恢复寄存器显示&#34;&gt;四、恢复寄存器显示&lt;/h2&gt;
&lt;p&gt;通常来说，当我们打开了vscode，左边都应该显示出寄存器信息：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 191; 
			flex-basis: 460px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_Wz4v1PMwjG.png&#34; data-size=&#34;786x410&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_Wz4v1PMwjG.png&#34;
			width=&#34;786&#34;
			height=&#34;410&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_Wz4v1PMwjG_hu5fe165fd821ecbcd1d6a28f76687df87_77475_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_Wz4v1PMwjG_hu5fe165fd821ecbcd1d6a28f76687df87_77475_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但如果我们在ubuntu20.04中打开调试后，会惊奇的发现，完全没有显示！&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 144; 
			flex-basis: 346px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WUeteXFuKv.png&#34; data-size=&#34;362x251&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WUeteXFuKv.png&#34;
			width=&#34;362&#34;
			height=&#34;251&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WUeteXFuKv_hu032566377157ad8342e752c32be343bd_3851_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WUeteXFuKv_hu032566377157ad8342e752c32be343bd_3851_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;vscode没有寄存器，这完全不能忍！心态一开始就有点小崩了，不过别着急，让我们先打开位于launch的gdb日志看看发生了什么：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 344; 
			flex-basis: 826px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_lBKHOrADXP.png&#34; data-size=&#34;799x232&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_lBKHOrADXP.png&#34;
			width=&#34;799&#34;
			height=&#34;232&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_lBKHOrADXP_hue00f435c34c70c1ea55448aa889895b2_32579_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_lBKHOrADXP_hue00f435c34c70c1ea55448aa889895b2_32579_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;日志告诉我们有个叫做ustatus的寄存器无法显示，应该是gdb不支持（然而我们也确实只见过mstatus&amp;hellip;）那么关键的问题就是我们该如何解决这个register问题。&lt;/p&gt;
&lt;p&gt;（我还尝试修改了各种makefile等等。。。但并未奏效，实际上和问题无关故不再重复说明）&lt;/p&gt;
&lt;h3 id=&#34;41有关gdb版本的坑问题并非解决方法&#34;&gt;4.1有关gdb版本的坑问题（并非解决方法）&lt;/h3&gt;
&lt;p&gt;经过一顿搜索，我发现有人也遇到了类似的E14错误问题，他说要更新gdb，但我们仔细一想，在ubuntu20版本下的软件源只有9版本的gdb，哪来的12？（22上完美运行的gdb版本是12）&lt;/p&gt;
&lt;p&gt;而且我们可以通过&lt;code&gt;-exec show version&lt;/code&gt;发现此时运行的gdb确实是9版本，我们也有理由相信这确实是gdb的问题。&lt;/p&gt;
&lt;p&gt;提前卸载了gdb及其gdb-multiarch并一顿操作猛如虎找到了gdb的源码：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.sourceware.org/gdb/&#34;  title=&#34;https://www.sourceware.org/gdb/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.sourceware.org/gdb/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随便找了个教程编译后看了一下gdb -v以及gdb-multiarch -v都没有安装。。心态又不好了&lt;/p&gt;
&lt;p&gt;好那咱们换个方法编译一下，一顿操作猛如虎找到了riscv64-unknown-elf-gdb：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html&#34;  title=&#34;http://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一顿操作编译后（记得修改launch）还是不行&amp;hellip;..开始怀疑人生了，老板你这rv是不是假的啊？&lt;/p&gt;
&lt;p&gt;突然想到ustatus好像确实没有在rv出现过，那看来不能错怪他，也许是qemu之类的配置问题。&lt;/p&gt;
&lt;p&gt;此时我再次按照这个帖子提到的问题进行编译&lt;code&gt;make CXXFLAGS=&amp;quot;-static-libstdc++&amp;quot;&lt;/code&gt;：（其实后面发现不需要静态编译也是可以的）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/32773255/how-to-update-gdb-to-most-current-stable-version&#34;  title=&#34;https://stackoverflow.com/questions/32773255/how-to-update-gdb-to-most-current-stable-version&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/32773255/how-to-update-gdb-to-most-current-stable-version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此时可以发现gdb版本成功显示为gdb 12但是仍然没有gdb-multiarch，也无法直接吧这个版本的gdb加入到launch供vscode使用。于是我们需要再换一个缝合怪的gdb（我后面发现gdb其实可以包含各种架构也可以切换）&lt;/p&gt;
&lt;p&gt;此时我打算将gdb更新到与22同步的版本，我们发现Ubuntu22版本中的gdb打印版本是不会出现—target=riscv之类字样的，只有gnu-linux。所以我再一次尝试编译完整的gdb，加上了&lt;code&gt;--enable-targets=all&lt;/code&gt;，此时我们可以直接更换launch的gdb为gdb了（之前只能gdb-multiarch或者riscv64，现在的gdb是融合了各种框架的超级缝合怪），进去后再次观察寄存器&amp;hellip;&amp;hellip;..还是一片空白&lt;/p&gt;
&lt;p&gt;又开始怀疑人生了，说好的gdb版本呢？痛定思痛后直接放弃了这个问题解决路线，让我们回到最开始的地方——到底那个奇怪的问题是怎么出现的？&lt;/p&gt;
&lt;h3 id=&#34;42直接解决问题&#34;&gt;4.2直接解决问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;💡太长不看版：
1、F5运行情况下在调试控制台中输入&lt;code&gt;-exec maintenance print xml-tdesc&lt;/code&gt; ，完整复制输出的内容后存放在根目录下的myxml.xml文件夹下（名字也可以看你喜欢修改）&lt;/p&gt;
&lt;p&gt;2、保存文件并结束调试，在根目录下运行&lt;code&gt;make clean&lt;/code&gt;
3、修改launch.json为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;configurations&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;debug xv6&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;cppdbg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;program&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;${workspaceFolder}/kernel/kernel&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;args&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;stopAtEntry&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;cwd&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;${workspaceFolder}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;miDebuggerServerAddress&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;127.0.0.1:26000&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//看你喜欢可以修改成什么能用的gdb，为了防止奇怪现象我选择了rv
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;miDebuggerPath&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/usr/local/bin/riscv64-unknown-elf-gdb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;environment&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;externalConsole&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;MIMode&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;gdb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;preLaunchTask&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;xv6build&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;setupCommands&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;pretty printing&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;-enable-pretty-printing&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;ignoreFailures&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;//在这里加载了寄存器信息表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;set tdesc filename myxml.xml&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//用于gdb调试的工具，可以发现gdb出错的原因
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// &amp;#34;logging&amp;#34;: {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//     &amp;#34;engineLogging&amp;#34;: true,
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;//     &amp;#34;programOutput&amp;#34;: true,
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3、F5运行后发现已经安静的停在main，此时你会发现寄存器恢复了
4、为了定制化xml，你可以修改内部结构但要遵守regnum排序，具体请自行尝试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;花了更多时间搜索log中提到的相关关键词，最后锁定了一个帖子：&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/72759791/why-does-gdb-do-not-show-all-risc-v-csrs-when-debugging-bare-metal-program-runni&#34;  title=&#34;https://stackoverflow.com/questions/72759791/why-does-gdb-do-not-show-all-risc-v-csrs-when-debugging-bare-metal-program-runni&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/72759791/why-does-gdb-do-not-show-all-risc-v-csrs-when-debugging-bare-metal-program-runni&lt;/a&gt;（非常关键的帖子不然要花更多时间搞明白）&lt;/p&gt;
&lt;p&gt;我一直在思考怎么才能&amp;quot;hack&amp;quot;gdb，也就是让他不去读取那个寄存器的信息（毕竟gdb只是一个程序！是程序就可以改），在这个帖子我找到了潜在的解决方法。我们通过&lt;code&gt;-exec maintenance print xml-tdesc&lt;/code&gt;成功在vscode看到了xml信息，根据描述我们知道gdb是通过qemu给的xml得到寄存器信息的，那么我们就有了一个想法，我们能不能不利用他给的xml进行寄存器读取，而是使用自己的xml呢？（因为它能保存，能保存就一定可以读取）&lt;/p&gt;
&lt;p&gt;一顿操作猛如虎我们找到了一个解决方法&lt;code&gt;set tdesc filename xxxxx&lt;/code&gt;其中xxx是你保存的xml的相对地址（这里我直接复制保存为一个新的xml了）。在里面我们发现了罪魁祸首ustatus直接进行删去操作，然后搓搓小手开始进行设置工作。&lt;/p&gt;
&lt;p&gt;一开始我很高兴他在运行中加载不会报错，但发现这样还是显示不了寄存器，也许他要在开头修改才有用？于是我修改了launch让他在开头加载&amp;hellip;&lt;/p&gt;
&lt;p&gt;成功点亮~&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 136; 
			flex-basis: 328px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WdKC737zp6.png&#34; data-size=&#34;823x602&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WdKC737zp6.png&#34;
			width=&#34;823&#34;
			height=&#34;602&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WdKC737zp6_hu7aa88fb39251c8c10e071f3b45a81d15_146309_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_WdKC737zp6_hu7aa88fb39251c8c10e071f3b45a81d15_146309_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;至此，我们能相对愉快的畅游vscode的调试世界了。&lt;/p&gt;
&lt;h2 id=&#34;五修复注释高亮&#34;&gt;五、修复注释高亮&lt;/h2&gt;
&lt;p&gt;这里我们用到了bear（具体原理可看jyy18课：），bear make创造的compile_commands.json 还需要让他生效&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;💡
你可以参考&lt;a class=&#34;link&#34; href=&#34;https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/&#34;  title=&#34;https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/&lt;/a&gt;中提到的方法
也可以使用这个教程：&lt;a class=&#34;link&#34; href=&#34;https://simplestupidcode.github.io/post/2022062501.html&#34;  title=&#34;https://simplestupidcode.github.io/post/2022062501.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://simplestupidcode.github.io/post/2022062501.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你还可以配合使用ctrl+p输入文件跳转文件与ctrl+p输入#加上函数名查找函数相应部分来辅助查找&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;（这里笔者尝试了第一步clang没有完全运行，会提示typedef的问题，按照第一个博主的说法做了还是不行，但是很神奇的在加入第二个博主的cpp_properties.json后就可以跑起来了也可以跳转&amp;hellip;.计算机真神奇啊，如果你不能用其中的一个成功跳转和兼容运行，可以尝试两个都加上，然后make clean后重新make 或者重启vscode与clang插件。）&lt;/p&gt;
&lt;h2 id=&#34;六调试控制台中省略exec&#34;&gt;六、调试控制台中省略exec&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;💡直接按照下列操作即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;偷懒要偷到底！此时我们发现每次都要输入-exec进行gdb操作，这未免有些太麻烦了（我观摩了vscode在github上被一群人锐kuang评pen，为了让vscode的调试控制台能更加接近gdb的原生体验，我们还需要进行进一步操作：&lt;/p&gt;
&lt;p&gt;1、在vscode中搜索插件multi-command&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 282; 
			flex-basis: 677px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_BK58mV711V.png&#34; data-size=&#34;223x79&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_BK58mV711V.png&#34;
			width=&#34;223&#34;
			height=&#34;79&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_BK58mV711V_hu2f846bf4fd13c49ecbecf35ed77aecd7_9861_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_BK58mV711V_hu2f846bf4fd13c49ecbecf35ed77aecd7_9861_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2、在.vscode中创建一个settings.json文件，内容为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;nt&#34;&gt;&amp;#34;multiCommand.commands&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;command&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;multiCommand.enterExec&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;#34;sequence&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
                &lt;span class=&#34;s2&#34;&gt;&amp;#34;repl.action.acceptInput&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;command&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;editor.action.insertSnippet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;args&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;snippet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;-exec &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3、分别按下ctrl+k  ctrl+s 或者在首选项中打开键盘快捷方式设置，在右上角找到并点击：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 70; 
			flex-basis: 169px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_w76fKHlduq.png&#34; data-size=&#34;254x360&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_w76fKHlduq.png&#34;
			width=&#34;254&#34;
			height=&#34;360&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_w76fKHlduq_hu28ff95e2a5be3c8d91d2fa1cd789a2c0_12697_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_w76fKHlduq_hu28ff95e2a5be3c8d91d2fa1cd789a2c0_12697_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时能看到keybindings.json，然后粘贴以下内容：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 472; 
			flex-basis: 1133px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_VpIXCCfCKs.png&#34; data-size=&#34;1421x301&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_VpIXCCfCKs.png&#34;
			width=&#34;1421&#34;
			height=&#34;301&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_VpIXCCfCKs_hu7f344a2275981d7d3d9311c50629ece0_67252_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_VpIXCCfCKs_hu7f344a2275981d7d3d9311c50629ece0_67252_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;key&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;enter&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;command&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;extension.multiCommand.execute&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;args&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;command&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;multiCommand.enterExec&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;#34;when&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;inDebugRepl&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来就重新开始调试，然后你会惊奇的发现回车的时候已经能够自动补全exec了，体验愉快使用原生gdb的快乐吧！&lt;/p&gt;
&lt;h2 id=&#34;七追踪函数调用的踪迹&#34;&gt;七、追踪函数调用的踪迹&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;💡
1、你需要下载&lt;a class=&#34;link&#34; href=&#34;https://jyywiki.cn/OS/2022/slides/29.slides#/2/2&#34;  title=&#34;jyy29课中提到的trace&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jyy29课中提到的trace&lt;/a&gt;，然后将它放在 根目录/mkfs 的文件夹下
2、如果你是ubuntu22.04系统，可以直接运行&lt;code&gt;gdb -ex &#39;source mkfs/trace.py&#39; mkfs/mkfs&lt;/code&gt;
如果你是ubuntu20.04系统，你可能会遇到一些问题，请参考下文提到的解决方法
3（可选）、如果你想看到更猛的状态机过程，你可以参考&lt;a class=&#34;link&#34; href=&#34;https://github.com/Alan-Lee123/TOSView&#34;  title=&#34;这个github&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这个github&lt;/a&gt;的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在代码的海洋中，用肉眼看代码显然是会超载的，也极其耗费时间；进行调试一步步看容易跳过关键步骤不得返回，令人懊恼不已，有什么方法可以让我们获得更快乐的debug体验？——trace，想想看超级武器strace，itrace吧，他能让我们一窥内核用户态的调用奥秘。（俗话说得好，读代码不如读执行）&lt;/p&gt;
&lt;p&gt;当然，如果想要更简单的方法，直接让gdb生成历史记录也是可以的，同样也可以类似pa中宏包裹的方式，自己做一个日志并保存输出到文本当中，这是所有程序都通用的一种方式。&lt;/p&gt;
&lt;p&gt;按照提示的操作后我们很自然可以得到结果（其他代码其实逻辑好理解一些，主要是文件系统写的实在是太邪门了）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 84; 
			flex-basis: 203px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_AM3t_6nFIT.png&#34; data-size=&#34;298x351&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_AM3t_6nFIT.png&#34;
			width=&#34;298&#34;
			height=&#34;351&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_AM3t_6nFIT_hu30c82abbae1316971f7f97f6e37d2d63_26092_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_AM3t_6nFIT_hu30c82abbae1316971f7f97f6e37d2d63_26092_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但你可能会想，我们能不能迁移到其他地方呢？我做了一些尝试（但也有一些问题，比如static的函数显示不了对应参数，内核调试没有尝试成功），如果你想体验或者魔改，可以参考改进我的方法看看能不能做的更好：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;TRACED&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;main ls&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;IGNORE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;buf fd&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;trace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gdb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Breakpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gdb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;selected_frame&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_valid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TRACED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;lvars&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sym&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sym&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sym&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sym&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_argument&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sym&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IGNORE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;bt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\033&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;[32m&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\033&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;[0m(&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lvars&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;)&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;older&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;    &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# won&amp;#39;t stop at this breakpoint&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;gdb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;target remote localhost:26000&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;gdb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;set prompt off&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;gdb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;set pagination off&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;gdb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;file ./user/_ls&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TRACED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;trace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将代码保存为mytrace放在根目录后执行&lt;code&gt;gdb -ex &#39;source mytrace.py&#39; &lt;/code&gt;，然后在其他地方&lt;code&gt;make qemu-gdb&lt;/code&gt; ，此时发现打开gdb的终端有反应了但没有开始，你需要输入c，回车后就发现xv6运行起来了，然后按下ls，你就可以看到他打印了对应的调用栈和参数了，但这个trace对于ls实在是杀鸡用牛刀（因为我们可以通过vscode调试就非常清楚流程了），我们可以在更复杂的情况（比如文件系统）下再使用它。但不管如何，我们的调试武器库又一次增加了。&lt;/p&gt;
&lt;h3 id=&#34;71-remote-g-packet-reply-is-too-long&#34;&gt;7.1 Remote &amp;lsquo;g&amp;rsquo; packet reply is too long&lt;/h3&gt;
&lt;p&gt;你可能会见到形如&amp;quot;Remote &amp;lsquo;g&amp;rsquo; packet reply is too long&amp;quot;相关的问题，这很可能是因为gdb版本不支持或者太低，你可以更改gdb为gdb-multiarch或者riscv64-unknown-elf-gdb，如果都不行，你需要重新编译升级gdb版本，可以选择7.2的方式，或者参考这个方式重新编译gdb：&lt;a class=&#34;link&#34; href=&#34;http://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html&#34;  title=&#34;http://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果还不能解决，你可以参考这里对这个问题的解决方法：&lt;a class=&#34;link&#34; href=&#34;https://github.com/Alan-Lee123/TOSView&#34;  title=&#34;https://github.com/Alan-Lee123/TOSView&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Alan-Lee123/TOSView&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;72海象运算符等python不支持的问题&#34;&gt;7.2海象运算符等python不支持的问题&lt;/h3&gt;
&lt;p&gt;注意：你可能会在这里遇到:=运算符的问题，这是编译gdb选择的python太低的问题，你需要重新编译过gdb的版本让他能够支持：&lt;/p&gt;
&lt;p&gt;首先参考4.1下载gdb源码，然后进入主页面后分别运行&lt;/p&gt;
&lt;p&gt;(这个相当于选择菜单，我选择编译了支持全体系结构的gdb，同时内置python版本是3.8）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;./configure --with-python&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/bin/python3.8  --enable-targets&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;all --enable-64-bit-bfd
make -j8
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装成功后再次运行即可成功！&lt;/p&gt;
&lt;h3 id=&#34;73-参数显示optimized-out&#34;&gt;7.3 参数显示&amp;lt;&lt;em&gt;optimized out&lt;/em&gt;&amp;gt;&lt;/h3&gt;
&lt;p&gt;如标题所示，我们只需要降低优化等级就好，在makefile中找到-o2改成-o0，并且注意到有关编译选项中有-o需要改成-o2（比如调试内核中的），修改后重新编译就可以解决问题&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 148; 
			flex-basis: 355px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_5DtGLdqA-i.png&#34; data-size=&#34;646x436&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_5DtGLdqA-i.png&#34;
			width=&#34;646&#34;
			height=&#34;436&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_5DtGLdqA-i_hu64637bcfd45f422f4b259c705d552dad_72831_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E8%AF%95%E5%9C%A8vscode%E4%B8%8A%E5%AE%8C%E7%BE%8E%E8%B0%83%E8%AF%95xv6%E5%AE%8C%E7%BB%93/image/image_5DtGLdqA-i_hu64637bcfd45f422f4b259c705d552dad_72831_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;外传vscode和gdb是如何工作的&#34;&gt;外传：vscode和gdb是如何工作的？&lt;/h2&gt;
&lt;p&gt;通过一波探索，我们对vscode的运行原理有了一点好奇心（当然对gdb调试也有，为什么要tcp？）&lt;/p&gt;
&lt;p&gt;我找到了这些相关资料（有空再写个博客好了）：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://fed.taobao.org/blog/taofed/do71ct/vscode-debug-source-analyse/&#34;  title=&#34;https://fed.taobao.org/blog/taofed/do71ct/vscode-debug-source-analyse/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://fed.taobao.org/blog/taofed/do71ct/vscode-debug-source-analyse/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/m0_37621078/article/details/113886458&#34;  title=&#34;https://blog.csdn.net/m0_37621078/article/details/113886458&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/m0_37621078/article/details/113886458&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有关断点的故事也有很多可以说&amp;hellip;比如通过更换Int3中断指令使得断点可以生效，等到结束恢复为原来的指令。（这也是为什么优化等级高了有时候停不下来，因为没有对应的指令可以替换）&lt;/p&gt;
&lt;p&gt;谢谢你看到最后，如果有问题或者有更优雅的方式欢迎提出或者发送邮件:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:physicoada@gmail.com&#34; &gt;physicoada@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也欢迎来我的github来找我玩：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sanbuphy&#34;  title=&#34;https://github.com/sanbuphy&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/sanbuphy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;h3 id=&#34;基本环节的打通&#34;&gt;基本环节的打通&lt;/h3&gt;
&lt;p&gt;MIT 6.S081 xv6调试不完全指北（包含了常见问题）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html&#34;  title=&#34;https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从零开始使用Vscode调试XV6（包含了task与launch）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/501901665&#34;  title=&#34;https://zhuanlan.zhihu.com/p/501901665&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/501901665&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.S081的调试和VSCode环境配置（代码提示和自动补全以及风格化）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/&#34;  title=&#34;https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果gdb调试报错Cannot access memory at address，也许需要在.gdbinit.tmpl-riscv加一条set riscv use-compressed-breakpoints yes&lt;/p&gt;
&lt;h3 id=&#34;有关gdb问题的排查&#34;&gt;有关gdb问题的排查&lt;/h3&gt;
&lt;p&gt;编译gdb最新版&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/32773255/how-to-update-gdb-to-most-current-stable-version&#34;  title=&#34;https://stackoverflow.com/questions/32773255/how-to-update-gdb-to-most-current-stable-version&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/32773255/how-to-update-gdb-to-most-current-stable-version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打印寄存器相关xml文件&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/72759791/why-does-gdb-do-not-show-all-risc-v-csrs-when-debugging-bare-metal-program-runni&#34;  title=&#34;https://stackoverflow.com/questions/72759791/why-does-gdb-do-not-show-all-risc-v-csrs-when-debugging-bare-metal-program-runni&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/72759791/why-does-gdb-do-not-show-all-risc-v-csrs-when-debugging-bare-metal-program-runni&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改寄存器定义&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/abeldeng/article/details/80325364&#34;  title=&#34;https://blog.csdn.net/abeldeng/article/details/80325364&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/abeldeng/article/details/80325364&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;有关vscode配置&#34;&gt;有关vscode配置&lt;/h3&gt;
&lt;p&gt;launch的一些参数讲解&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/ZCShouCSDN/article/details/60466707&#34;  title=&#34;https://blog.csdn.net/ZCShouCSDN/article/details/60466707&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/ZCShouCSDN/article/details/60466707&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;优雅的配置launch.json：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.barretlee.com/blog/2019/03/18/debugging-in-vscode-tutorial/&#34;  title=&#34;https://www.barretlee.com/blog/2019/03/18/debugging-in-vscode-tutorial/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.barretlee.com/blog/2019/03/18/debugging-in-vscode-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;exec省略&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Microsoft/vscode-cpptools/issues/106#issuecomment-829008826&#34;  title=&#34;https://github.com/Microsoft/vscode-cpptools/issues/106#issuecomment-829008826&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Microsoft/vscode-cpptools/issues/106#issuecomment-829008826&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.lagerdata.com/articles/vscode-and-gdb&#34;  title=&#34;https://www.lagerdata.com/articles/vscode-and-gdb&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.lagerdata.com/articles/vscode-and-gdb&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>NJU计算机课程基础实验 PA4笔记（大结局）</title>
        <link>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/</link>
        <pubDate>Fri, 16 Sep 2022 08:50:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/</guid>
        <description>&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 132; 
			flex-basis: 316px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP.png&#34; data-size=&#34;940x712&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP.png&#34;
			width=&#34;940&#34;
			height=&#34;712&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP_huf038ba577edd80746ac2e351fb231b7f_213902_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP_huf038ba577edd80746ac2e351fb231b7f_213902_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从这我越来越感受到系统复杂度上升带来的挑战，也明白了抽象的根本目的。&lt;/p&gt;
&lt;p&gt;抽象是为了降低复杂度，为了系统能够更好的做大以及稳健和排错。&lt;/p&gt;
&lt;p&gt;而且抽象能让你切换不同的“后续程序”进行测试，甚至在大概率正确的载体上进行diff查看到底是哪一层出现了问题（参考各种native）&lt;/p&gt;
&lt;p&gt;如何相信抽象是对的？——对每一个抽象层完成后的充分测试。&lt;/p&gt;
&lt;p&gt;善用assert是魔法！&lt;/p&gt;
&lt;p&gt;（个人能力受限，挂在了2阶的最后pal阶段。。。也许有机会能请教大佬解决一下，这样就可以做第三阶段了，很可惜，但也只能这样了。）&lt;/p&gt;
&lt;p&gt;菜得承认，我的能力可能暂时就到此为止了；还是很想做完的，但是从时间成本和能力估计上是不行了。。。&lt;/p&gt;
&lt;p&gt;等以后变强了再挑战一次。&lt;/p&gt;
&lt;p&gt;2022年9月16日记&lt;/p&gt;
&lt;h2 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;自从有了上下文切换后，程序也就有了进程的概念。（从静止到运动的飞跃 ~~·）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设进程A运行的过程中触发了系统调用, 陷入到内核. 根据&lt;code&gt;__am_asm_trap()&lt;/code&gt;的代码, A的上下文结构(&lt;code&gt;Context&lt;/code&gt;)将会被保存到A的栈上. 在PA3中, 系统调用处理完毕之后, &lt;code&gt;__am_asm_trap()&lt;/code&gt;会根据栈上保存的上下文结构来恢复A的上下文.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 173; 
			flex-basis: 417px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-.png&#34; data-size=&#34;1135x653&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-.png&#34;
			width=&#34;1135&#34;
			height=&#34;653&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-_huf31f56de2e5ca741e461353f125fd95c_98535_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-_huf31f56de2e5ca741e461353f125fd95c_98535_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们先不着急恢复A的上下文, 而是先将栈顶指针切换到另一个进程B的栈上, 那会发生什么呢? 由于B的栈上存放了之前B保存的上下文结构, 接下来的操作就会根据这一结构来恢复B的上下文. 
上下文切换其实就是不同进程之间的栈切换!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;进程控制块&#34;&gt;进程控制块&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有不少信息都是进程相关的, 除了刚才提到的上下文指针&lt;code&gt;cp&lt;/code&gt;之外, 上文提到的栈空间也是如此. 
为了方便对这些进程相关的信息进行管理, 操作系统使用一种叫进程控制块(PCB, process control block)的数据结构, 为每一个进程维护一个PCB.
Nanos-lite使用一个联合体来把其它信息放置在进程堆栈的底部. 代码为每一个进程分配了一个32KB的堆栈, 已经足够使用了, 不会出现栈溢出导致UB. 
在进行上下文切换的时候, &lt;strong&gt;只需要把PCB中的&lt;/strong&gt;&lt;code&gt;cp&lt;/code&gt;指针返回给CTE的&lt;code&gt;__am_irq_handle()&lt;/code&gt;函数即可, 剩余部分的代码会根据上下文结构恢复上下文.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;内核线程&#34;&gt;内核线程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对于刚刚加载完的进程, 我们要怎么切换到它来让它运行起来呢??
答案很简单, 我们只需要在&lt;strong&gt;进程的栈上人工创建一个上下文结构, 使得将来切换的时候可以根据这个结构来正确地恢复上下文即可.&lt;/strong&gt;
我们先把Nanos-lite中直接定义的一些测试函数作为程序. Nanos-lite提供了一个测试函数&lt;code&gt;hello_fun()&lt;/code&gt;(在&lt;code&gt;nanos-lite/src/proc.c&lt;/code&gt;中定义), 
我们接下来的任务就是&lt;strong&gt;为它创建一个上下文, 然后切换到它来执行. 这样的执行流有一个专门的名称, 叫&amp;quot;内核线程&amp;quot;(kernel thread).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建内核线程的上下文是通过CTE提供的&lt;code&gt;kcontext()&lt;/code&gt;函数 (在&lt;code&gt;abstract-machine/am/src/$ISA/nemu/cte.c&lt;/code&gt;中定义)来实现的,
在Nanos-lite中, 我们可以通过一个&lt;code&gt;context_kload()&lt;/code&gt;函数来进行进一步的封装: 它会调用&lt;code&gt;kcontext()&lt;/code&gt;来创建上下文, 并把返回的指针记录到PCB的&lt;code&gt;cp&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;上下文的创建和切换是CTE的工作, 而具体切换到哪个上下文, 则是由操作系统来决定的, 这项任务叫做进程调度
进程调度是由&lt;code&gt;schedule()&lt;/code&gt;函数(在&lt;code&gt;nanos-lite/src/proc.c&lt;/code&gt;中定义)来完成的, 它用于返回将要调度的进程上下文. 因此, 我们需要一种方式来记录当前正在运行哪一个进程, 这样我们才能在&lt;code&gt;schedule()&lt;/code&gt;中返回另一个进程的上下文&lt;/p&gt;
&lt;p&gt;我们让&lt;code&gt;schedule()&lt;/code&gt;总是切换到&lt;code&gt;pcb[0]&lt;/code&gt;. 注意它的上下文是通过&lt;code&gt;kcontext()&lt;/code&gt;创建的, 在&lt;code&gt;schedule()&lt;/code&gt;中才决定要切换到它, 然后在CTE的&lt;code&gt;__am_asm_trap()&lt;/code&gt;中才真正地恢复这一上下文.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;努力理解了一下，然后写了个汇编，成功点亮~（主要卡在kcontex如何传送area）&lt;/p&gt;
&lt;p&gt;这里还要思考一下area到底怎么才是对的。开头地址kstack.start应该拿谁？那段空间应该从哪边开始界定（这也是需要理解的坑）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 175; 
			flex-basis: 422px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH.png&#34; data-size=&#34;1311x745&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH.png&#34;
			width=&#34;1311&#34;
			height=&#34;745&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH_hubf41834a42365016cbfb0ee37f101bf5_172943_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH_hubf41834a42365016cbfb0ee37f101bf5_172943_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;内核线程的参数&#34;&gt;内核线程的参数&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt; 我们来创建两个内核线程, 给它们传递不同的参数, 然后在输出的信息中把参数也一同输出, 这样我们就能看到执行流在两个内核线程之间来回切换了!
 我们只需要让&lt;code&gt;kcontext()&lt;/code&gt;按照调用约定将&lt;code&gt;arg&lt;/code&gt;放置在正确的位置, 将来&lt;code&gt;hello_fun()&lt;/code&gt;执行的时候就可以获取正确的参数了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感叹这个设计真聪明~&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 139; 
			flex-basis: 334px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG.png&#34; data-size=&#34;905x650&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG.png&#34;
			width=&#34;905&#34;
			height=&#34;650&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG_hu6825840c146c0bb1968a5e6c3a0d7421_240366_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG_hu6825840c146c0bb1968a5e6c3a0d7421_240366_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;实现上下文切换2&#34;&gt;实现上下文切换(2)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;根据讲义的上述内容, 实现以下功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改CTE的&lt;code&gt;kcontext()&lt;/code&gt;函数, 使其支持参数&lt;code&gt;arg&lt;/code&gt;的传递&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;kcontext()&lt;/code&gt;创建第二个以&lt;code&gt;hello_fun()&lt;/code&gt;为入口的内核线程, 并传递不同的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改Nanos-lite的&lt;code&gt;schedule()&lt;/code&gt;函数, 使其轮流返回两个上下文&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以自行约定用何种类型来解析参数&lt;code&gt;arg&lt;/code&gt;(整数, 字符, 字符串, 指针等皆可), 然后修改&lt;code&gt;hello_fun()&lt;/code&gt;中的输出代码, 来按照你约定的方式解析&lt;code&gt;arg&lt;/code&gt;. 如果你的实现正确, 你将会看到&lt;code&gt;hello_fun()&lt;/code&gt;会轮流输出不同参数的信息.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里要想想，riscv用什么方法传参呢？然后思考一下会不会和我们之前的操作有没有冲突（本质是执行顺序的问题，实际上没任何问题）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 196; 
			flex-basis: 471px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I.png&#34; data-size=&#34;1258x640&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I.png&#34;
			width=&#34;1258&#34;
			height=&#34;640&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I_hu2f96352309cbf87b75e1eed08bd7f30a_339627_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I_hu2f96352309cbf87b75e1eed08bd7f30a_339627_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为什么这里叫做内核线程？我的想法是因为他在nanos内部调用实现，并且可以达到快速的执行流切换的效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在真实的操作系统中, 内核中的很多后台任务, 守护服务和驱动程序都是以内核线程的形式存在的. 如果你执行&lt;code&gt;ps aux&lt;/code&gt;, 你就会看到系统中有很多COMMAND中带有中括号的内核线程(例如&lt;code&gt;[kthreadd]&lt;/code&gt;). 而创建和执行它们的原理, 也是和上面的实验内容非常相似(当然具体实现肯定会有所不同).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有关一些调用约定：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 178; 
			flex-basis: 428px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6.png&#34; data-size=&#34;1322x741&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6.png&#34;
			width=&#34;1322&#34;
			height=&#34;741&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6_hu96d4f11f8d37cd358584726cb84f5dbc_136056_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6_hu96d4f11f8d37cd358584726cb84f5dbc_136056_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;用户进程&#34;&gt;用户进程&lt;/h2&gt;
&lt;h4 id=&#34;创建用户进程上下文&#34;&gt;创建用户进程上下文&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在PA3的批处理系统中, 我们在&lt;code&gt;naive_uload()&lt;/code&gt;中直接通过函数调用转移到用户进程的代码, &lt;strong&gt;那时候使用的还是内核区的栈&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么知道的？因为naive_uload跳转的entry本质是在nanos的时候调用函数，出入栈都在内部完成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果内核线程发生了栈溢出, 怎么办?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果能检测出来, 最好的方法就是触发kernel panic, 因为这时候内核的数据已经不再可信, 如果将一个被破坏的数据写回磁盘, 将会造成无法恢复的毁灭性损坏.&lt;/p&gt;
&lt;p&gt;好消息是, 内核线程的正确性可以由内核开发人员来保证, 这至少要比保证那些来路不明的用户进程的正确性要简单多了. 而坏消息则是, 大部分的内核bug都是第三方驱动程序导致的: 栈溢出算是少见的了, 更多的是use-after-free, double-free, 还有难以捉摸的并发bug. 而面对海量的第三方驱动程序, 内核开发人员也难以逐一保证其正确性. 如果你想到一个可以提升驱动程序代码质量的方法, 那就是为计算机系统领域作出贡献了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Nanos-lite和Navy作了一项约定: Nanos-lite把栈顶位置设置到GPRx中&lt;/strong&gt;, 然后由Navy里面的&lt;code&gt;_start&lt;/code&gt;来&lt;strong&gt;把栈顶位置真正设置到栈指针寄存器中&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我实现后一直出不来。。（首先记得不能在init加载程序了）&lt;/p&gt;
&lt;p&gt;最后发现原来是局部变量和全局的问题（我把参数设置在init，init结束后在stack上的参数自动没了。。。所以就找不到了），最好的方法是直接传入或者是全局变量&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 166; 
			flex-basis: 399px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9.png&#34; data-size=&#34;1251x751&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9.png&#34;
			width=&#34;1251&#34;
			height=&#34;751&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9_hucff7b6b7a0255a3657221407d9ef714c_333414_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9_hucff7b6b7a0255a3657221407d9ef714c_333414_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时有点“一起卡”的感觉，本质是因为pal 的屏幕io的时候就切换去跑hello了。（yield）&lt;/p&gt;
&lt;h4 id=&#34;问如何验证仙剑奇侠传确实在使用用户栈而不是内核栈&#34;&gt;问：如何验证仙剑奇侠传确实在使用用户栈而不是内核栈?&lt;/h4&gt;
&lt;p&gt;只要获取pal内部的地址信息在什么范围即可。&lt;/p&gt;
&lt;p&gt;还好检查了一下这个，一看发现我的pal还是在内核，直接翻车- -&lt;/p&gt;
&lt;p&gt;后面思考了一下发现应该是stack分配的问题。。这点上讲义确实不骗人 老老实实实现就行了。&lt;/p&gt;
&lt;p&gt;认真注意这句话：“目前我们让Nanos-lite把&lt;code&gt;heap.end&lt;/code&gt;作为用户进程的栈顶, 然后把这个栈顶赋给用户进程的栈指针寄存器就可以了.”&lt;/p&gt;
&lt;h3 id=&#34;用户进程的参数&#34;&gt;用户进程的参数&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;最适合存放参数和环境变量的地方就是用户栈了, 因为在&lt;strong&gt;首次切换到用户进程的时候, 用户栈上的内容就已经可以被用户进程访问. 于是操作系统在加载用户进程的时候&lt;/strong&gt;, 还需要负责把&lt;code&gt;argc/argv/envp&lt;/code&gt;以及相应的字符串放在用户栈中,
把它们的存放方式和位置作为和用户进程的约定之一, 这样用户进程在&lt;code&gt;_start&lt;/code&gt;中就可以根据约定访问它们了.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/riscv-non-isa/riscv-elf-psabi-doc&#34;  title=&#34;https://github.com/riscv-non-isa/riscv-elf-psabi-doc&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/riscv-non-isa/riscv-elf-psabi-doc&lt;/a&gt;
ABI手册有一节Process Initialization的内容, **里面详细约定了操作系统需要为用户进程的初始化提供哪些信息. **不过在我们的Project-N系统里面, 我们只需要一个简化版的Process Initialization就够了: 操作系统将&lt;code&gt;argc/argv/envp&lt;/code&gt;及其相关内容放置到用户栈上, 然后将GPRx设置为&lt;code&gt;argc&lt;/code&gt;所在的地址.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里遇到了一个问题，数组一旦作为参数传入后就退化成了指针，我们怎么才能求得正确的大小呢？一个机智的方式是在末尾留个NULL（很多东西都参考了这个设计），这样就可以随意遍历求得数组大小了。&lt;/p&gt;
&lt;p&gt;每次操作差点忘记操作栈顶导致翻车，一顿操作猛如虎安排好了用户栈的空间状况，成功跳过开头。（pal的代码写的确实比较通俗）&lt;/p&gt;
&lt;h3 id=&#34;实现带参数的sys_execve&#34;&gt;实现带参数的SYS_execve&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用户进程的参数还是应该由用户来指定的.最好能有一个方法能把用户指定的参数告诉操作系统, &lt;/p&gt;
&lt;p&gt;让操作系统来把指定的参数放到新进程的用户栈里面. &lt;/p&gt;
&lt;p&gt;为了实现带参数的&lt;code&gt;SYS_execve&lt;/code&gt;, 我们可以在&lt;code&gt;sys_execve()&lt;/code&gt;中直接调用&lt;code&gt;context_uload()&lt;/code&gt;. 但我们还需要考虑如下的一些细节, 为了方便描述, 我们假设用户进程A将要通过&lt;code&gt;SYS_execve&lt;/code&gt;来执行另一个新程序B.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何在A的执行流中创建用户进程B?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何结束A的执行流?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以从栈底(&lt;code&gt;heap.end&lt;/code&gt;)到栈顶(栈指针&lt;code&gt;sp&lt;/code&gt;当前的位置)列出用户栈中的内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Nanos-lite之前为A传递的用户进程参数(&lt;code&gt;argc/argv/envp&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A从&lt;code&gt;_start&lt;/code&gt;开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了libos中的&lt;code&gt;execve()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CTE保存的上下文结构,&lt;/strong&gt; 这是由于A在&lt;code&gt;execve()&lt;/code&gt;中执行了系统调用自陷指令导致的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nanos-lite从&lt;code&gt;__am_irq_handle()&lt;/code&gt;开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了&lt;code&gt;SYS_execve&lt;/code&gt;的系统调用处理函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上述分析, 我们得出一个重要的结论: &lt;strong&gt;在加载B时, Nanos-lite使用的是A的用户栈! 这意味着在A的执行流结束之前, A的用户栈是不能被破坏的.&lt;/strong&gt; 因此&lt;code&gt;heap.end&lt;/code&gt;附近的用户栈是不能被B复用的, 我们应该申请一段新的内存作为B的用户栈&lt;/p&gt;
&lt;p&gt;可以让&lt;code&gt;context_uload()&lt;/code&gt;统一通过调用&lt;code&gt;new_page()&lt;/code&gt;函数来获得用户栈的内存空间. &lt;code&gt;new_page()&lt;/code&gt;函数在&lt;code&gt;nanos-lite/src/mm.c&lt;/code&gt;中定义, 它会通过一个&lt;code&gt;pf&lt;/code&gt;指针来管理堆区, 用于分配一段大小为&lt;code&gt;nr_page * 4KB&lt;/code&gt;的连续内存区域, 并返回这段区域的首地址. 我们让&lt;code&gt;context_uload()&lt;/code&gt;通过&lt;code&gt;new_page()&lt;/code&gt;来分配32KB的内存作为用户栈, 这对PA中的用户程序来说已经足够使用了.&lt;/p&gt;
&lt;p&gt;操作系统作为一个特殊的AM应用, 很多时候对动态内存申请却有更严格的要求, 例如申请一段起始地址是4KB整数倍的内存区域, &lt;code&gt;malloc()&lt;/code&gt;通常不能满足这样的要求. 因此操作系统一般都会自己来管理堆区, 而不会调用klib中的&lt;code&gt;malloc()&lt;/code&gt;. 在操作系统中管理堆区是MM(Memory Manager)模块的工作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始理解错了什么是A还以为hello是A。。。。。然后被提醒后看了好几遍发现原来是这个意思= = （联系一下PA的上文，搞清楚到底是什么进程，这个进程在当下是什么，要换成什么进程）&lt;/p&gt;
&lt;p&gt;一顿操作猛如虎成功：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 178; 
			flex-basis: 428px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf.png&#34; data-size=&#34;961x538&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf.png&#34;
			width=&#34;961&#34;
			height=&#34;538&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf_hu89c0292a312d4e22346b78e5a0994d81_110717_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf_hu89c0292a312d4e22346b78e5a0994d81_110717_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里运行nterm又挂了（其他都可以）我哭了- - 又开始排查问题，发现传入argc就会挂。。。具体原因不明，又要继续排查。最后发现是argv飞掉的问题（没有参数的时候如果传入指针拦不住）&lt;/p&gt;
&lt;p&gt;总结：你必须搞清楚上下文是怎么从创建到调度的全过程，这样才能理解关键的每一个细节。&lt;/p&gt;
&lt;h3 id=&#34;运行busybox&#34;&gt;运行Busybox&lt;/h3&gt;
&lt;p&gt;我的不知道为啥遇到了致命的ld错误。。。。没办法跑&lt;/p&gt;
&lt;p&gt;只能放弃了（很神奇的ld符号缺失）&lt;/p&gt;
&lt;p&gt;虽然我后面暴力调整了源码可以编译通过了- -但是只能cat之类的基础功能。。。&lt;/p&gt;
&lt;p&gt;然后不知道为什么让虚拟机走了几次快照，就可以用了- -只能说计算机真神奇呀。。。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 109; 
			flex-basis: 263px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd.png&#34; data-size=&#34;843x768&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd.png&#34;
			width=&#34;843&#34;
			height=&#34;768&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd_hu8d58ac57acda53aed754cdf7ab7e0056_178726_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd_hu8d58ac57acda53aed754cdf7ab7e0056_178726_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;WC也完美运行~&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 200; 
			flex-basis: 481px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye.png&#34; data-size=&#34;1366x681&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye.png&#34;
			width=&#34;1366&#34;
			height=&#34;681&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye_huc7dd563df2f31cd43c6ff8efd483cd5c_378066_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye_huc7dd563df2f31cd43c6ff8efd483cd5c_378066_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;—skip也同理完结~ 这阶段最主要的就是麻烦。。很多时候可能一不小心argv就会爆炸。&lt;/p&gt;
&lt;p&gt;第一阶段结束,这一阶段的关键就是1：上下文执行流是怎么保存和切换的 2：有关参数的指针小练习&lt;/p&gt;
&lt;p&gt;以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终端如何读取用户的按键?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各种等待键盘事件。。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shell如何进行命令的解析?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以类似eval,然后要注意argv的维护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;库函数如何根据命令解析出的字符串搜索到可执行文件?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;execvp，维护了一个PATH&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统如何加载执行一个可执行文件?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;维护参数表进入一个_start，处理后才进行真正的main（上下文切换和跳转）&lt;/p&gt;
&lt;h2 id=&#34;程序和内存位置很感人的阅读环节&#34;&gt;程序和内存位置（很感人的阅读环节）&lt;/h2&gt;
&lt;h3 id=&#34;绝对代码&#34;&gt;绝对代码&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一般来说, 程序的内存位置是在&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Link_time&#34;  title=&#34;链接时刻(link time)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;链接时刻(link time)&lt;/a&gt;确定的(Navy-apps中的程序就是这样), 以前的程序员甚至在程序中使用绝对地址来进行内存访问, 这两种代码称为绝对代码(absolute code). &lt;/p&gt;
&lt;p&gt;绝对代码会假设程序中的对象(函数和数据)位于某个固定的位置, 绝对代码只能在固定的内存位置才能正确运行.&lt;/p&gt;
&lt;p&gt;操作系统在加载时刻分配的空闲内存位置, 并不总是能让这种程序正确运行. &lt;/p&gt;
&lt;p&gt;因此, 这个问题的一个解决方案, 就是让操作系统记录程序的加载位置, 当一个程序试图加载到一个已经被使用的内存位置时, 加载将会失败, 操作系统将返回一个错误. 为了避免加载失败, 一个方法是&lt;strong&gt;为每个程序维护多个不同加载地址的版本&lt;/strong&gt;, 期望其中有一个版本可以被成功加载.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;可重定位代码&#34;&gt;可重定位代码&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么一定要提前确定一个程序的加载位置呢? 如果我们把链接时的重定位阶段往后推迟, 不就可以打破绝对代码的限制了吗?&lt;/p&gt;
&lt;p&gt;于是有程序员开发了一类&amp;quot;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Self-relocation&#34;  title=&#34;自重定位(self-relocation)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自重定位(self-relocation)&lt;/a&gt;&amp;ldquo;的特殊程序, 这种程序可以**在开始运行的时候, 先把自己重定位到其它内存位置, **然后再开始真正的运行. 这种重定位类型称为&amp;rdquo;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Run_time_%5c%28program_lifecycle_phase%5c%29&#34;  title=&#34;运行时(run time)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;运行时(run time)&lt;/a&gt;重定位&amp;quot;.&lt;/p&gt;
&lt;p&gt;但对多任务操作系统来说, 这并没有真正解决问题, 因为程序在运行时刻并不知道重定位的&lt;strong&gt;目标内存位置是否空闲&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;既然只有操作系统才知道内存是否空闲, 那就干脆让加载器来进行重定位吧, 于是有了&amp;quot;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Loader_%5c%28computing%5c%29&#34;  title=&#34;加载时(load time)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;加载时(load time)&lt;/a&gt;重定位&amp;quot;的说法. &lt;/p&gt;
&lt;p&gt;具体地, &lt;strong&gt;加载器会申请一个空闲的内存位置, 然后将程序加载到这个内存位置, 并把程序重定位到这个内存位置, 之后才会执行这个程序&lt;/strong&gt;. 今天的GNU/Linux就是通过这种方式来插入&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Loadable_kernel_module&#34;  title=&#34;内核模块&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;内核模块&lt;/a&gt;的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;位置无关代码-pic&#34;&gt;位置无关代码 PIC&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有没有方法可以节省重定位的开销, 甚至不进行重定位呢? 但链接时的重定位又可能会产生绝对代码, 这并不是我们所希望的 &lt;strong&gt;. 如果程序中的所有寻址, 都是针对程序位置来进行相对寻址操作, 这样的程序就可以被加载到任意位置执行, 而不会出现绝对代码的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Position-independent_code&#34;  title=&#34;PIC(position-independent code, 位置无关代码)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PIC(position-independent code, 位置无关代码)&lt;/a&gt;的基本思想. 今天的动态库都是PIC, 这样它们就可以被加载到任意的内存位置了. 此外, 如果一个可执行文件全部由PIC组成, 那么它有一个新名字, 叫&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Position-independent_code#PIE&#34;  title=&#34;PIE(position-independent executable, 位置无关可执行文件)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PIE(position-independent executable, 位置无关可执行文件)&lt;/a&gt;. 编译器可以通过特定的选项编译出PIE.&lt;/p&gt;
&lt;p&gt;PIE之所以能做到位置无关, 其实是要依赖于程序中一个叫&lt;a class=&#34;link&#34; href=&#34;https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html&#34;  title=&#34;GOT(global offset table, 全局偏移量表)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GOT(global offset table, 全局偏移量表)&lt;/a&gt;的数据结构&lt;/p&gt;
&lt;p&gt; 但总有一些包含绝对代码的程序, 考虑到兼容问题, 还需要想办法运行它们. 有没有更好的, 一劳永逸的方案呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;虚实交错的魔法&#34;&gt;虚实交错的魔法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;绝对代码经过编译链接之后, 程序看到的内存地址就会确定下来了, 加载运行的时候就会让程序使用这一内存地址, 来保证程序可以正确运行. 
一种尝试是&lt;strong&gt;把程序看到的内存和它运行时候真正使用的内存解耦开来&lt;/strong&gt;. 这就是虚拟内存的思想.&lt;/p&gt;
&lt;p&gt;有了虚拟内存之后, 进程只需要认为自己运行在虚拟地址上就可以了, 真正运行的时候, 才把虚拟地址映射到物理地址. &lt;/p&gt;
&lt;p&gt;我们只要**把程序链接到一个固定的虚拟地址, 加载的时候把它们加载到不同的物理地址, 并维护好虚拟地址到物理地址的映射关系, **&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键：&lt;strong&gt;硬件把物理地址映射成虚拟地址，维护地址映射功能。操作系统决定具体要把虚拟地址映射到哪些物理地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虚拟内存机制是一个&lt;strong&gt;软硬协同&lt;/strong&gt;才能工作的机制:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;操作系统加载进程的时候决定要&lt;strong&gt;把进程的虚拟地址映射到哪些物理地址&lt;/strong&gt;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等到进程真正运行之前, 还需要&lt;strong&gt;配置MMU, 把之前决定好的映射落实到硬件&lt;/strong&gt;上, &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程运行的时候, &lt;strong&gt;MMU就会进行地址转换, 把进程的虚拟地址映射&lt;/strong&gt;到操作系统希望的物理地址. &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（注意到这个映射是进程相关的: 不同的进程有不同的映射,）&lt;/p&gt;
&lt;h3 id=&#34;分段&#34;&gt;分段&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;MMU地址映射最简单的方法就是, 物理地址=虚拟地址+偏移量。即段式虚拟内存管理机制, 简称分段机制. &lt;/p&gt;
&lt;p&gt;把物理内存划分成若干个段, 不同的进程就放到不同的段中运行, 进程不需要关心自己具体在哪一个段里面, &lt;strong&gt;操作系统只要让不同的进程使用不同的偏移，进程之间就不会相互干扰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Minix就是这样工作的, 一些简单的嵌入式系统和实时系统, 也是通过分段机制来进行虚存管理.&lt;/p&gt;
&lt;p&gt;但是很复杂+性能不高，实际上现在没什么人用这个了。。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;超越容量的界限&#34;&gt;超越容量的界限&lt;/h2&gt;
&lt;p&gt;这部分我看的有点吃力，参考了一些其他资料：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/jinking01/article/details/107098437&#34;  title=&#34;https://blog.csdn.net/jinking01/article/details/107098437&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/jinking01/article/details/107098437&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/starter_____/article/details/100998087&#34;  title=&#34;https://blog.csdn.net/starter_____/article/details/100998087&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/starter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/starter&lt;/a&gt;____ _/article/details/100998087&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wkfvawl/p/11700301.html&#34;  title=&#34;https://www.cnblogs.com/wkfvawl/p/11700301.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/wkfvawl/p/11700301.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么 Linux 默认页大小是 4KB&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/whys-the-design-linux-default-page/&#34;  title=&#34;https://draveness.me/whys-the-design-linux-default-page/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://draveness.me/whys-the-design-linux-default-page/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 481; 
			flex-basis: 1155px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O.png&#34; data-size=&#34;761x158&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O.png&#34;
			width=&#34;761&#34;
			height=&#34;158&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O_hu2b25d731c012c3d86e57bfc163c3d243_14443_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O_hu2b25d731c012c3d86e57bfc163c3d243_14443_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 422; 
			flex-basis: 1013px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV.png&#34; data-size=&#34;1140x270&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV.png&#34;
			width=&#34;1140&#34;
			height=&#34;270&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV_hue566954d002d955be1fd5cdd1e5bedcf_147730_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV_hue566954d002d955be1fd5cdd1e5bedcf_147730_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 166; 
			flex-basis: 400px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG.png&#34; data-size=&#34;906x543&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG.png&#34;
			width=&#34;906&#34;
			height=&#34;543&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG_huff1a274ec48f98d977bbd525804756b0_116391_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG_huff1a274ec48f98d977bbd525804756b0_116391_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 288; 
			flex-basis: 692px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M.png&#34; data-size=&#34;1125x390&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M.png&#34;
			width=&#34;1125&#34;
			height=&#34;390&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M_hu48316f3178380908df55f2c32e1ce1a2_157709_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M_hu48316f3178380908df55f2c32e1ce1a2_157709_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中页目录项和页表项的结构是&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 235; 
			flex-basis: 565px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB.png&#34; data-size=&#34;818x347&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB.png&#34;
			width=&#34;818&#34;
			height=&#34;347&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB_huf796f3770f439a47202c86cddaec60f2_35820_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB_huf796f3770f439a47202c86cddaec60f2_35820_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;present位表示物理页是否可用, 不可用的时候又分两种情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;物理页面由于交换技术被交换到磁盘中了, Page fault&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图访问一个未映射的线性地址, 并没有实际的物理页与之相对应, 就是一个非法操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R/W位表示物理页是否可写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;U/S位表示访问物理页所需要的权限, 如果一个ring 3的进程尝试访问一个ring 0的页面, 当然也会被判定为非法操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分页&#34;&gt;分页&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上, 我们需要一种&lt;strong&gt;按需分配的虚存管理机制&lt;/strong&gt;. 之所以分段机制不好实现按需分配, 就是因为段的粒度太大了, 为了实现这一目标, 我们需要反其道而行之: &lt;strong&gt;把连续的存储空间分割成小片段, 以这些小片段为单位进行组织, 分配和管理. 这正是分页机制的核心思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分页机制引入了一个叫&amp;quot;页表&amp;quot;的结构, &lt;strong&gt;页表中的每一个表项&lt;/strong&gt;记录了一个&lt;strong&gt;虚拟页到物理页的映射关系,&lt;/strong&gt; 来**把不必连续的物理页面重新组织成连续的虚拟地址空间. **&lt;/p&gt;
&lt;p&gt;操作系统首先需要以物理页为单位对内存进行管理. **每当加载程序的时候, 就给程序分配相应的物理页(注意这些物理页之间不必连续), 并为程序准备一个新的页表, 在页表中填写程序用到的虚拟页到这些物理页的映射关系. **&lt;/p&gt;
&lt;p&gt;等到程序运行的时候, 操作系统就**把之前为这个程序填写好的页表设置到MMU中, MMU就会根据页表的内容进行地址转换, **把程序的虚拟地址空间映射到操作系统所希望的物理地址空间上.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一张页目录和页表都有1024个表项, 每个表项的大小都是4字节&lt;/strong&gt;, （4k）&lt;/p&gt;
&lt;p&gt;除了包含页表(或者物理页)的基地址, 还包含一些标志位信息. 要放在寄存器中是不可能的, &lt;strong&gt;因此它们要放在内存中. 为了找到页目录, i386提供了一个CR3(control register 3)寄存器, 专门用于存放页目录的基地址&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;这样,** 页级地址转换就从CR3开始一步一步地进行, 最终将虚拟地址转换成真正的物理地址, 这个过程称为一次page table walk.**&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：操作系统负责写好小纸条和分配关系，MMU负责执行小纸条。&lt;/p&gt;
&lt;h4 id=&#34;问虚存管理中pic的好处&#34;&gt;问：虚存管理中PIC的好处&lt;/h4&gt;
&lt;p&gt;我们之前提到, PIC的其中一个好处是可以将代码加载到任意内存位置执行. 如果配合虚存管理, PIC还有什么新的好处呢? (Hint: 动态库已经在享受这些好处了)&lt;/p&gt;
&lt;h4 id=&#34;问理解分页细节&#34;&gt;问：理解分页细节&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;i386不是一个32位的处理器吗, 为什么表项中的基地址信息只有20位, 而不是32位?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;答：页表信息表示本身需要2^12的空间，即4kb&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手册上提到表项(包括CR3)中的基地址都是物理地址, 物理地址是必须的吗? 能否使用虚拟地址?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个页表的基址存放在 CR3 &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/search?q=%e5%af%84%e5%ad%98%e5%99%a8%5c&amp;amp;search_source=Entity%5c&amp;amp;hybrid_search_source=Entity%5c&amp;amp;hybrid_search_extra=%7b%22sourceType%22:%22answer%22,%22sourceId%22:1951840374%7d&#34;  title=&#34;寄存器&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;寄存器&lt;/a&gt;里。CR3 存放的是&lt;strong&gt;物理地址&lt;/strong&gt;，这是整个地址转换最根本的基础。在系统初始化时，&lt;strong&gt;CR3 必须填入物理地址&lt;/strong&gt;，否则没办法进行地址转换了。这个东西是要让 MMU &amp;ldquo;看&amp;quot;的，它是个硬件，只能看得懂物理地址。&lt;/p&gt;
&lt;p&gt;每个&lt;strong&gt;页表项（PML4E, PDPTE, PDE，PTE）里的&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/search?q=%e5%9f%ba%e5%9d%80%5c&amp;amp;search_source=Entity%5c&amp;amp;hybrid_search_source=Entity%5c&amp;amp;hybrid_search_extra=%7b%22sourceType%22:%22answer%22,%22sourceId%22:1951840374%7d&#34;  title=&#34;基址&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;基址&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;，都是物理地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是，整个&lt;strong&gt;页转换表结构&lt;/strong&gt;是存放内存里，属于虚拟地址。也就是：&lt;strong&gt;页转换表结构需要进行内存映射。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么不采用一级页表? 或者说采用一级页表会有什么缺点?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当虚拟空间巨大的时候，页表项增多，页表本身占据的空间也会非常庞大。&lt;/p&gt;
&lt;p&gt;对于32位虚拟地址空间，假设页面大小为4K，页表项大小为4字节：&lt;/p&gt;
&lt;p&gt;一个进程有4G/4k = 2^20个页面
因为一个页面需要一个页表项来对应，所以，进程的页表项个数也为2^20个
不难得出该进程的页表占用了 2^20 * 4 / 4096(4k) = 1024个页面的大小&lt;/p&gt;
&lt;p&gt;没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。&lt;/p&gt;
&lt;h4 id=&#34;问空指针真的是空的吗&#34;&gt;问：空指针真的是&amp;quot;空&amp;quot;的吗?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;程序设计课上老师告诉你, 当一个指针变量的值等于NULL时, 代表空, 不指向任何东西. 仔细想想, 真的是这样吗? 当程序对空指针解引用的时候, 计算机内部具体都做了些什么? 你对空指针的本质有什么新的认识?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程试图访问一个未映射的线性地址, 并没有实际的物理页与之相对应，出现错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者访问没有权限的地址页，导致直接出错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Linux 中，每个进程空间的 0x0 虚拟地址开始的线性区(memory region)都会被映射到一个用户态没有访问权限的页上。通过这样的映射，内核可以保证没有别的页会映射到这个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译器把空指针当做 0 对待，开心地让你去访问空指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺页异常处理程序被调用，因为在 0x0 的页没有在物理内存里面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺页异常处理程序发现你没有访问的权限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内核发送 SIGSEGV 信号给进程，该信号默认是让进程自杀。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;出自&lt;a class=&#34;link&#34; href=&#34;https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer-Usually-the-process-terminates-Does-the-reaction-depend-on-the-operating-system-or-is-it-controlled-by-the-compiler-Is-it-mandatory-that-NULL-always-be-defined-as-%e2%80%9c0%e2%80%9d-with-proper-casting&#34;  title=&#34;https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer-Usually-the-process-terminates-Does-the-reaction-depend-on-the-operating-system-or-is-it-controlled-by-the-compiler-Is-it-mandatory-that-NULL-always-be-defined-as-“0”-with-proper-casting&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer-Usually-the-process-terminates-Does-the-reaction-depend-on-the-operating-system-or-is-it-controlled-by-the-compiler-Is-it-mandatory-that-NULL-always-be-defined-as-“0”-with-proper-casting&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个文章不错，Linux C程序真的不能访问NULL指针吗：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1536302&#34;  title=&#34;https://cloud.tencent.com/developer/article/1536302&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.tencent.com/developer/article/1536302&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;状态机视角下的虚存管理机制&#34;&gt;状态机视角下的虚存管理机制&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 245; 
			flex-basis: 589px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH.png&#34; data-size=&#34;1107x451&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH.png&#34;
			width=&#34;1107&#34;
			height=&#34;451&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH_hu1d0f7d935267d9bc3bdf5a6d141dd1ef_43740_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH_hu1d0f7d935267d9bc3bdf5a6d141dd1ef_43740_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fvm()&lt;/code&gt;函数可以认为是系统寄存器&lt;code&gt;SR&lt;/code&gt;的一部分, 操作系统通过修改&lt;code&gt;SR&lt;/code&gt;来对虚存进行管理&lt;/p&gt;
&lt;h3 id=&#34;在分页机制上运行nanos-lite&#34;&gt;在分页机制上运行Nanos-lite&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为了让&lt;code&gt;map()&lt;/code&gt;填写的映射生效, 我们还需要在NEMU中实现分页机制. 具体地, 我们需要实现以下两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何&lt;strong&gt;判断CPU当前是否处于分页模式&lt;/strong&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分页地址转换的具体过程&lt;/strong&gt;应该如何实现?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但这两点都是ISA相关的, 于是NEMU将它们抽象成相应的API:&lt;/p&gt;
&lt;p&gt;// 检查当前系统状态下对内存区间为[vaddr, vaddr + len), 类型为type的访问是否需要经过地址转换.&lt;/p&gt;
&lt;p&gt;int isa_mmu_check(vaddr_t vaddr, int len, int type);&lt;/p&gt;
&lt;p&gt;// 对内存区间为[vaddr, vaddr + len), 类型为type的内存访问进行地址转换&lt;/p&gt;
&lt;p&gt;paddr_t isa_mmu_translate(vaddr_t vaddr, int len, int type);&lt;/p&gt;
&lt;p&gt;riscv32的Sv32分页机制和x86非常类似, 只不过寄存器的名字和页表项结构有所不同: &lt;strong&gt;在riscv32中, 页目录基地址和分页使能位都是位于satp寄存器中&lt;/strong&gt;. 至于页表项结构的差异, 这里就不详细说明了, 还是RTFM吧.&lt;/p&gt;
&lt;p&gt;你需要理解分页地址转换的过程, 然后实现&lt;code&gt;isa_mmu_check()&lt;/code&gt;(在&lt;code&gt;nemu/src/isa/$ISA/include/isa-def.h&lt;/code&gt;中定义) 和&lt;code&gt;isa_mmu_translate()&lt;/code&gt;(在&lt;code&gt;nemu/src/isa/$ISA/system/mmu.c&lt;/code&gt;中定义), &lt;/p&gt;
&lt;p&gt;你可以查阅NEMU的ISA相关API说明文档来了解它们的行为. 另外由于我们不打算实现保护机制, 在&lt;code&gt;isa_mmu_translate()&lt;/code&gt;的实现中, &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你务必使用assertion检查页目录项和页表项的present/valid位, 如果发现了一个无效的表项, 及时终止NEMU的运行, 否则调试将会非常困难. 这通常是由于你的实现错误引起的, 请检查实现的正确性.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我参考了一些其他的关于页表叙述：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie&#34;  title=&#34;https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;csr寄存器：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 628; 
			flex-basis: 1507px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-.png&#34; data-size=&#34;603x96&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-.png&#34;
			width=&#34;603&#34;
			height=&#34;96&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-_hu5ae7974e7795137e194962f891749850_11703_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-_hu5ae7974e7795137e194962f891749850_11703_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;地址和页表项的构成：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 204; 
			flex-basis: 491px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr.png&#34; data-size=&#34;502x245&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr.png&#34;
			width=&#34;502&#34;
			height=&#34;245&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr_hub7feb1f484dd4dae97756911a5fdb502_28460_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr_hub7feb1f484dd4dae97756911a5fdb502_28460_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 170; 
			flex-basis: 409px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL.png&#34; data-size=&#34;898x526&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL.png&#34;
			width=&#34;898&#34;
			height=&#34;526&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL_hub966a67dfa6019d0196aa292bb848497_232572_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL_hub966a67dfa6019d0196aa292bb848497_232572_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 368; 
			flex-basis: 885px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln.png&#34; data-size=&#34;948x257&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln.png&#34;
			width=&#34;948&#34;
			height=&#34;257&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln_hue20d95dc73925030ce1e496687897bf9_83750_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln_hue20d95dc73925030ce1e496687897bf9_83750_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时一种最简单的解决方案是：&lt;strong&gt;将全部物理内存区域映射到虚拟地址空间&lt;/strong&gt;。此时虚拟地址和物理地址之间会有一种简单的对应关系，称为 &lt;strong&gt;线性映射&lt;/strong&gt; ，具体关系式如下：&lt;/p&gt;
&lt;p&gt;virtual address = physical address + offset&lt;/p&gt;
&lt;p&gt;具体的页表转换过程：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 101; 
			flex-basis: 244px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ.png&#34; data-size=&#34;768x753&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ.png&#34;
			width=&#34;768&#34;
			height=&#34;753&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ_hu1d90819e8c5d71e3fa036cb72fa91db7_131405_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ_hu1d90819e8c5d71e3fa036cb72fa91db7_131405_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 628; 
			flex-basis: 1507px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb.png&#34; data-size=&#34;603x96&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb.png&#34;
			width=&#34;603&#34;
			height=&#34;96&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb_hu5ae7974e7795137e194962f891749850_11703_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb_hu5ae7974e7795137e194962f891749850_11703_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 419; 
			flex-basis: 1006px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE.png&#34; data-size=&#34;566x135&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE.png&#34;
			width=&#34;566&#34;
			height=&#34;135&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE_hue778b952d82f3a208f4fffb29dad70f8_19269_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE_hue778b952d82f3a208f4fffb29dad70f8_19269_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意到riscv32 中所有页面都是 4k 对齐，因此任何页表基地址的低 12 位一定是 0 。这使得我们在保存页表基址的时候只需要保存其高 22 位（PPN）。&lt;/p&gt;
&lt;p&gt;我思考了很久页目录项的每一项怎么实现………然后小伙伴提醒不需要那么复杂，只要最简单的地址索引就好… 顿时泪流满面。&lt;/p&gt;
&lt;p&gt;然后我们还要知道一点就是，map只需要实现填写一级和二级页表，然后一级就是用VA，二级是用VA+PA（图上都有，一个是正向思考一个是反向思考！）&lt;/p&gt;
&lt;p&gt;如果你感到很困难，把这个过程的每一步写下来（第一步做什么，第二部做什么，都要细化！写得出来才是懂了，没写出来就没真的懂。）&lt;/p&gt;
&lt;p&gt;而且还要注意看看map的循环，具体的源码是怎么样走的，要注意是顺序映射，所以不需要考虑很多花里胡哨的问题。（什么时候才要创造新页表？看循环其实就知道了。）&lt;/p&gt;
&lt;p&gt;此时还要注意一个点：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/image/%5c%29IC6-7NK6%7bNEV%5c~L4Z1%5c%29%5c%29%5c[EK_MGtEixiOTm.png&#34; &gt;
		&lt;img src=&#34;https://sanbuphy.github.io/image/%5c%29IC6-7NK6%7bNEV%5c~L4Z1%5c%29%5c%29%5c[EK_MGtEixiOTm.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于不同isa的映射，我们跑的算是客户程序（所有的都是am上的客户程序），然后真正的转换到物理 还要guest到host（这个问题很坑）。其实就是一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;硬件层你怎么解引用？？怎么获取软件的信息？？？要用什么才能读取到软件的信息？？怎么read&lt;/strong&gt;？ &lt;strong&gt;这是非常关键且重要的问题，怎么在nemu实现“解引用”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调不出来，想哭，发现是我的页表项加法有点问题（感觉是指针之类的运算问题），然后一个个仔细修改，发现问题出在最后的页表项，一顿尝试后终于调出来了 哭瞎QWQ 太好哭了&lt;/p&gt;
&lt;p&gt;实在绷不住了，借用了阿尼亚的mmu进行diff各种神奇的段错误。&lt;/p&gt;
&lt;p&gt;还要注意的是，在页表相关计算的时候要记得转换一下指针。。。别用指针做加法运算。。&lt;/p&gt;
&lt;p&gt;这东西让我怀疑了自己100次是不是不适合做PA&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 202; 
			flex-basis: 485px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr.png&#34; data-size=&#34;1497x740&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr.png&#34;
			width=&#34;1497&#34;
			height=&#34;740&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr_hu5817c50bd051ab32da10af54d23892e2_158942_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr_hu5817c50bd051ab32da10af54d23892e2_158942_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 214; 
			flex-basis: 514px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9.png&#34; data-size=&#34;1607x750&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9.png&#34;
			width=&#34;1607&#34;
			height=&#34;750&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9_hu00be0c56a40f36188929aca41c114c2a_227820_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9_hu00be0c56a40f36188929aca41c114c2a_227820_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;在分页机制上运行用户进程&#34;&gt;在分页机制上运行用户进程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;目前这个地址空间除了内核映射之外就没有其它内容了, 具体可以参考&lt;code&gt;abstract-machine/am/src/$ISA/nemu/vme.c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;不过, 此时&lt;code&gt;loader()&lt;/code&gt;&lt;strong&gt;不能直接把用户进程加载&lt;/strong&gt;到内存位置&lt;code&gt;0x40000000&lt;/code&gt;附近了, 因为这个地址&lt;strong&gt;并不在内核的虚拟地址空间中, 内核不能直接访问它&lt;/strong&gt;. &lt;code&gt;loader()&lt;/code&gt;要做的事情是, 获取程序的大小之后, &lt;strong&gt;以页为单位进行加载&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申请一页空闲的物理页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;map()&lt;/code&gt;把这一物理页映射到用户进程的虚拟地址空间中. 由于AM native实现了权限检查, 为了让程序可以在AM native上正确运行, 你调用&lt;code&gt;map()&lt;/code&gt;的时候需要将&lt;code&gt;prot&lt;/code&gt;设置成可读可写可执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从文件中读入一页的内容到这一物理页中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一切都是为了让用户进程在将来可以正确地运行:** 用户进程在将来使用虚拟地址访问内存, 在loader为用户进程维护的映射下, 虚拟地址被转换成物理地址, 通过这一物理地址访问到的物理内存, 恰好就是用户进程想要访问的数据.**&lt;/p&gt;
&lt;p&gt;另一个&lt;strong&gt;需要考虑的问题是用户栈,&lt;/strong&gt; 和&lt;code&gt;loader()&lt;/code&gt;类似, 我们需要把&lt;code&gt;new_page()&lt;/code&gt;申请得到的物理页通过&lt;code&gt;map()&lt;/code&gt;映射到用户进程的虚拟地址空间中. 我们&lt;strong&gt;把用户栈的虚拟地址安排在用户进程虚拟地址空间的末尾&lt;/strong&gt;, 你可以通过&lt;code&gt;as.area.end&lt;/code&gt;来得到末尾的位置, 然后把用户栈的物理页映射到&lt;code&gt;[as.area.end - 32KB, as.area.end)&lt;/code&gt;这段虚拟地址空间.&lt;/p&gt;
&lt;p&gt;最后, 为了让这一地址空间生效, 我们还需要将它落实到MMU中. 具体地, 我们希望在CTE恢复进程上下文的时候来切换地址空间. 为此, 我们需要将进程的地址空间描述符指针&lt;code&gt;as-&amp;gt;ptr&lt;/code&gt;加入到上下文中, 框架代码已经实现了这一功能(见&lt;code&gt;abstract-machine/am/include/arch/$ISA-nemu.h&lt;/code&gt;), 在x86中这一成员为&lt;code&gt;cr3&lt;/code&gt;, 而在mips32/riscv32中则为&lt;code&gt;pdir&lt;/code&gt;. 你还需要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改&lt;code&gt;ucontext()&lt;/code&gt;的实现, 在创建的用户进程上下文中设置地址空间描述符指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;__am_irq_handle()&lt;/code&gt;的开头调用&lt;code&gt;__am_get_cur_as()&lt;/code&gt; (在&lt;code&gt;abstract-machine/am/src/$ISA/nemu/vme.c&lt;/code&gt;中定义), 来将当前的地址空间描述符指针保存到上下文中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;__am_irq_handle()&lt;/code&gt;返回前调用&lt;code&gt;__am_switch()&lt;/code&gt; (在&lt;code&gt;abstract-machine/am/src/$ISA/nemu/vme.c&lt;/code&gt;中定义)来切换地址空间, 将被调度进程的地址空间落实到MMU中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里遇到的第一个大坑就是怎么优雅的改写loader（差点忘了具体程序头表的成分了，又去看书复习了一遍。。。）&lt;/p&gt;
&lt;p&gt;然后又忘了as里面其实是有个ptr的。。。。&lt;/p&gt;
&lt;p&gt;写loader实在蚌埠住了（浮躁了），开始抱大腿（卡在具体页读取思路上）&lt;/p&gt;
&lt;p&gt;此时我又被vaddr_ifetch没实现卡了一晚上 - -。。。。。（一直到不了mmu，直接说我要访问的地方飘了。。。。）出现了超边界提示。通过排查指令可以知道我们执行前会进行fetch_decode——isa_fetch_decode——instr_fetch——vaddr_ifetch，就发现了问题源。。&lt;/p&gt;
&lt;p&gt;然后发现神奇mepc之类都为0的问题。。。。开始怀疑上下文是不是有问题。。。一顿操作猛如虎调了一下用户栈相关，解决&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 176; 
			flex-basis: 424px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn.png&#34; data-size=&#34;1212x686&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn.png&#34;
			width=&#34;1212&#34;
			height=&#34;686&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn_hu441b2c5dadc414125370ee62186c1811_276474_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn_hu441b2c5dadc414125370ee62186c1811_276474_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里要重新实现一下sbrk的映射&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 142; 
			flex-basis: 341px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF.png&#34; data-size=&#34;915x643&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF.png&#34;
			width=&#34;915&#34;
			height=&#34;643&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF_hu647e640f8bfb98ec734200328e392e9c_217301_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF_hu647e640f8bfb98ec734200328e392e9c_217301_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（笔者在这一阶段打出了GG）&lt;/p&gt;
&lt;h4 id=&#34;问内核映射的作用&#34;&gt;问：内核映射的作用&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;对于x86和riscv32, 在&lt;code&gt;protect()&lt;/code&gt;中创建地址空间的时候, 有一处代码用于拷贝内核映射:&lt;/p&gt;
&lt;p&gt;// map kernel space&lt;/p&gt;
&lt;p&gt;memcpy(updir, kas.ptr, PGSIZE);&lt;/p&gt;
&lt;p&gt;尝试注释这处代码, 重新编译并运行, 你会看到发生了错误. 请解释为什么会发生这个错误.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>opencv读取视频图像处理后推流rtmp</title>
        <link>https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/</link>
        <pubDate>Sat, 03 Sep 2022 11:56:50 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/</guid>
        <description>&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zong596568821xp/article/details/92790502&#34;  title=&#34;https://blog.csdn.net/zong596568821xp/article/details/92790502&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/zong596568821xp/article/details/92790502&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u014303844/article/details/80394101&#34;  title=&#34;https://blog.csdn.net/u014303844/article/details/80394101&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/u014303844/article/details/80394101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一些关于nginx的常见操作：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/&#34;  title=&#34;https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kalacloud.com/blog/how-to-install-nginx-on-ubuntu-20-04/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nginx rtmp配置相关官方手册：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/arut/nginx-rtmp-module/wiki/Directives#server&#34;  title=&#34;https://github.com/arut/nginx-rtmp-module/wiki/Directives#server&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/arut/nginx-rtmp-module/wiki/Directives#server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比较全的中文可参考conf文件内容解析&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/15316e0f3de1&#34;  title=&#34;https://www.jianshu.com/p/15316e0f3de1&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/15316e0f3de1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为业务上需求需要将流拉下来处理后转为其他流推送出去，之前的博客内容涉及到的是rtsp流的处理，这次利用nginx服务器转发推rtmp流。（拉流后可以进行任何图像处理）&lt;/p&gt;
&lt;p&gt;操作环境：Ubuntu 20.04 + python3&lt;/p&gt;
&lt;h2 id=&#34;nginx服务器搭建&#34;&gt;Nginx服务器搭建&lt;/h2&gt;
&lt;p&gt;因为要将处理过的图片串成rtmp码流，因此，需要搭建一个rtmp服务器，常用的方案是Nginx服务器。&lt;/p&gt;
&lt;h4 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install openssl libssl-dev
sudo apt-get install libpcre3 libpcre3-dev
sudo apt-get install zlib1g-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;安装nginx&#34;&gt;安装nginx&lt;/h3&gt;
&lt;p&gt;首先下载nginx：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://nginx.org/en/download.html&#34;  title=&#34;http://nginx.org/en/download.html&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择稳定版本即可，比如&lt;a class=&#34;link&#34; href=&#34;http://nginx.org/download/nginx-1.22.0.tar.gz&#34;  title=&#34;http://nginx.org/download/nginx-1.22.0.tar.gz&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://nginx.org/download/nginx-1.22.0.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以及nginx-rtmp-module:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone https://github.com/arut/nginx-rtmp-module.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将两者放在同级目录的文件夹下：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 246; 
			flex-basis: 590px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-41-17%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_cBl584UjTG.png&#34; data-size=&#34;588x239&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-41-17%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_cBl584UjTG.png&#34;
			width=&#34;588&#34;
			height=&#34;239&#34;
			srcset=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-41-17%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_cBl584UjTG_hu158101d61616781d65d185b72f03dbd9_10016_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-41-17%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_cBl584UjTG_hu158101d61616781d65d185b72f03dbd9_10016_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后进入nginx的文件夹，依次运行指令进行编译：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;./configure --add-module&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;../nginx-rtmp-module
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;安装后的一些信息：&lt;/p&gt;
&lt;p&gt;nginx安装目录 /usr/local/nginx      
nginx配置目录 /usr/local/nginx/conf/nginx.conf        
nginx运行目录 /usr/local/nginx/sbin/nginx &amp;ndash;options    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行指令启动nginx:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo /usr/local/nginx/sbin/nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在浏览器中输入localhost，若看到如下画面，表示运行成功&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 362; 
			flex-basis: 869px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-45-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_Py0QgJRLpC.png&#34; data-size=&#34;1221x337&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-45-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_Py0QgJRLpC.png&#34;
			width=&#34;1221&#34;
			height=&#34;337&#34;
			srcset=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-45-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_Py0QgJRLpC_hu686d3e3f75b5ca2a2d6eab8f3987b1b0_39527_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-45-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_Py0QgJRLpC_hu686d3e3f75b5ca2a2d6eab8f3987b1b0_39527_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置nginx用于推流转发&#34;&gt;配置nginx用于推流转发&lt;/h3&gt;
&lt;p&gt;可以采取vim或者vscode进行编辑&lt;/p&gt;
&lt;p&gt;这里采用vscode，首先运行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;code /usr/local/nginx/conf/nginx.conf

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着找到对应位置进行填充：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;#地址为  /usr/local/nginx/conf/nginx.conf

#注明：请勿直接覆盖原来的conf文件,这只是部分有关直播的内容

#配置RTMP，这个配置格式在github的readme上有详细说明

rtmp {                

  server {

    listen 1935;  #服务端口--默认

    chunk_size 4096;   #数据传输块的大小--默认

    #设置直播的application名称是 mylive

  application mylive{ 

    live on; #live on表示开启直播模式

    }

  }

}

#请在http里面找到server

http{

  ...#这里有一些其他的配置

#复制粘贴这个替换原来的server
 server {
            listen       80;
            server_name  localhost;
            location / {
                    root   html;
                    index  index.html index.htm;
            }
            location /pop/video {
                    alias /var/video;
            }
            location /info {
                rtmp_stat all;
                rtmp_stat_stylesheet stat.xsl;
            }
            location /stat.xsl {
                    root html; #这里可以进行一个替换
            }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 100; 
			flex-basis: 242px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-19%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_zEVduDbFDg.png&#34; data-size=&#34;583x578&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-19%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_zEVduDbFDg.png&#34;
			width=&#34;583&#34;
			height=&#34;578&#34;
			srcset=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-19%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_zEVduDbFDg_huc38dfed4d05cd589a74a02bc2c71ac4d_80612_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-19%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_zEVduDbFDg_huc38dfed4d05cd589a74a02bc2c71ac4d_80612_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 99; 
			flex-basis: 237px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_ojw0PG04QL.png&#34; data-size=&#34;678x684&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_ojw0PG04QL.png&#34;
			width=&#34;678&#34;
			height=&#34;684&#34;
			srcset=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_ojw0PG04QL_hufd2082652aba014208b7141354136e3c_52604_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2013-50-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_ojw0PG04QL_hufd2082652aba014208b7141354136e3c_52604_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;配置完之后，需要重启nginx&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo /usr/local/nginx/sbin/nginx -s reload&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来配置服务器的监控信息显示，修改之前server的一个路径信息,把这个路径改成开头下载好的module的绝对路径（因为那里面有个stat.xsl）：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 144; 
			flex-basis: 346px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-10-08%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_084WTClih1.png&#34; data-size=&#34;686x475&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-10-08%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_084WTClih1.png&#34;
			width=&#34;686&#34;
			height=&#34;475&#34;
			srcset=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-10-08%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_084WTClih1_huab15b1c96220dd94312a13da29157ea3_43949_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-10-08%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_084WTClih1_huab15b1c96220dd94312a13da29157ea3_43949_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;保存后重启nginx，然后然后在浏览器中输入localhost/info可看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 299; 
			flex-basis: 718px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-11-14%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_jlltQnBrS4.png&#34; data-size=&#34;1054x352&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-11-14%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_jlltQnBrS4.png&#34;
			width=&#34;1054&#34;
			height=&#34;352&#34;
			srcset=&#34;https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-11-14%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_jlltQnBrS4_hu91456c7cdcc18e9cf1f4cd7bd80fd112_60641_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/opencv%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%90%8E%E6%8E%A8%E6%B5%81rtmp/image/2022-09-02%2014-11-14%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_jlltQnBrS4_hu91456c7cdcc18e9cf1f4cd7bd80fd112_60641_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此，完成了rtmp-nginx服务器的全部配置&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;推流代码部分&#34;&gt;推流代码部分&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;cv2&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;subprocess&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;rtsp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;随便选个视频源测试&amp;#34;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;rtmp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;rtmp://localhost:1935/mylive/test&amp;#39;&lt;/span&gt;
 
&lt;span class=&#34;c1&#34;&gt;# 读取视频并获取属性&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cv2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;VideoCapture&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rtsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cv2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CAP_PROP_FRAME_WIDTH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cv2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CAP_PROP_FRAME_HEIGHT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sizeStr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;sezie is&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sizeStr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;command&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ffmpeg&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-y&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;-an&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-f&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;rawvideo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-vcodec&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;rawvideo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-pix_fmt&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;bgr24&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-s&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sizeStr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-r&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;15&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-i&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-c:v&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;libx264&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-pix_fmt&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;yuv420p&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-preset&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;ultrafast&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s1&#34;&gt;&amp;#39;-f&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;flv&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;rtmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
 
&lt;span class=&#34;n&#34;&gt;pipe&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subprocess&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Popen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shell&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stdin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subprocess&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PIPE&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
 
&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isOpened&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# print(frame1.shape())&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;#=================进行一些图像处理=================&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;frame&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cv2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rectangle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;50&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;900&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;400&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;#=================进行一些图像处理=================&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cv2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;waitKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xFF&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;ord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;q&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;    
        &lt;span class=&#34;n&#34;&gt;pipe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stdin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tostring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
 
&lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;pipe&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;terminate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行上述代码，然后在nginx服务器info上可查看推流情况&lt;/p&gt;
&lt;p&gt;之后用ffplay或者VLC等客户端软件即可查看推流视频&lt;/p&gt;
&lt;h2 id=&#34;可能遇到的坑&#34;&gt;可能遇到的坑：&lt;/h2&gt;
&lt;p&gt;推送时的fps选取要和源相近，不要自己随意跳帧。。。。否则speed会很奇葩的延迟。以1.0左右为准。&lt;/p&gt;
&lt;p&gt;快速重启可以写一个shell：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; 你的sudo密码 &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo -S /usr/local/nginx/sbin/nginx
xdg-open http://localhost/info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>NJU计算机课程基础实验 PA3笔记（二）</title>
        <link>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
        <pubDate>Sun, 28 Aug 2022 08:50:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
        <description>&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 131; 
			flex-basis: 315px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Pvjs3__9OY.png&#34; data-size=&#34;876x666&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Pvjs3__9OY.png&#34;
			width=&#34;876&#34;
			height=&#34;666&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Pvjs3__9OY_hu591984d82063d37d8f564bc13e4ba56f_154307_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Pvjs3__9OY_hu591984d82063d37d8f564bc13e4ba56f_154307_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;4简易文件系统&#34;&gt;4、简易文件系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对用户程序来说, 它怎么知道文件位于ramdisk的哪一个位置呢? 更何况文件会动态地增删, 用户程序并不知情&lt;/strong&gt;. 这说明, 把ramdisk的读写接口直接提供给用户程序来使用是不可行的. 操作系统还需要&lt;strong&gt;在存储介质的驱动程序之上为用户程序提供一种更高级的抽象&lt;/strong&gt;, 那就是文件.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个简易文件系统sfs(Simple File System):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个文件的&lt;strong&gt;大小是固定的&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写文件时&lt;strong&gt;不允许超过原有文件的大小&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件的&lt;strong&gt;数量是固定的, 不能创建新文件&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有目录(/a/b/c）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然文件的数量和大小都是固定的, 我们自然可以把每一个文件分别固定在ramdisk中的某一个位置. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了记录ramdisk中各个文件的名字和大小, 我们还需要一张&amp;quot;文件记录表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nanos-lite/Makefile修改后然后运行&lt;code&gt;make ARCH=riscv32-nemu update&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就会自动编译Navy中的程序, 并把&lt;code&gt;navy-apps/fsimg/&lt;/code&gt;目录下的所有内容整合成ramdisk镜像&lt;code&gt;navy-apps/build/ramdisk.img&lt;/code&gt;, 同时生成这个ramdisk镜像的文件记录表&lt;code&gt;navy-apps/build/ramdisk.h&lt;/code&gt;, Nanos-lite的&lt;code&gt;Makefile&lt;/code&gt;会通过软连接把它们链接到项目中.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你修改了Navy中的内容, 请记得通过上述命令来更新镜像文件.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;文件记录表&amp;quot;其实是一个数组, 数组的每个元素都是一个结构体:&lt;/p&gt;
&lt;p&gt;typedef struct {&lt;/p&gt;
&lt;p&gt;char *name;         // 文件名&lt;/p&gt;
&lt;p&gt;size_t size;        // 文件大小&lt;/p&gt;
&lt;p&gt;size_t disk_offset;  // 文件在ramdisk中的偏移&lt;/p&gt;
&lt;p&gt;} Finfo;&lt;/p&gt;
&lt;p&gt;最基本的文件读写操作:&lt;/p&gt;
&lt;p&gt;size_t read(const char *filename, void *buf, size_t len);&lt;/p&gt;
&lt;p&gt;size_t write(const char *filename, void *buf, size_t len);&lt;/p&gt;
&lt;p&gt;操作系统中存在不少&amp;quot;没有名字&amp;quot;的文件（比如管道传输给另一个工具的标准输入，less等）. 为了统一管理它们, **通过一个编号来表示文件, 文件描述符(file descriptor). **&lt;/p&gt;
&lt;p&gt;一个文件描述符对应一个正在打开的文件, &lt;strong&gt;由操作系统来维护文件描述符到具体文件的映射&lt;/strong&gt;. 于是我们很自然地通过&lt;code&gt;open()&lt;/code&gt;系统调用来打开一个文件, 并返回相应的文件描述符&lt;/p&gt;
&lt;p&gt;int open(const char *pathname, int flags, int mode);&lt;/p&gt;
&lt;p&gt;由于sfs的文件数目是固定的, 我们可以简单地把&lt;strong&gt;文件记录表的下标作为相应文件的文件描述符&lt;/strong&gt;返回给用户程序. &lt;strong&gt;在这以后, 所有文件操作都通过文件描述符来标识文件&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;size_t read(int fd, void *buf, size_t len);&lt;/p&gt;
&lt;p&gt;size_t write(int fd, const void *buf, size_t len);&lt;/p&gt;
&lt;p&gt;int close(int fd);&lt;/p&gt;
&lt;p&gt;我们为&lt;strong&gt;每一个已经打开的文件引入偏移量属性&lt;/strong&gt;&lt;code&gt;open_offset&lt;/code&gt;, 来&lt;strong&gt;记录目前文件操作的位置.&lt;/strong&gt; 每次对文件读写了多少个字节, 偏移量就前进多少.&lt;/p&gt;
&lt;p&gt;偏移量可以通过&lt;code&gt;lseek()&lt;/code&gt;系统调用来调整, 从而可以对文件中的任意位置进行读写:&lt;/p&gt;
&lt;p&gt;size_t lseek(int fd, size_t offset, int whence);&lt;/p&gt;
&lt;p&gt;为了方便用户程序进行标准输入输出, 操作系统准备了三个默认的文件描述符:&lt;/p&gt;
&lt;p&gt;#define FD_STDIN 0&lt;/p&gt;
&lt;p&gt;#define FD_STDOUT 1&lt;/p&gt;
&lt;p&gt;#define FD_STDERR 2&lt;/p&gt;
&lt;p&gt;它们分别对应标准输入&lt;code&gt;stdin&lt;/code&gt;, 标准输出&lt;code&gt;stdout&lt;/code&gt;和标准错误&lt;code&gt;stderr&lt;/code&gt;. 我们经常使用的printf, 最终会调用&lt;code&gt;write(FD_STDOUT, buf, len)&lt;/code&gt;进行输出; &lt;/p&gt;
&lt;p&gt;而scanf将会通过调用&lt;code&gt;read(FD_STDIN, buf, len)&lt;/code&gt;进行读入.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nanos-lite/src/fs.c&lt;/code&gt;中定义的&lt;code&gt;file_table&lt;/code&gt;会包含&lt;code&gt;nanos-lite/src/files.h&lt;/code&gt;, 其中前面还有3个特殊的文件: &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;和&lt;code&gt;stderr&lt;/code&gt;的占位表项, 它们只是为了保证sfs和约定的标准输入输出的文件描述符保持一致, 例如根据约定&lt;code&gt;stdout&lt;/code&gt;的文件描述符是&lt;code&gt;1&lt;/code&gt;, 而我们添加了三个占位表项之后, 文件记录表中的&lt;code&gt;1&lt;/code&gt;号下标也就不会分配给其它的普通文件了.&lt;/p&gt;
&lt;p&gt;根据以上信息, 我们就可以在文件系统中实现以下的文件操作了:&lt;/p&gt;
&lt;p&gt;int fs_open(const char *pathname, int flags, int mode);&lt;/p&gt;
&lt;p&gt;size_t fs_read(int fd, void *buf, size_t len);&lt;/p&gt;
&lt;p&gt;size_t fs_write(int fd, const void *buf, size_t len);&lt;/p&gt;
&lt;p&gt;size_t fs_lseek(int fd, size_t offset, int whence);&lt;/p&gt;
&lt;p&gt;int fs_close(int fd);&lt;/p&gt;
&lt;p&gt;这些文件操作实际上是&lt;strong&gt;相应的系统调用在内核中的实现&lt;/strong&gt;. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于sfs中每一个文件都是固定的, 不会产生新文件, 因此&amp;rdquo;&lt;code&gt;fs_open()&lt;/code&gt;没有找到&lt;code&gt;pathname&lt;/code&gt;所指示的文件&amp;quot;属于异常情况, 你需要使用assertion终止程序运行.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了简化实现, 我们&lt;strong&gt;允许所有用户程序都可以对所有已存在的文件进行读写,&lt;/strong&gt; 这样以后, 我们在实现&lt;code&gt;fs_open()&lt;/code&gt;的时候就可以忽略&lt;code&gt;flags&lt;/code&gt;和&lt;code&gt;mode&lt;/code&gt;了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;ramdisk_read()&lt;/code&gt;和&lt;code&gt;ramdisk_write()&lt;/code&gt;来进行文件的真正读写.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于文件的大小是固定的, 在实现&lt;code&gt;fs_read()&lt;/code&gt;, &lt;code&gt;fs_write()&lt;/code&gt;和&lt;code&gt;fs_lseek()&lt;/code&gt;的时候, 注意偏移量不要越过文件的边界.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了写入&lt;code&gt;stdout&lt;/code&gt;和&lt;code&gt;stderr&lt;/code&gt;之外(用&lt;code&gt;putch()&lt;/code&gt;输出到串口), 其余对于&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;和&lt;code&gt;stderr&lt;/code&gt;这&lt;strong&gt;三个特殊文件的操作可以直接忽略.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于sfs&lt;strong&gt;没有维护文件打开的状态&lt;/strong&gt;, &lt;code&gt;fs_close()&lt;/code&gt;可以直接返回&lt;code&gt;0&lt;/code&gt;, 表示总是关闭成功.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后你还需要在&lt;strong&gt;Nanos-lite和Navy的libos中添加相应的系统调用,&lt;/strong&gt; 来调用相应的文件操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始看不懂表达的意思是啥。。。看着看着打算先写了再说。一顿操作猛如虎成功：（自由切换文件，拦截了奇怪的情况）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 156; 
			flex-basis: 374px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_2DzXnSxled.png&#34; data-size=&#34;1228x786&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_2DzXnSxled.png&#34;
			width=&#34;1228&#34;
			height=&#34;786&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_2DzXnSxled_hu3b9ca7d1bb13dde02f22ce6a4c72bd29_157289_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_2DzXnSxled_hu3b9ca7d1bb13dde02f22ce6a4c72bd29_157289_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一开始一直想不到怎么在loader对段头表处理部分可以隔离对ramdisk_read的依赖，因为参数数目不匹配。随后突然想到可以用lseek设置偏移再读写操作，而且我们可以利用结构体偏移量，那么这个抽象就是可以被完成的了。一顿操作猛如虎解除了loader的耦合。&lt;/p&gt;
&lt;p&gt;(这里要注意navy系统调用的返回值，请按照man填写否则吃大亏！手册！手册！手册！）&lt;/p&gt;
&lt;p&gt;我这里还遇到一个很坑的问题：边界拦截，自己把自己坑了，因为实际上失败返回-1即可，我自己给自己panic了- -。。。。这件事情告诉我们，好好按照man的规定不要自己花里胡哨QAQ&lt;/p&gt;
&lt;p&gt;为了更好的调试，学习pony哥方法给log换了个皮肤：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1142372&#34;  title=&#34;https://cloud.tencent.com/developer/article/1142372&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.tencent.com/developer/article/1142372&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 155; 
			flex-basis: 372px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_F3veXWpYTh.png&#34; data-size=&#34;1298x836&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_F3veXWpYTh.png&#34;
			width=&#34;1298&#34;
			height=&#34;836&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_F3veXWpYTh_hu652b690b3a289cc77e4b19ce3f8ce450_379618_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_F3veXWpYTh_hu652b690b3a289cc77e4b19ce3f8ce450_379618_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;一切皆文件&#34;&gt;一切皆文件&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;我们需要有一种方式对设备的功能进行抽象, 向用户程序提供统一的接口.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存是以字节编址的, 天然就是一个字节序列, 因而我们之前使用的ramdisk作为字节序列也更加显而易见了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管道(shell命令中的&lt;code&gt;|&lt;/code&gt;)是一种先进先出的字节序列, 本质上它是内存中的一个队列缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁盘也可以看成一个字节序列: 我们可以为磁盘上的每一个字节进行编号, 例如第x柱面第y磁头第z扇区中的第n字节, 把磁盘上的所有字节按照编号的大小进行排列, 便得到了一个字节序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;socket(网络套接字)也是一种字节序列, 它有一个缓冲区,** 负责存放接收到的网络数据包**,上层应用将socket中的内容看做是字节序列, 并通过一些特殊的文件操作来处理它们. 我们在PA2中介绍了DiffTest, 如果你RTFSC, 就会发现其中的&lt;code&gt;qemu-diff&lt;/code&gt;就是&lt;strong&gt;通过socket与QEMU进行通信&lt;/strong&gt;的, 而操作socket的方式就是&lt;code&gt;fgetc()&lt;/code&gt;和&lt;code&gt;fputc()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统提供的一些特殊的功能, 如随机数生成器, 也可以看成一个&lt;strong&gt;无穷长的字节序列&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件就是字节序列, 那很自然地, 上面这些五花八门的字节序列应该都可以看成文件. &lt;/p&gt;
&lt;p&gt;我们可以使用文件的接口来操作计算机上的一切, 而不必对它们进行详细的区分: 例如 &lt;code&gt;navy-apps/Makefile&lt;/code&gt;的&lt;code&gt;ramdisk&lt;/code&gt;规则通过管道&lt;strong&gt;把各个shell工具的输入输出连起来, 生成文件记录表&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;虚拟文件系统&#34;&gt;虚拟文件系统&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 132; 
			flex-basis: 317px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_U_HmID6cYq.png&#34; data-size=&#34;885x670&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_U_HmID6cYq.png&#34;
			width=&#34;885&#34;
			height=&#34;670&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_U_HmID6cYq_hue225d25de8493c27ef46e8a9b1e0b862_170219_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_U_HmID6cYq_hue225d25de8493c27ef46e8a9b1e0b862_170219_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;真实文件系统, 其实是指&lt;strong&gt;具体如何操作&lt;/strong&gt;某一类文件。&lt;/p&gt;
&lt;p&gt;VFS其实是对不同种类的真实文件系统的抽象,** 它用一组API来描述了这些真实文件系统的抽象行为, 屏蔽了真实文件系统之间的差异,** 上层模块(比如系统调用处理函数)不必关心当前操作的文件具体是什么类型, 只要调用这一组API即可完成相应的文件操作&lt;/p&gt;
&lt;p&gt;只要把真实文件系统的访问方式包装成VFS的API, 上层模块无需修改任何代码, 就能支持一个新的真实文件系统了&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;ReadFn&lt;/code&gt;和&lt;code&gt;WriteFn&lt;/code&gt;分别是两种函数指针, 它们用于指向真正进行读写的函数, 并返回成功读写的字节数. 有了这两个函数指针, 我们只需要在文件记录表中对不同的文件设置不同的读写函数, 就可以通过&lt;code&gt;f-&amp;gt;read()&lt;/code&gt;和&lt;code&gt;f-&amp;gt;write()&lt;/code&gt;的方式来调用具体的读写函数了.&lt;/p&gt;
&lt;p&gt;由于特殊文件的数量很少, 我们约定, 当上述的函数指针为&lt;code&gt;NULL&lt;/code&gt;时, 表示相应文件是一个普通文件, 通过ramdisk的API来进行文件的读写, 这样我们就不需要为大多数的普通文件显式指定ramdisk的读写函数了.&lt;/p&gt;
&lt;p&gt;我们把文件看成字节序列, 大部分字节序列都是&amp;quot;静止&amp;quot;的, 例如对于ramdisk和磁盘上的文件, 如果我们不对它们进行修改, 它们就会一直位于同一个地方, 这样的字节序列具有&amp;quot;位置&amp;quot;的概念; 但有一些特殊的字节序列并不是这样, 例如键入按键的字节序列是&amp;quot;流动&amp;quot;的, 被读出之后就不存在了, 这样的字节序列中的字节之间只有顺序关系, 但无法编号, 因此它们没有&amp;quot;位置&amp;quot;的概念. &lt;/p&gt;
&lt;p&gt;属于前者的文件支持&lt;code&gt;lseek&lt;/code&gt;操作, 存储这些文件的设备称为&amp;quot;块设备&amp;quot;; 而属于后者的文件则不支持&lt;code&gt;lseek&lt;/code&gt;操作, 相应的设备称为&amp;quot;字符设备&amp;quot;. 真实的操作系统还会对&lt;code&gt;lseek&lt;/code&gt;操作进行抽象, 我们在Nanos-lite中进行了简化, 就不实现这一抽象了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;操作系统之上的ioe&#34;&gt;操作系统之上的IOE&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有了VFS, 要把IOE抽象成文件就非常简单了.&lt;/p&gt;
&lt;p&gt;串口. 在Nanos-lite中, &lt;code&gt;stdout&lt;/code&gt;和&lt;code&gt;stderr&lt;/code&gt;都会输出到串口. 之前你可能会通过判断&lt;code&gt;fd&lt;/code&gt;是否为&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;2&lt;/code&gt;, 来决定&lt;code&gt;sys_write()&lt;/code&gt;是否写入到串口. 现在有了VFS, 我们就不需要让系统调用处理函数关心这些特殊文件的情况了: 我们只需要在&lt;code&gt;nanos-lite/src/device.c&lt;/code&gt;中实现&lt;code&gt;serial_write()&lt;/code&gt;, 然后在文件记录表中设置相应的写函数, 就可以实现上述功能了. 由于串口是一个字符设备, 对应的字节序列没有&amp;quot;位置&amp;quot;的概念, 因此&lt;code&gt;serial_write()&lt;/code&gt;中的&lt;code&gt;offset&lt;/code&gt;参数可以忽略. 另外Nanos-lite也不打算支持&lt;code&gt;stdin&lt;/code&gt;的读入, 因此在文件记录表中设置相应的报错函数即可.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一步比较简单，就按照描述加入即可，把fswrite进行一下抽象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Nanos-lite中, 我们也提供一个&lt;code&gt;SYS_gettimeofday&lt;/code&gt;系统调用, 用户程序可以通过它读出当前的系统时间.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据以前的am依葫芦画瓢（实际上我们能知道am就是为了这时候做准备）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 152; 
			flex-basis: 366px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_278DUxX-K4.png&#34; data-size=&#34;1211x792&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_278DUxX-K4.png&#34;
			width=&#34;1211&#34;
			height=&#34;792&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_278DUxX-K4_hu9b944b2b57eec4a93e87dea8c2e5192a_128689_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_278DUxX-K4_hu9b944b2b57eec4a93e87dea8c2e5192a_128689_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;替换成NDL库的过程中，注意NDL的导入（想想make的时候怎么搜索库）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另一个输入设备是键盘, 按键信息对系统来说本质上就是到来了一个事件. 一种简单的方式是把事件以文本的形式表现出来, 我们定义以下两种事件,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按下按键事件, 如&lt;code&gt;kd RETURN&lt;/code&gt;表示按下回车键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;松开按键事件, 如&lt;code&gt;ku A&lt;/code&gt;表示松开&lt;code&gt;A&lt;/code&gt;键&lt;/p&gt;
&lt;p&gt;按键名称与AM中的定义的按键名相同, 均为大写. 此外, 一个事件以换行符&lt;code&gt;\n&lt;/code&gt;结束.&lt;/p&gt;
&lt;p&gt;我们采用文本形式来描述事件有两个好处, 首先文本显然是一种字节序列, 这使得事件很容易抽象成文件; 此外文本方式使得用户程序可以容易可读地解析事件的内容. Nanos-lite和Navy约定, 上述事件抽象成一个特殊文件&lt;code&gt;/dev/events&lt;/code&gt;, 它需要支持读操作, 用户程序可以从中读出按键事件, 但它不必支持&lt;code&gt;lseek&lt;/code&gt;, 因为它是一个字符设备.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里关键问题要理解：&lt;strong&gt;键入按键的字节序列是&amp;quot;流动&amp;quot;的, 被读出之后就不存在了&lt;/strong&gt;, &lt;strong&gt;它们没有&amp;quot;位置&amp;quot;的概念&lt;/strong&gt;. 属于后者的文件则不支持&lt;code&gt;lseek&lt;/code&gt;操作, &lt;strong&gt;相应的设备称为&amp;quot;字符设备&amp;quot;&lt;/strong&gt;，说明我们需要让数据直接被“读出”，也就是读函数中交互过程能直接把数据传送到我们需要的地方。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 511; 
			flex-basis: 1227px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_8jz8z3DeiO.png&#34; data-size=&#34;895x175&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_8jz8z3DeiO.png&#34;
			width=&#34;895&#34;
			height=&#34;175&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_8jz8z3DeiO_hu6ab1e9bc52070a7dea31f56b3fa63e09_41257_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_8jz8z3DeiO_hu6ab1e9bc52070a7dea31f56b3fa63e09_41257_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;答：实际上fopen得到的FILE也是可以通过转换得到最后的fd的，但是之所以不用是因为可能错误使用了fread，因为这系列的读写操作实际上是对FILE里面的缓冲区进行操作的，而我们的设备文件需要直接把我们需要的buf打印。&lt;/p&gt;
&lt;p&gt;注意对好各类接口（返回值 0和1以及对应的buf传输链即可得到结果）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 152; 
			flex-basis: 366px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_0lfiKRhjw6.png&#34; data-size=&#34;1290x845&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_0lfiKRhjw6.png&#34;
			width=&#34;1290&#34;
			height=&#34;845&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_0lfiKRhjw6_hu065c9f02bf4b43c4f2b030caa424ed8b_135867_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_0lfiKRhjw6_hu065c9f02bf4b43c4f2b030caa424ed8b_135867_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nanos-lite需要做的, 便是把显存抽象成文件. &lt;strong&gt;显存本身也是一段存储空间&lt;/strong&gt;, 它以行优先的方式存储了将要在屏幕上显示的像素. Nanos-lite和Navy约定, 把显存抽象成文件&lt;code&gt;/dev/fb&lt;/code&gt;(fb为frame buffer之意), 它需要&lt;strong&gt;支持写操作和&lt;/strong&gt;&lt;code&gt;lseek&lt;/code&gt;, 以&lt;strong&gt;便于把像素更新到屏幕的指定位置上.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中&amp;quot;&lt;strong&gt;画布&amp;quot;是一个面向程序的概念,&lt;/strong&gt; 程序绘图时的坐标都是针对画布来设定的, 这样程序就无需关心系统屏幕的大小, 以及需要将图像绘制到系统屏幕的哪一个位置. &lt;strong&gt;NDL可以根据系统屏幕大小以及画布大小, 来决定将画布&amp;quot;贴&amp;quot;到哪里&lt;/strong&gt;, 例如贴到屏幕左上角或者居中, 从而将画布的内容写入到frame buffer中正确的位置.&lt;/p&gt;
&lt;p&gt;NDL_DrawRect()的功能和PA2中介绍的绘图接口是非常类似的. 但为了实现它, NDL还需要知道屏幕大小的信息. &lt;strong&gt;Nanos-lite和Navy约定, 屏幕大小的信息通过/proc/dispinfo文件来获得, 它需要支持读操作. navy-apps/README.md中对这个文件内容的格式进行了约定, 你需要阅读它&lt;/strong&gt;. 至于具体的屏幕大小, 你需要通过IOE的相应API来获取.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;把vga显存抽象成文件&#34;&gt;把VGA显存抽象成文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;实现&lt;code&gt;fb_write()&lt;/code&gt;(在&lt;code&gt;nanos-lite/src/device.c&lt;/code&gt;中定义), &lt;/p&gt;
&lt;p&gt;用于把&lt;code&gt;buf&lt;/code&gt;中的&lt;code&gt;len&lt;/code&gt;字节写到屏幕上&lt;code&gt;offset&lt;/code&gt;处. 你需要先从&lt;code&gt;offset&lt;/code&gt;计算出屏幕上的坐标, 然后调用IOE来进行绘图. 另外我们约定每次绘图后总是马上将frame buffer中的内容同步到屏幕上.&lt;/p&gt;
&lt;p&gt;在NDL中实现&lt;code&gt;NDL_DrawRect()&lt;/code&gt;, 通过往&lt;code&gt;/dev/fb&lt;/code&gt;中的正确位置写入像素信息来绘制图像. 你需要梳理清楚系统屏幕(即frame buffer), &lt;code&gt;NDL_OpenCanvas()&lt;/code&gt;打开的画布, 以及&lt;code&gt;NDL_DrawRect()&lt;/code&gt;指示的绘制区域之间的位置关系.&lt;/p&gt;
&lt;p&gt;让Nanos-lite运行&lt;code&gt;navy-apps/tests/bmp-test&lt;/code&gt;, 如果实现正确, 你将会看到屏幕上显示Project-N的logo.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我一直卡着没做出来，主要是不理解fb_write和NDL_DrawRect到底要做什么。实际上要理解的是，绘制工作已经被am完成了，所以我们只需要吧数据全部丢过去即可。而重要的是在fs的特别write中根据am的接口把我们的数据喂过去（需要w,h,x,y的信息），而NDL是为喂过去而准备的。&lt;/p&gt;
&lt;p&gt;【其实就要注意一点，在navy中的读写其实都是依靠fs完成，所以对应的buff和len都是在navy才进行处理，因为那才是真正调用处理的函数，想想他们拿到的东西是什么，是不是一样】&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 163; 
			flex-basis: 392px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_jE_Zzd5sd0.png&#34; data-size=&#34;1179x721&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_jE_Zzd5sd0.png&#34;
			width=&#34;1179&#34;
			height=&#34;721&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_jE_Zzd5sd0_hu2b5289946be45637c43161977b022d2b_187772_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_jE_Zzd5sd0_hu2b5289946be45637c43161977b022d2b_187772_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;精彩纷呈的应用程序&#34;&gt;精彩纷呈的应用程序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;miniSDL的代码位于&lt;code&gt;navy-apps/libs/libminiSDL/&lt;/code&gt;目录下, 它由6个模块组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;timer.c&lt;/code&gt;: 时钟管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;event.c&lt;/code&gt;: 事件处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;video.c&lt;/code&gt;: 绘图接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;file.c&lt;/code&gt;: 文件抽象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;audio.c&lt;/code&gt;: 音频播放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;general.c&lt;/code&gt;: 常规功能, 包括初始化, 错误管理等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以通过NDL来支撑miniSDL的底层实现, 让miniSDL向用户程序提供更丰富的功能, 这样我们就可以在Navy上运行更复杂的程序了. miniSDL中的API和SDL同名, 你可以通过&lt;a class=&#34;link&#34; href=&#34;https://www.libsdl.org/release/SDL-1.2.15/docs/&#34;  title=&#34;RTFM&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RTFM&lt;/a&gt;来查阅这些API的具体行为. 另外miniSDL中的大部分API都没有实现, 你最好想个办法让程序用到某个未实现API的时候提醒你, 否则你可能难以理解由此导致的复杂程序非预期行为.&lt;/p&gt;
&lt;p&gt;虽然Navy的&lt;code&gt;native&lt;/code&gt;和AM中的&lt;code&gt;native&lt;/code&gt;同名, 但它们的机制是不同的: &lt;/p&gt;
&lt;p&gt;在AM native上运行的系统, 需要AM, Nanos-lite, libos, libc这些抽象层来支撑上述的运行时环境, &lt;/p&gt;
&lt;p&gt;在AM中的&lt;code&gt;ARCH=native&lt;/code&gt;, 在Navy中对应的是&lt;code&gt;ISA=am_native&lt;/code&gt;; 而在&lt;strong&gt;Navy native中, 上述运行时环境是直接由Linux native实现的.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;问神奇的ld_preload&#34;&gt;问：神奇的LD_PRELOAD&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bmp-test&lt;/code&gt;需要打开一个路径为&lt;code&gt;/share/pictures/projectn.bmp&lt;/code&gt;的文件, 但在Linux native中, 这个路径对应的文件并不存在. 但我们还是把&lt;code&gt;bmp-test&lt;/code&gt;成功运行起来了, 你知道这是如何实现的吗? 如果你感兴趣, 可以在互联网上搜索&lt;code&gt;LD_PRELOAD&lt;/code&gt;相关的内容.&lt;/p&gt;
&lt;p&gt;答：LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。&lt;/p&gt;
&lt;p&gt;SDL2常用函数&amp;amp;结构分析:SDL_Surface&amp;amp;SDL_GetWindowSurface&amp;amp;SDL_LoadBMP&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_25333681/article/details/89789479&#34;  title=&#34;https://blog.csdn.net/qq_25333681/article/details/89789479&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/qq_25333681/article/details/89789479&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;幻灯片显示：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 139; 
			flex-basis: 334px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/huandeng.png&#34; data-size=&#34;825x592&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/huandeng.png&#34;
			width=&#34;825&#34;
			height=&#34;592&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/huandeng_huad8b7d9b543d729758e71ae4250bcd15_195276_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/huandeng_huad8b7d9b543d729758e71ae4250bcd15_195276_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的pdf转换一开始我还以为只能转换开头那张pdf。。。经过查资料后成功转了其他页面~&lt;/p&gt;
&lt;p&gt;有可能会出现数字键爆炸的问题，请注意是否清除缓存以及键盘type。&lt;/p&gt;
&lt;p&gt;接下来实现menu，有点痛不欲生。。。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 161; 
			flex-basis: 386px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/surface.png&#34; data-size=&#34;709x440&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/surface.png&#34;
			width=&#34;709&#34;
			height=&#34;440&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/surface_huc053f20ddd1de16ecc38417726190cf5_260885_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/surface_huc053f20ddd1de16ecc38417726190cf5_260885_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实SDL_FillRect的关键是要理解什么是像素。。。其实像素是一个“数组”里面根据00rrrggbb00rrrggbb这样的方式排列下去（4byte的情况），理解了这点就好办了。理解画布并不是要画上去，只是准备画布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来最难的就是SDL_BlitSurface的实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现后能看到这样的画面：开始菜单（还没有execve的功能）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 175; 
			flex-basis: 420px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_wAHxcP8c3v.png&#34; data-size=&#34;1396x796&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_wAHxcP8c3v.png&#34;
			width=&#34;1396&#34;
			height=&#34;796&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_wAHxcP8c3v_huf317ecf0daeb695f33711efa27e846e6_245695_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_wAHxcP8c3v_huf317ecf0daeb695f33711efa27e846e6_245695_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;nterm-nju-terminal&#34;&gt;NTerm (NJU Terminal)&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 152; 
			flex-basis: 365px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/nterm.png&#34; data-size=&#34;1084x711&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/nterm.png&#34;
			width=&#34;1084&#34;
			height=&#34;711&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/nterm_hu81874d9f95f3f508e741fc80c2440a66_97942_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/nterm_hu81874d9f95f3f508e741fc80c2440a66_97942_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;flappy-bird&#34;&gt;Flappy Bird&lt;/h4&gt;
&lt;p&gt;这里我首当其冲遇到了爆炸问题：fe_read出边界，但实际上是手册没读好的问题。。。。（被pony哥拯救系列）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 159; 
			flex-basis: 383px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/shouce.png&#34; data-size=&#34;1368x856&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/shouce.png&#34;
			width=&#34;1368&#34;
			height=&#34;856&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/shouce_hu59a563ee73d77d4009c99dc02018d472_138210_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/shouce_hu59a563ee73d77d4009c99dc02018d472_138210_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后又遇到了- -神奇的按键没反应的情况。。。。后面发现是对“事件”不够理解。。。如果你也遇到了请仔细阅读事件的定义然后反思下某个函数是否返回正确。。。。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 150; 
			flex-basis: 361px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/xiaoniao.png&#34; data-size=&#34;989x657&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/xiaoniao.png&#34;
			width=&#34;989&#34;
			height=&#34;657&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/xiaoniao_hu6af73d8437039569412037fe24db4b36_125761_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/xiaoniao_hu6af73d8437039569412037fe24db4b36_125761_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;仙剑奇侠传&#34;&gt;仙剑奇侠传&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 131; 
			flex-basis: 315px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_iPtNfF-iU9.png&#34; data-size=&#34;784x597&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_iPtNfF-iU9.png&#34;
			width=&#34;784&#34;
			height=&#34;597&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_iPtNfF-iU9_hu5b0edb30fd6ac6264efe903332550d31_178619_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_iPtNfF-iU9_hu5b0edb30fd6ac6264efe903332550d31_178619_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;首先很快就找到了data（就是data，其他花里胡哨的不算）然后你可能会看到一坨大写文件发现段错误。。。。这里是个坑&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【具体查找过程开gdb，你会发现出错的地方。。。。。建议不要放过这个过程。】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先在pal下运行&lt;code&gt;make ISA=native gdb&lt;/code&gt; 查找段错误的原因，此时你会看到一个io错误，fp=NULL（0x0），那么是什么文件打开错误呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意到讲义&lt;/strong&gt;：此外, 你还需要创建配置文件&lt;code&gt;sdlpal.cfg&lt;/code&gt;, 具体请阅读&lt;code&gt;repo/docs/README.md&lt;/code&gt;和&lt;code&gt;repo/docs/sdlpal.cfg.example&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;一顿操作找到了cfg文件，那么这个要放在那呢？&lt;/p&gt;
&lt;p&gt;先在makefile中加入-g 方便调试（具体什么地方自己找apps），然后在pal下继续gdb，r结束后&lt;strong&gt;bt打印堆栈信息&lt;/strong&gt;，这时候你就会发现访问某个文件出错了，找到对应的文件即可（或者把cfg放进去。）。如果你发现他需要访问某个share/games之类的文件信息，检查下有没有，然后想想在之前的小鸟下做了什么操作。&lt;/p&gt;
&lt;p&gt;反复测试直到make ISA=native run不报错，此时你就发现make run 可以运行了！&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 155; 
			flex-basis: 372px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_il7mYTUE6u.png&#34; data-size=&#34;927x598&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_il7mYTUE6u.png&#34;
			width=&#34;927&#34;
			height=&#34;598&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_il7mYTUE6u_hubde635a9f3f75c8d05e251caa04a3eeb_71223_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_il7mYTUE6u_hubde635a9f3f75c8d05e251caa04a3eeb_71223_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是在这里native还不能运行，这是因为我们还没有处理调色盘（这里关键的是理解调色盘）&lt;/p&gt;
&lt;p&gt;注意到此时的pixels只是索引，那么我们要做的就是取出真正的像素做成真正的pixels喂给NDL即可。&lt;/p&gt;
&lt;p&gt;如果遇到有些update还是没有去除的奇怪情况，建议在pal重新install后再update run看看。&lt;/p&gt;
&lt;p&gt;处理完成后成功跑native~:&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 145; 
			flex-basis: 349px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_sR2pJods3N.png&#34; data-size=&#34;1000x686&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_sR2pJods3N.png&#34;
			width=&#34;1000&#34;
			height=&#34;686&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_sR2pJods3N_hue808351ec153e1e567ba8fc153dcc18a_100249_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_sR2pJods3N_hue808351ec153e1e567ba8fc153dcc18a_100249_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来发现跑nemu还是有点问题，主要是update实现不对，又要返工一下ndl。。。。。（注意到这里的src→w和w其实是有区别的。我们需要理解以下几点：【我在这卡了特别久。。】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NDL_DrawRect的xywh对pixels做什么，为什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SDL_UpdateRect的xywh要对surface做什么为什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上这是一个抠图的过程。wh是我们在运行中需要扣出的范围，而实际上的s是画布，我们要把x,y偏移处的东西从surface抠出来然后更新到NDL中，让他更新到屏幕。&lt;/p&gt;
&lt;p&gt;然后这里我有个问题，就是我的x,y居中逻辑是错误的，因为没有旧xy的信息只是强制更新，容易出问题，换了一版新的逻辑正常了。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 171; 
			flex-basis: 410px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_ufiGlhnv8R.png&#34; data-size=&#34;1388x811&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_ufiGlhnv8R.png&#34;
			width=&#34;1388&#34;
			height=&#34;811&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_ufiGlhnv8R_hufba78d3c35973daf0a005339bf0a2d56_189877_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_ufiGlhnv8R_hufba78d3c35973daf0a005339bf0a2d56_189877_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我的fps只有6左右，有小伙伴最高11，不过还是感觉很流畅的~&lt;/p&gt;
&lt;p&gt;刚跑出来的时候我是特别开心的，高兴了一晚上睡不着。&lt;/p&gt;
&lt;p&gt;显卡读写是我的一生之敌，真的花了很久去理解像素的绘制，这个还是需要动手会比较直观。&lt;/p&gt;
&lt;h4 id=&#34;问仙剑奇侠传的框架是如何工作的&#34;&gt;问：仙剑奇侠传的框架是如何工作的?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;我们在PA2中讨论过一个游戏的基本框架, 尝试阅读仙剑奇侠传的代码, 找出基本框架是通过哪些函数实现的. 找到之后, 可能会对你调试仙剑奇侠传带来一定的帮助. 虽然仙剑奇侠传的代码很多, 但为了回答这个问题, 你并不需要阅读大量的代码.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;问仙剑奇侠传的脚本引擎&#34;&gt;问：仙剑奇侠传的脚本引擎&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;navy-apps/apps/pal/repo/src/game/script.c&lt;/code&gt;中有一个&lt;code&gt;PAL_InterpretInstruction()&lt;/code&gt;的函数, 尝试大致了解这个函数的作用和行为. 然后大胆猜测一下, 仙剑奇侠传的开发者是如何开发这款游戏的? 你对&amp;quot;游戏引擎&amp;quot;是否有新的认识?&lt;/p&gt;
&lt;h4 id=&#34;am-kernels&#34;&gt;am-kernels&lt;/h4&gt;
&lt;p&gt;开局一条狗内容全靠偷后实现（基本上native能跑就胜利）&lt;/p&gt;
&lt;p&gt;这里如果出现找不到文件错误，可以尝试一下子文件&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 174; 
			flex-basis: 419px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_gnQY3DCMzO.png&#34; data-size=&#34;1313x751&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_gnQY3DCMzO.png&#34;
			width=&#34;1313&#34;
			height=&#34;751&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_gnQY3DCMzO_hub58dbc6f53366d669b04987fe2fecbf3_93443_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_gnQY3DCMzO_hub58dbc6f53366d669b04987fe2fecbf3_93443_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;fceux&#34;&gt;FCEUX&lt;/h4&gt;
&lt;p&gt;一开始卡着段错误。。。然后打印后发现其实是rom没有东西 是个NULL 。。&lt;/p&gt;
&lt;p&gt;翻了一下源码后恍然大悟，成功调出~&lt;/p&gt;
&lt;p&gt;快乐卡比&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 180; 
			flex-basis: 433px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_C2Yo5DI6AG.png&#34; data-size=&#34;1305x723&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_C2Yo5DI6AG.png&#34;
			width=&#34;1305&#34;
			height=&#34;723&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_C2Yo5DI6AG_huc94043e8d83b49d40b8451bf4f48cfbb_144101_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_C2Yo5DI6AG_huc94043e8d83b49d40b8451bf4f48cfbb_144101_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;展示你的批处理系统&#34;&gt;展示你的批处理系统&lt;/h3&gt;
&lt;p&gt;这里我实现execve后遇到了魔数爆炸的情况。。。。最后发现是有个地方偏移没有清零- -。。。。。难怪读取不正确（总感觉是读写的问题）修改后一切正常~&lt;/p&gt;
&lt;p&gt;然后菜单menu一直有不显示的情况。。。感到非常伤心&lt;/p&gt;
&lt;p&gt;然后pony哥教我gdb调试后发现一个窗口创建的问题- -，不知道原因是什么,最后排查源码发现原来又是一个api没认真看手册漏的坑（之前被自己删掉了一句）。。。。open窗口，难怪一直不显示。&lt;/p&gt;
&lt;p&gt;修改后正常：（给不同游戏加个退出，就非常帅气了！）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 185; 
			flex-basis: 444px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Wc-JtNEg6g.png&#34; data-size=&#34;1262x681&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Wc-JtNEg6g.png&#34;
			width=&#34;1262&#34;
			height=&#34;681&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Wc-JtNEg6g_hu474b5a398f4ce87062662aa3147328cc_70019_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Wc-JtNEg6g_hu474b5a398f4ce87062662aa3147328cc_70019_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后处理了一下execvp相关内容 顺利完成 ~~(原来不需要自己实现。。。害我之前还以为要自己设定env&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 188; 
			flex-basis: 452px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_xwzdsEICvb.png&#34; data-size=&#34;1407x746&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_xwzdsEICvb.png&#34;
			width=&#34;1407&#34;
			height=&#34;746&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_xwzdsEICvb_hu8f66f0a2a3c5a238d4946a1bbf7d8b22_103087_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_xwzdsEICvb_hu8f66f0a2a3c5a238d4946a1bbf7d8b22_103087_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（不太完美的地方就是不会清屏~）&lt;/p&gt;
&lt;p&gt;接下来开始接受pa4的折磨。。。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>NJU计算机课程基础实验 PA3笔记（一）</title>
        <link>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
        <pubDate>Fri, 26 Aug 2022 08:50:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
        <description>&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 129; 
			flex-basis: 311px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_OJoXBv79xo.png&#34; data-size=&#34;791x610&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_OJoXBv79xo.png&#34;
			width=&#34;791&#34;
			height=&#34;610&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_OJoXBv79xo_hu0890545de703375c2bfcf035e97c2059_86334_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_OJoXBv79xo_hu0890545de703375c2bfcf035e97c2059_86334_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;写在前面：感谢pony、杨婆婆等群友的讨论和帮助，让我对PA有了更深入的理解。&lt;/p&gt;
&lt;p&gt;关于问题部分：请遵守学术诚信，有关提问都要自己思考（笔记也不会涉及到任何直接给出代码的部分，有关自己的心得体会很可能是错的，请自己思考。遵守以下协议：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 169; 
			flex-basis: 406px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_79louUpRWq.png&#34; data-size=&#34;885x522&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_79louUpRWq.png&#34;
			width=&#34;885&#34;
			height=&#34;522&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_79louUpRWq_hu76b326673c9db4f94fe2a85d46dc5329_187133_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_79louUpRWq_hu76b326673c9db4f94fe2a85d46dc5329_187133_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;1最简单的操作系统&#34;&gt;1、最简单的操作系统&lt;/h2&gt;
&lt;p&gt;Nanos-lite是运行在AM之上, AM的API在Nanos-lite中都是可用的. 虽然操作系统对我们来说是一个特殊的概念, 但在AM看来, 它只是一个调用AM API的普通C程序而已, &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nanos-lite目前的行为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打印Project-N的logo, 并通过&lt;code&gt;Log()&lt;/code&gt;输出hello信息和编译时间. 在Nanos-lite中, &lt;code&gt;Log()&lt;/code&gt;宏通过你在&lt;code&gt;klib&lt;/code&gt;中编写的&lt;code&gt;printf()&lt;/code&gt;输出, 最终会调用TRM的&lt;code&gt;putch()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用&lt;code&gt;init_device()&lt;/code&gt;对设备进行一些初始化操作. 目前&lt;code&gt;init_device()&lt;/code&gt;会直接调用&lt;code&gt;ioe_init()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在NEMU中对磁盘进行模拟是一个略显复杂工作, 先让Nanos-lite把其中的一段内存作为磁盘来使用. 这样的磁盘有一个专门的名字, 叫ramdisk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;init_fs()&lt;/code&gt;和&lt;code&gt;init_proc()&lt;/code&gt;, 分别用于初始化文件系统和创建进程, 目前它们均未进行有意义的操作, 可以忽略它们.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用&lt;code&gt;panic()&lt;/code&gt;结束Nanos-lite的运行.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;回顾历史, 要实现一个最简单的操作系统, 就要实现以下两点功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户程序执行结束之后, 可以跳转到操作系统的代码继续执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统可以加载一个新的用户程序来执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（没错，就是fork与execve）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了操作系统的稳定性，我们所希望是一种可以限制入口的执行流切换方式,而不像用户程序那样可以随意切换PC跳转：&lt;/p&gt;
&lt;p&gt;i386：保护模式(protected mode)和特权级(privilege level)&lt;/p&gt;
&lt;p&gt;mips32处理器：内核模式和用户模式&lt;/p&gt;
&lt;p&gt;riscv32：机器模式(M-mode), 监控者模式(S-mode)和用户模式(U-mode)&lt;/p&gt;
&lt;p&gt;最厉害的是硬件检查：如mips32都是通过硬件检查，只要软件运行在硬件上面, 都无法逃出这一天网. 硬件保护机制使得恶意程序永远无法全身而退,&lt;/p&gt;
&lt;p&gt;在硬件中加入一些与特权级检查相关的门电路(例如比较器电路), 如果发现了非法操作, 就会抛出一个异常信号, 让CPU跳转到一个约定好的目标位置, 并进行后续处理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接看看效果：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 126; 
			flex-basis: 304px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_wl-aDRVg-_.png&#34; data-size=&#34;1033x815&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_wl-aDRVg-_.png&#34;
			width=&#34;1033&#34;
			height=&#34;815&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_wl-aDRVg-__hu3ac6f6641bfe7bd113eaf496964a2185_127215_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_wl-aDRVg-__hu3ac6f6641bfe7bd113eaf496964a2185_127215_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时会出现异常，因为我们还没实现csrw伪指令，但要注意的是这里中文文档有个错误，从csrwi的可以推测这里应该是csrrw，也可以直接看英文文档的说明&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 399; 
			flex-basis: 958px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LDGP_9AfA6.png&#34; data-size=&#34;1126x282&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LDGP_9AfA6.png&#34;
			width=&#34;1126&#34;
			height=&#34;282&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LDGP_9AfA6_hu2b6dde16788955947d1238f2cff20393_58027_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LDGP_9AfA6_hu2b6dde16788955947d1238f2cff20393_58027_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 393; 
			flex-basis: 943px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X89OzgaJq5.png&#34; data-size=&#34;1030x262&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X89OzgaJq5.png&#34;
			width=&#34;1030&#34;
			height=&#34;262&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X89OzgaJq5_hu11ac2d849f22d8082fecdbcb6ed8c8c9_101088_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X89OzgaJq5_hu11ac2d849f22d8082fecdbcb6ed8c8c9_101088_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里我们发现了一个名词“控制状态寄存器”，应该如何理解呢？我们看看下文中对控制状态寄存器的解释。&lt;/p&gt;
&lt;h2 id=&#34;2穿越时空的旅程&#34;&gt;2、穿越时空的旅程&lt;/h2&gt;
&lt;p&gt;硬件需要提供一种可以限制入口的执行流切换方式. 这种方式就是自陷指令, &lt;/p&gt;
&lt;p&gt;程序执行自陷指令之后, 就会陷入到操作系统预先设置好的跳转目标. 这个跳转目标也称为异常入口地址.&lt;/p&gt;
&lt;p&gt;非法指令可以定义成&amp;quot;不属于ISA手册描述范围的指令&amp;quot;, 而自陷指令可以认为是一种特殊的无条件失败. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;riscv32提供&lt;code&gt;ecall&lt;/code&gt;指令作为自陷指令, 并提供一个mtvec寄存器来存放异常入口地址. 为了保存程序当前的状态, &lt;strong&gt;riscv32提供了一些特殊的系统寄存器, 叫控制状态寄存器(CSR寄存器). 在PA中, 我们只使用如下3个CSR寄存器:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**mepc寄存器 **- 存放触发异常的PC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mstatus寄存器&lt;/strong&gt; - 存放处理器的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mcause寄存器&lt;/strong&gt; - 存放触发异常的原因&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;riscv32触发异常后硬件的响应过程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将当前PC值保存到mepc寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在mcause寄存器中设置异常号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从mtvec寄存器中取出异常入口地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转到异常入口地址&lt;/p&gt;
&lt;p&gt;上述保存程序状态以及跳转到异常入口地址的工作, 都是硬件自动完成的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们知道，如果要补全csrw指令，首先要能区分不同的控制状态寄存器，具体怎么区分呢，&lt;/p&gt;
&lt;p&gt;首先修复一下对应的指令，此时要注意的是CSR寄存器的实现方法。&lt;/p&gt;
&lt;p&gt;注意到：The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0]) for up to 4,096 CSRs.&lt;/p&gt;
&lt;p&gt;此时需要查阅的是新手大礼包（具体是哪个需要自己RTFM）之Control and Status Registers——CSR Listing的Currently allocated RISC-V machine-level CSR addresses&lt;/p&gt;
&lt;p&gt;因为此时立即数位置对应的就是CSR地址，打印出来后发现是0x305查手册后发现也确实是mtvec——Machine trap-handler base address.&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 205; 
			flex-basis: 492px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TG38eGv2Kl.png&#34; data-size=&#34;1020x497&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TG38eGv2Kl.png&#34;
			width=&#34;1020&#34;
			height=&#34;497&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TG38eGv2Kl_hude91585b3a5cb89f377fe46ccdfad849_95395_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TG38eGv2Kl_hude91585b3a5cb89f377fe46ccdfad849_95395_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;根据手册的地址进行匹配并存入寄存器。&lt;/p&gt;
&lt;h3 id=&#34;状态机视角下的异常响应机制&#34;&gt;状态机视角下的异常响应机制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;SR[mepc] &amp;lt;- PC       （发生异常的pc）&lt;/p&gt;
&lt;p&gt;SR[mcause] &amp;lt;- 一个描述失败原因的号码   &lt;/p&gt;
&lt;p&gt;PC &amp;lt;- SR[mtvec]     （异常入口地址）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fex: S -&amp;gt; {0, 1}&lt;/code&gt;, 给定状态机的任意状态&lt;code&gt;S&lt;/code&gt;, &lt;code&gt;fex(S)&lt;/code&gt;都可以唯一表示当前PC指向的指令是否可以成功执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 188; 
			flex-basis: 453px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LaO0TTipN2.png&#34; data-size=&#34;839x444&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LaO0TTipN2.png&#34;
			width=&#34;839&#34;
			height=&#34;444&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LaO0TTipN2_hucceae6fd0b7a28d0bae33271b867248a_36835_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_LaO0TTipN2_hucceae6fd0b7a28d0bae33271b867248a_36835_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;将上下文管理抽象成cte&#34;&gt;将上下文管理抽象成CTE&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;程序的状态, 在操作系统中有一个等价的术语, 叫&amp;quot;上下文&amp;quot;.AM的一类新的API中名字叫CTE(ConText Extension).&lt;/p&gt;
&lt;p&gt;与IOE一样, 上下文管理的具体实现也是架构相关的: 例如上文提到, x86/mips32/riscv32中分别通过&lt;code&gt;int&lt;/code&gt;/&lt;code&gt;syscall&lt;/code&gt;/&lt;code&gt;ecall&lt;/code&gt;指令来进行自陷, &lt;code&gt;native&lt;/code&gt;中甚至可以通过一些神奇的库函数来模拟相应的功能&lt;/p&gt;
&lt;p&gt;操作系统的处理过程其实需要哪些信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引发这次执行流切换的原因, 是程序除0, 非法指令, 还是触发断点, 又或者是程序自愿陷入操作系统? &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序的上下文了（寄存器）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把这两点信息抽象成一种统一的表示方式, 就可以定义出CTE的API.&lt;/p&gt;
&lt;p&gt; 对于切换原因, 我们只需要定义一种统一的描述方式即可. CTE定义了名为&amp;quot;事件&amp;quot;的数据结构(见&lt;code&gt;abstract-machine/am/include/am.h&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;event&lt;/code&gt;表示事件编号, &lt;code&gt;cause&lt;/code&gt;和&lt;code&gt;ref&lt;/code&gt;是一些描述事件的补充信息, &lt;code&gt;msg&lt;/code&gt;是事件信息字符串, 我们在PA中只会用到&lt;code&gt;event&lt;/code&gt;. 然后, 我们只要定义一些统一的事件编号(上述枚举常量), 让每个架构在实现各自的CTE API时, 都统一通过上述结构体来描述执行流切换的原因,&lt;/p&gt;
&lt;p&gt;对于上下文, 我们只能将描述上下文的结构体类型名统一成&lt;code&gt;Context&lt;/code&gt;至于其中的具体内容, 就无法进一步进行抽象了. 这主要是因为不同架构之间上下文信息的差异过大（比如各种寄存器）,在AM中, &lt;code&gt;Context&lt;/code&gt;的具体成员也是由不同的架构自己定义的, 比如&lt;code&gt;x86-nemu&lt;/code&gt;的&lt;code&gt;Context&lt;/code&gt;结构体在&lt;code&gt;abstract-machine/am/include/arch/x86-nemu.h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不过大多数情况下, 操作系统并不需要单独访问&lt;code&gt;Context&lt;/code&gt;结构中的成员. CTE也提供了一些的接口, 来让操作系统在必要的时候访问它们, 从而保证操作系统的相关代码与架构无关.&lt;/p&gt;
&lt;p&gt;最后还有另外两个统一的API:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bool cte_init(Context* (*handler)(Event ev, Context *ctx))&lt;/code&gt;用于进行CTE相关的初始化操作. 其中它还&lt;strong&gt;接受一个来自操作系统的事件处理回调函数的指针,&lt;/strong&gt; 当发生事件时,** CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理**.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void yield()&lt;/code&gt;用于进行自陷操作, 会触发一个编号为&lt;code&gt;EVENT_YIELD&lt;/code&gt;事件.** 不同的ISA会使用不同的自陷指令来触发自陷操作**,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Q：AM究竟给&lt;strong&gt;程序&lt;/strong&gt;提供了多大的栈空间呢? 事实上, 如果你在PA2的时候尝试努力了解每一处细节, 你已经知道这个问题的答案了;&lt;/p&gt;
&lt;p&gt;A：&lt;/p&gt;
&lt;p&gt;_stack_top = ALIGN(0x1000);&lt;/p&gt;
&lt;p&gt;. = _stack_top + 0x8000;&lt;/p&gt;
&lt;p&gt;_stack_pointer = .;&lt;/p&gt;
&lt;p&gt;end = .;&lt;/p&gt;
&lt;p&gt;_end = .;&lt;/p&gt;
&lt;p&gt;_heap_start = ALIGN(0x1000);&lt;/p&gt;
&lt;p&gt;注意区别：&lt;/p&gt;
&lt;p&gt;/* Minimum stack size for a signal handler. */&lt;/p&gt;
&lt;p&gt;#define MINSIGSTKSZ 2048&lt;/p&gt;
&lt;p&gt;/* System default stack size. */&lt;/p&gt;
&lt;p&gt;#define SIGSTKSZ 8192&lt;/p&gt;
&lt;h3 id=&#34;插播一个潜在大坑&#34;&gt;插播一个潜在大坑&lt;/h3&gt;
&lt;p&gt;【发现者为jyyos群的杨婆婆，也是一位超神的大佬】：&lt;/p&gt;
&lt;p&gt;涉及到ra寄存器相关跳转的顺序问题，要严格按照这个顺序操作&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 484; 
			flex-basis: 1163px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tXKZguEUsv.png&#34; data-size=&#34;1023x211&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tXKZguEUsv.png&#34;
			width=&#34;1023&#34;
			height=&#34;211&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tXKZguEUsv_huc1adf31eaa12d9a76fb172ec326940d6_65743_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tXKZguEUsv_huc1adf31eaa12d9a76fb172ec326940d6_65743_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为什么呢？原因是如果我们的源操作数和目的操作数寄存器刚好是同一个的时候（比如ra），重复写入会直接覆盖值，如果我们先用pc+4赋值，很可能再次使用的时候就会出大问题，值被提前覆盖了！！！&lt;/p&gt;
&lt;h3 id=&#34;尝试在nanos-lite中触发一次自陷操作&#34;&gt;尝试在Nanos-lite中触发一次自陷操作&lt;/h3&gt;
&lt;h4 id=&#34;设置异常入口地址&#34;&gt;设置异常入口地址&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;按照ISA的约定来设置异常入口地址, 将来切换执行流时才能跳转到正确的异常入口. 这显然是架构相关的行为, 因此我们把这一行为放入CTE中, 而不是让Nanos-lite直接来设置异常入口地址. &lt;/p&gt;
&lt;p&gt;你需要在&lt;code&gt;nanos-lite/include/common.h&lt;/code&gt;中定义宏&lt;code&gt;HAS_CTE&lt;/code&gt;, 这样以后, Nanos-lite会多进行一项初始化工作: 调用&lt;code&gt;init_irq()&lt;/code&gt;函数, 这最终会调用位于&lt;code&gt;abstract-machine/am/src/nemu/isa/$ISA/cte.c&lt;/code&gt;中的&lt;code&gt;cte_init()&lt;/code&gt;函数. &lt;code&gt;cte_init()&lt;/code&gt;函数会做两件事情, 第一件就是设置异常入口地址&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cte_init()&lt;/code&gt;函数做的第二件事是注册一个事件处理回调函数, 这个回调函数由Nanos-lite提供,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于riscv32来说, 直接将异常入口地址设置到mtvec寄存器中即可.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现完各种指令框架后我们能看到&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 136; 
			flex-basis: 327px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-Iu7mDHnwA.png&#34; data-size=&#34;1130x827&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-Iu7mDHnwA.png&#34;
			width=&#34;1130&#34;
			height=&#34;827&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-Iu7mDHnwA_hu92d90df7223698c84e42742f0b431ae0_154428_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-Iu7mDHnwA_hu92d90df7223698c84e42742f0b431ae0_154428_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时还没完全实现ecall，进入实现过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你需要实现上文提到的新指令, 并实现&lt;code&gt;isa_raise_intr()&lt;/code&gt;函数. 然后阅读&lt;code&gt;cte_init()&lt;/code&gt;的代码, 找出相应的异常入口地址.&lt;/p&gt;
&lt;p&gt;实现后, 重新运行Nanos-lite, 如果你发现NEMU确实跳转到你找到的异常入口地址, 说明你的实现正确&lt;/p&gt;
&lt;p&gt;你需要在自陷指令的辅助函数中调用&lt;code&gt;isa_raise_intr()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时先实现&lt;code&gt;isa_raise_intr&lt;/code&gt;，模拟上文提到的异常响应机制：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 211; 
			flex-basis: 507px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_mKFE5NXPxt.png&#34; data-size=&#34;425x201&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_mKFE5NXPxt.png&#34;
			width=&#34;425&#34;
			height=&#34;201&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_mKFE5NXPxt_hudf79569b4fb48fb1c84991ce06cb5cf8_33105_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_mKFE5NXPxt_hudf79569b4fb48fb1c84991ce06cb5cf8_33105_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;会发现我们需要找到一个NO，而这个异常NO可以在yield的代码中“领略到怎么获取”，我们直接看他的汇编代码&lt;code&gt;asm volatile(&amp;quot;li a7, -1; ecall&amp;quot;)&lt;/code&gt;; 可以猜想是不是和a7有关呢？这时候可以拿出a7看看。至于怎么拿出，这个就是基础操作了。（注意：这里其实是错误的，之后会说为什么）&lt;/p&gt;
&lt;p&gt;同时我们再看到&lt;code&gt;asm volatile(&amp;quot;csrw mtvec, %0&amp;quot; :  : &amp;quot;r&amp;quot;(__am_asm_trap));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是什么意思呢，首先我们能知道应该是把寄存器的值写入控制状态寄存器（有理由猜测这就是异常地址），那后面的&amp;quot;r&amp;quot;是什么意思呢？&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 171; 
			flex-basis: 412px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jBWMD2oFED.png&#34; data-size=&#34;878x511&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jBWMD2oFED.png&#34;
			width=&#34;878&#34;
			height=&#34;511&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jBWMD2oFED_hucb0860e21a63e781bd45f2dcedb203c1_49164_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jBWMD2oFED_hucb0860e21a63e781bd45f2dcedb203c1_49164_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们可以对照一下知道了那是输入操作数，我们有理由猜测这就是为了把trap相关的地址存到mtvec，在另外一个文件可以看到类似的东西&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 246; 
			flex-basis: 590px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_uLAvhvpBAS.png&#34; data-size=&#34;980x398&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_uLAvhvpBAS.png&#34;
			width=&#34;980&#34;
			height=&#34;398&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_uLAvhvpBAS_huf90e3e5ce73e39db45e3115b4a2f240d_75666_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_uLAvhvpBAS_huf90e3e5ce73e39db45e3115b4a2f240d_75666_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时大胆猜测这就是异常相关入口。&lt;/p&gt;
&lt;p&gt;一顿操作猛如虎实现了ecall调用，找了个地方加入了异常处理的寄存器：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 113; 
			flex-basis: 272px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_L64lph05Y0.png&#34; data-size=&#34;908x801&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_L64lph05Y0.png&#34;
			width=&#34;908&#34;
			height=&#34;801&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_L64lph05Y0_huedb4cb21fa9f62021371ee4203fa9457_160347_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_L64lph05Y0_huedb4cb21fa9f62021371ee4203fa9457_160347_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;开diff检查发现了问题：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 107; 
			flex-basis: 257px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XKNnHKIekD.png&#34; data-size=&#34;777x725&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XKNnHKIekD.png&#34;
			width=&#34;777&#34;
			height=&#34;725&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XKNnHKIekD_hubf2b024b79d53d725028804e1675dcfa_65120_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XKNnHKIekD_hubf2b024b79d53d725028804e1675dcfa_65120_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为啥是b呢？我们发现这其实是mcause的返回值，难道不是前面的li a7 -1吗？？？&lt;/p&gt;
&lt;p&gt;经过搜索手册可以查到那其实表示一种environment call。&lt;/p&gt;
&lt;p&gt;经过查阅资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RISC-V中系统调用通过（environment call）来实现。在U-mode、S-mode、M-mode下执行 &lt;code&gt;ecall&lt;/code&gt;分别会触发environment-call-from-U-mode异常、environment-call-from-S-mode异常、environment-call-from-M-mode异常。在系统调用的实现中，我们通过在U-mode下执行 &lt;code&gt;ecall&lt;/code&gt;触发environment-call-from-U-mode异常，并由S-mode中运行的内核处理这个异常。&lt;/p&gt;
&lt;p&gt;在head.S中内核boot阶段时，设置 medeleg 寄存器为用户模式系统调用添加异常委托。 在没有设置异常委托的情况下，&lt;code&gt;ecall&lt;/code&gt;指令产生的异常由M-mode来处理，而不是交由内核所在的S-mode进行处理。通过 medeleg 中设置相应的位，可以将environment-call-from-U-mode异常直接交由S-mode处理。&lt;/p&gt;
&lt;p&gt;链接：&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/24960401/answer/2308952497&#34;  title=&#34;https://www.zhihu.com/question/24960401/answer/2308952497&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/24960401/answer/2308952497&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;来源：知乎  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么里面的U,S,M是什么意思呢？以支持现代操作系统的RISC-V处理器为例, 它们存在M, S, U三个特权模式, 分别代表机器模式, 监管者模式和用户模式. M模式特权级最高, U模式特权级最低。所以我们知道了到底是什么调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;华中科技大学操作系统团队：&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/hustos/pke-doc/blob/master/chapter1_riscv.md&#34;  title=&#34;https://gitee.com/hustos/pke-doc/blob/master/chapter1_riscv.md&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gitee.com/hustos/pke-doc/blob/master/chapter1_riscv.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;系统发生中断（我们用中文的“中断”这个名词来指代广义的中断，并非以上的interrupt）时执行的这段程序，往往被称为&lt;strong&gt;中断例程&lt;/strong&gt;（interrupt routine）。因为事件的多样性，系统可能有多个这样的中断例程，通常的做法是把这些例程的入口放在一张表中，而这张表一般称为&lt;strong&gt;中断向量表&lt;/strong&gt;（interrupt table）。RV64G处理器在发生中断后，会将发生的中断类型、编号自动记录（硬件完成）到目标模式的CSR中。&lt;strong&gt;假设发生中断的目标模式为M模式，则中断的这些信息会记录到mcause寄存器。&lt;/strong&gt; 表1.7列出了mcause的可能取值以及对应的中断信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么a7到底是什么呢，从man syscall可以查到，原来只是用于存放syscall调用号的地方，并不是真正的mcause，只是为了触发自陷操作,不同ISA的实现不同的(可以全局搜索yield)&lt;/p&gt;
&lt;p&gt;（至于为什么是-1，和小伙伴讨论还是个迷）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 139; 
			flex-basis: 334px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jGFU-H3yDx.png&#34; data-size=&#34;1225x880&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jGFU-H3yDx.png&#34;
			width=&#34;1225&#34;
			height=&#34;880&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jGFU-H3yDx_hu2a1373e3e8017b16d49f8611813f3de3_172961_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_jGFU-H3yDx_hu2a1373e3e8017b16d49f8611813f3de3_172961_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来目的就是找到正确的mcause，什么才是正确的呢？这里就需要你查手册理解PA有几种模式了，以及理解为什么说在后面我们会再次用到&lt;code&gt;isa_raise_intr()&lt;/code&gt;函数。（想想&lt;code&gt;isa_raise_intr()&lt;/code&gt;的翻译是什么？并不是异常指令）&lt;/p&gt;
&lt;p&gt;你可以用diff检查自己实现的对不对。&lt;/p&gt;
&lt;p&gt;通过diff检查：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 174; 
			flex-basis: 419px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tFgyzY_Ye7.png&#34; data-size=&#34;987x565&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tFgyzY_Ye7.png&#34;
			width=&#34;987&#34;
			height=&#34;565&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tFgyzY_Ye7_hu5cb4816abed766fd9b57d7f6ae056e7f_140748_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tFgyzY_Ye7_hu5cb4816abed766fd9b57d7f6ae056e7f_140748_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;保存上下文&#34;&gt;保存上下文&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;现在的通用寄存器, 里面存放的都是执行流切换之前的内容. 这些内容也是上下文的一部分, 如果不保存就覆盖它们, 将来就无法恢复这一上下文了. 但通常硬件并不负责保存它们, 因此需要通过软件代码来保存它们的值. riscv32则通过&lt;code&gt;sw&lt;/code&gt;指令将各个通用寄存器依次压栈.&lt;/p&gt;
&lt;p&gt;除了通用寄存器之外, 上下文还包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**触发异常时的PC和处理器状态. **epc/mepc和status/mstatus寄存器, 异常响应机制把它们保存在相应的系统寄存器中, 我们还需要将它们从系统寄存器中读出, 然后保存在堆栈上.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**异常号. **异常号已经由硬件保存在cause/mcause寄存器中, 我们还需要将其保存在堆栈上.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;地址空间.&lt;/strong&gt; 这是为PA4准备的,将地址空间信息与0号寄存器共用存储空间, 反正0号寄存器的值总是0, 也不需要保存和恢复. 我们暂时不使用地址空间信息, 你目前可以忽略它们的含义.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;问异常号的保存&#34;&gt;问：异常号的保存&lt;/h4&gt;
&lt;p&gt;Q:x86通过软件来保存异常号, 没有类似cause的寄存器. mips32和riscv32也可以这样吗? 为什么?&lt;/p&gt;
&lt;p&gt;A：我认为可以，因为异常地址之类的都能保存到上下文信息，那么riscv也可以有。&lt;/p&gt;
&lt;h4 id=&#34;重新组织context结构体&#34;&gt;重新组织Context结构体&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;你的任务如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实现这一过程中的新指令, 详情请RTFM.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解上下文形成的过程并RTFSC, 然后重新组织&lt;code&gt;abstract-machine/am/include/arch/$ISA-nemu.h&lt;/code&gt; 中定义的&lt;code&gt;Context&lt;/code&gt;结构体的成员, 使得这些成员的定义顺序和 &lt;code&gt;abstract-machine/am/src/$ISA/nemu/trap.S&lt;/code&gt;中构造的上下文保持一致.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是, 虽然我们目前暂时不使用上文提到的地址空间信息, 但你在重新组织&lt;code&gt;Context&lt;/code&gt;结构体时仍&lt;strong&gt;然需要正确地处理地址空间信息的位置,&lt;/strong&gt; 否则你可能会在PA4中遇到难以理解的错误.&lt;/p&gt;
&lt;p&gt;实现之后, 你可以在&lt;code&gt;__am_irq_handle()&lt;/code&gt;中通过&lt;code&gt;printf&lt;/code&gt;输出上下文&lt;code&gt;c&lt;/code&gt;的内容, 然后通过简易调试器观察触发自陷时的寄存器状态, 从而检查你的&lt;code&gt;Context&lt;/code&gt;实现是否正确.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这部分关键是理解结构体和汇编语言的关系，让我们看一段示例代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;


&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fun&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;123&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1234&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12345&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;汇编代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-6502&amp;#x20;assembly&#34; data-lang=&#34;6502&amp;#x20;assembly&#34;&gt;  pushl   %ebp
  movl    %esp, %ebp
  subl    $16, %esp
  //ret=0;
  movl    $0, -16(%ebp)
  //tmp.ch=&#39;a&#39;;
  movb    $97, -12(%ebp)
  //tmp.s=123;
  movw    $123, -10(%ebp)
  //tmp.i=1234;
  movl    $1234, -8(%ebp)
  //tmp.l=12345;
  movl    $12345, -4(%ebp)
  //返回值
  movl    -16(%ebp), %eax
  leave
  ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从顺序上我们就知道根据压入栈该如何组织结构体了，同时我们也可以在handler处理后看到结果。&lt;/p&gt;
&lt;h4 id=&#34;问必答题需要在实验报告中回答---理解上下文结构体的前世今生&#34;&gt;问：必答题(需要在实验报告中回答) - 理解上下文结构体的前世今生&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;你会在&lt;code&gt;__am_irq_handle()&lt;/code&gt;中看到有一个上下文结构指针&lt;code&gt;c&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的? 具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的? &lt;code&gt;$ISA-nemu.h&lt;/code&gt;, &lt;code&gt;trap.S&lt;/code&gt;, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令, 这四部分内容又有什么联系?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：本质是Context* (&lt;em&gt;user_handler)(Event, Context&lt;/em&gt;)的结构体指针。其中定义在am.h，赋值在cte_init阶段初始化&lt;/p&gt;
&lt;p&gt;（怀疑就是为了软件存储上下文信息。所谓的保存到堆栈（S的过程））&lt;/p&gt;
&lt;p&gt;具体的Context是怎么被加载的？&lt;/p&gt;
&lt;p&gt;首先我们能在S中找到.globl __am_asm_trap，其中.globl关键字作用是&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/image/8%7dBZVLYNSMF-4G%7d-%5c%283DDGWJ_fbcT98jcT7.png&#34; &gt;
		&lt;img src=&#34;https://sanbuphy.github.io/image/8%7dBZVLYNSMF-4G%7d-%5c%283DDGWJ_fbcT98jcT7.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;能被链接后，就会和extern相对应，所以我们确定__am_irq_trap 是可以在链接过程打包到可执行文件的&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/image/%5c%297%60_%7d]WQ9IQ%5c%29%5c%29VWNP%5c%28CD%5c~DM_Drh4r0nTcu.png&#34; &gt;
		&lt;img src=&#34;https://sanbuphy.github.io/image/%5c%297%60_%7d]WQ9IQ%5c%29%5c%29VWNP%5c%28CD%5c~DM_Drh4r0nTcu.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 62; 
			flex-basis: 150px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_bKSOwKodOu.png&#34; data-size=&#34;447x715&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_bKSOwKodOu.png&#34;
			width=&#34;447&#34;
			height=&#34;715&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_bKSOwKodOu_hu4319e2fab4f40aac1430e6b1f9236ca9_111124_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_bKSOwKodOu_hu4319e2fab4f40aac1430e6b1f9236ca9_111124_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再回顾S代码，我们发现这确实就是结构体的push过程。最开始是寄存器，最后是mepc。（我们可以通过打印结构体指针的讯息来看看是不是对应的位置（比如mepc）。）同时我们可以注意到jal __am_irq_handle，这里就真正跳转到了框架代码。但这个明明是Context &lt;em&gt;，哪来的Context&lt;/em&gt;？&lt;/p&gt;
&lt;p&gt;可以合理猜测应该是mv a0,sp 中传入sp得到了context的指针信息Context *c，而结构体指针的第一个成员的地址也即是结构体指针的地址。&lt;/p&gt;
&lt;h3 id=&#34;事件分发&#34;&gt;事件分发&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;__am_irq_handle()&lt;/code&gt;的代码会把执行流切换的原因打包成事件, 然后调用在&lt;code&gt;cte_init()&lt;/code&gt;中注册的事件处理回调函数（&lt;em&gt;user_handler&lt;/em&gt;）, 将事件交给Nanos-lite来处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 191; 
			flex-basis: 459px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_yQGHt4UZNy.png&#34; data-size=&#34;701x366&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_yQGHt4UZNy.png&#34;
			width=&#34;701&#34;
			height=&#34;366&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_yQGHt4UZNy_huf8d6eadf421d6d75c02b75f8429c7860_37428_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_yQGHt4UZNy_huf8d6eadf421d6d75c02b75f8429c7860_37428_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 222; 
			flex-basis: 534px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_anE1Gr1k6B.png&#34; data-size=&#34;1273x572&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_anE1Gr1k6B.png&#34;
			width=&#34;1273&#34;
			height=&#34;572&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_anE1Gr1k6B_hu416f69f5684d041696d431321b4579a1_78607_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_anE1Gr1k6B_hu416f69f5684d041696d431321b4579a1_78607_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;实现完成后发现卡在自现异常的死循环,之后会解决这个问题&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 153; 
			flex-basis: 367px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_R3UC5okCSz.png&#34; data-size=&#34;1128x737&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_R3UC5okCSz.png&#34;
			width=&#34;1128&#34;
			height=&#34;737&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_R3UC5okCSz_hu9f9828947a5c09800c2232b7caab3ac8_80600_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_R3UC5okCSz_hu9f9828947a5c09800c2232b7caab3ac8_80600_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;恢复上下文&#34;&gt;恢复上下文&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;代码将会一路返回到&lt;code&gt;trap.S&lt;/code&gt;的&lt;code&gt;__am_asm_trap()&lt;/code&gt;中, 接下来的事情就是恢复程序的上下文. &lt;code&gt;__am_asm_trap()&lt;/code&gt;将根据之前保存的上下文内容, 恢复程序的状态, 最后执行&amp;quot;异常返回指令&amp;quot;返回到程序触发异常之前的状态.&lt;/p&gt;
&lt;p&gt;需要注意之前自陷指令保存的PCr。iscv32的&lt;code&gt;ecall&lt;/code&gt;, 保存的是自陷指令的PC, 因此需要在适当的地方对保存的PC加上4, 使得将来返回到自陷指令的下一条指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么叫做合适的地方？我们该想想什么叫做恢复上下文——用什么恢复？&lt;/p&gt;
&lt;p&gt;所以我们应该在恢复的地方将pc+4。&lt;/p&gt;
&lt;h4 id=&#34;问从加4操作看cisc和risc&#34;&gt;问：从加4操作看CISC和RISC&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上, 自陷只是其中一种异常类型. 有一种故障类异常, 它们返回的PC和触发异常的PC是同一个, 例如缺页异常, 在系统将故障排除后, 将会重新执行相同的指令进行重试, 因此异常返回的PC无需加4. 所以根据异常类型的不同, 有时候需要加4, 有时候则不需要加.&lt;/p&gt;
&lt;p&gt;这时候, 我们就可以考虑这样的一个问题了: 决定要不要加4的, 是硬件还是软件呢? CISC和RISC的做法正好相反, CISC都交给硬件来做, 而RISC则交给软件来做. 思考一下, 这两种方案各有什么取舍? 你认为哪种更合理呢? 为什么?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：riscv不支持用硬件，只有一个，是因为pc要存在mepc里，mepc只有1个，x86执行到int指令后会直接把flags,cs,ip压栈。x86是硬件做的 (by pony)&lt;/p&gt;
&lt;p&gt;而且我倾向于x86放在硬件主要是指令太多，放在软件会拖慢速度而且可能会导致奇奇怪怪的问题。&lt;/p&gt;
&lt;h4 id=&#34;问必答题需要在实验报告中回答---理解穿越时空的旅程&#34;&gt;问：必答题(需要在实验报告中回答) - 理解穿越时空的旅程&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;从Nanos-lite调用&lt;code&gt;yield()&lt;/code&gt;开始, 到从&lt;code&gt;yield()&lt;/code&gt;返回的期间, 这一趟旅程具体经历了什么? 软(AM, Nanos-lite)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节, 包括涉及的每一行汇编代码/C代码的行为, 尤其是一些比较关键的指令/变量. 事实上, 上文的必答题&amp;quot;理解上下文结构体的前世今生&amp;quot;已经涵盖了这趟旅程中的一部分, 你可以把它的回答包含进来.&lt;/p&gt;
&lt;p&gt;别被&amp;quot;每一行代码&amp;quot;吓到了, 这个过程也就大约50行代码, 要完全理解透彻并不是不可能的. 我们之所以设置这道必答题, 是为了强迫你理解清楚这个过程中的每一处细节. 这一理解是如此重要, 以至于如果你缺少它, 接下来你面对bug几乎是束手无策&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：暂时参考理解上下文结构体的前世今生&lt;/p&gt;
&lt;h2 id=&#34;3用户程序和系统调用&#34;&gt;3、用户程序和系统调用&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 133; 
			flex-basis: 320px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_BelyiKXswJ.png&#34; data-size=&#34;886x663&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_BelyiKXswJ.png&#34;
			width=&#34;886&#34;
			height=&#34;663&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_BelyiKXswJ_huc7ce369b0152d87359697f021c2fdf44_133086_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_BelyiKXswJ_huc7ce369b0152d87359697f021c2fdf44_133086_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这部分强烈推荐先看袁妈妈有关链接和可执行文件的讲解&lt;/p&gt;
&lt;p&gt;简直是手把手喂给你：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1kE411X7S5&#34;  title=&#34;https://www.bilibili.com/video/BV1kE411X7S5&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1kE411X7S5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 141; 
			flex-basis: 338px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_rbSAocB3uS.png&#34; data-size=&#34;1261x894&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_rbSAocB3uS.png&#34;
			width=&#34;1261&#34;
			height=&#34;894&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_rbSAocB3uS_hu19e08bf6cefd7943bd8f7e2cf2fc2775_887649_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_rbSAocB3uS_hu19e08bf6cefd7943bd8f7e2cf2fc2775_887649_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;加载第一个用户程序&#34;&gt;加载第一个用户程序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;加载的过程就是把可执行文件中的代码和数据放置在正确的内存位置,&lt;/p&gt;
&lt;p&gt;然后跳转到程序入口, 程序就开始执行了. &lt;/p&gt;
&lt;p&gt;更具体的, 为了实现&lt;code&gt;loader()&lt;/code&gt;函数, 我们需要解决以下问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可执行文件在哪里?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码和数据在可执行文件的哪个位置?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码和数据有多少?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;正确的内存位置&amp;quot;在哪里?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中, &lt;code&gt;navy-apps/libs/libc&lt;/code&gt;中是一个名为&lt;a class=&#34;link&#34; href=&#34;https://sourceware.org/newlib/&#34;  title=&#34;Newlib&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Newlib&lt;/a&gt;的项目, 它是一个专门为嵌入式系统提供的C库, 库中的函数对运行时环境的要求极低. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户程序的入口位于&lt;/strong&gt;&lt;code&gt;navy-apps/libs/libos/src/crt0/start/$ISA.S&lt;/code&gt;中的&lt;code&gt;_start()&lt;/code&gt;函数, 这里的&lt;code&gt;crt&lt;/code&gt;是&lt;code&gt;C RunTime&lt;/code&gt;的缩写, &lt;code&gt;0&lt;/code&gt;的含义表示最开始. &lt;code&gt;_start()&lt;/code&gt;函数会调用&lt;code&gt;navy-apps/libs/libos/src/crt0/crt0.c&lt;/code&gt;中的&lt;code&gt;call_main()&lt;/code&gt;函数, 然后调用用户程序的&lt;code&gt;main()&lt;/code&gt;函数, 从&lt;code&gt;main()&lt;/code&gt;函数返回后会调用&lt;code&gt;exit()&lt;/code&gt;结束运行.&lt;/p&gt;
&lt;p&gt;我们约定目前用户程序需要被链接到内存位置&lt;code&gt;0x83000000&lt;/code&gt;附近, Navy已经设置好了相应的选项(见&lt;code&gt;navy-apps/scripts/$ISA.mk&lt;/code&gt;中的&lt;code&gt;LDFLAGS&lt;/code&gt;变量).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：这里我的电脑在make ISA=riscv32的时候出现了问题，我怀疑是交叉汇编环境冲突。。不明白(assert.h相关说undefined reference to `__assert_fail&#39;）于是从另外一个电脑弄来了编译通过的文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可执行文件位于ramdisk偏移为0处, 访问它就可以得到用户程序的第一个字节.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;问堆和栈在哪里&#34;&gt;问：堆和栈在哪里?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;我们提到了代码和数据都在可执行文件里面, 但却没有提到堆(heap)和栈(stack). 为什么堆和栈的内容没有放入可执行文件里面? 那程序运行时刻用到的堆和栈又是怎么来的? AM的代码是否能给你带来一些启发?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：这些代码和数据本身都是静态的。程序要想运行，首先要OS负责为其创建进程，并在进程的虚拟地址空间中为其代码段和数据段建立映射。光有代码段和数据段是不够的，进程在运行过程中还要有其动态环境，其中最重要的就是堆栈。&lt;/p&gt;
&lt;p&gt;内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。&lt;/p&gt;
&lt;h4 id=&#34;问如何识别不同格式的可执行文件&#34;&gt;问：如何识别不同格式的可执行文件?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件, 将会报告&amp;quot;格式错误&amp;rdquo;. 思考一下, GNU/Linux是如何知道&amp;quot;格式错误&amp;quot;的?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt; 不同组织形式形成了不同格式的可执行文件, 例如Windows主流的可执行文件是&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Portable_Executable&#34;  title=&#34;PE(Portable Executable)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PE(Portable Executable)&lt;/a&gt;格式, 而GNU/Linux主要使用&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Executable_and_Linkable_Format&#34;  title=&#34;ELF(Executable and Linkable Format)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ELF(Executable and Linkable Format)&lt;/a&gt;格式. 因此一般情况下, 你不能在Windows下把一个可执行文件拷贝到GNU/Linux下执行, 反之亦然. ELF是GNU/Linux可执行文件的标准格式, 这是因为GNU/Linux遵循System V ABI(&lt;a class=&#34;link&#34; href=&#34;http://stackoverflow.com/questions/2171177/what-is-application-binary-interface-abi&#34;  title=&#34;Application Binary Interface&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Application Binary Interface&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 227; 
			flex-basis: 547px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_hfRQXj7lxB.png&#34; data-size=&#34;832x365&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_hfRQXj7lxB.png&#34;
			width=&#34;832&#34;
			height=&#34;365&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_hfRQXj7lxB_hu1c43725c804a27414cd3ee66ab31d317_469186_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_hfRQXj7lxB_hu1c43725c804a27414cd3ee66ab31d317_469186_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;E:可执行 L：链接&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 243; 
			flex-basis: 583px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_iATXT8xti3.png&#34; data-size=&#34;870x358&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_iATXT8xti3.png&#34;
			width=&#34;870&#34;
			height=&#34;358&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_iATXT8xti3_hu06c1c2e1ea9a5afccd677ac763adc274_165860_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_iATXT8xti3_hu06c1c2e1ea9a5afccd677ac763adc274_165860_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过解析数据结构可以得到信息。比如ELF头。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ELF文件提供了两个视角来组织一个可执行文件,&lt;/p&gt;
&lt;p&gt;一个是面向链接过程的section视角, 这个视角提供了用于链接与重定位的信息(例如符号表); &lt;/p&gt;
&lt;p&gt;另一个是面向执行的segment视角, 这个视角提供了用于加载可执行文件的信息. &lt;/p&gt;
&lt;p&gt;可以参考这篇文章：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/GoolyOh/article/details/119801160&#34;  title=&#34;https://blog.csdn.net/GoolyOh/article/details/119801160&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/GoolyOh/article/details/119801160&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 183; 
			flex-basis: 440px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_FaWhoqy3y-.png&#34; data-size=&#34;529x288&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_FaWhoqy3y-.png&#34;
			width=&#34;529&#34;
			height=&#34;288&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_FaWhoqy3y-_hu52573777e025c4c7992f28a13b2ce878_94607_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_FaWhoqy3y-_hu52573777e025c4c7992f28a13b2ce878_94607_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 一个segment可能由0个或多个section组成, 但一个section可能不被包含于任何segment中.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;program header table的一个表项&lt;/strong&gt;描述了一个segment的所有属性, 包括类型, &lt;strong&gt;虚拟地址&lt;/strong&gt;, 标志, 对齐方式, 以及&lt;strong&gt;文件内偏移量和segment大小.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载一个可执行文件并不是加载它所包含的所有内容, 只要加载那些与运行时刻相关的内容就可以了, 例如调试信息和符号表就不必加载. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以通过判断segment的&lt;/strong&gt;&lt;code&gt;Type&lt;/code&gt;属性是否为&lt;code&gt;PT_LOAD&lt;/code&gt;来判断一个segment是否需要加载.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;问冗余的属性&#34;&gt;问：冗余的属性?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;readelf&lt;/code&gt;查看一个ELF文件的信息, 你会看到一个segment包含两个大小的属性, 分别是&lt;code&gt;FileSiz&lt;/code&gt;和&lt;code&gt;MemSiz&lt;/code&gt;, 这是为什么? 再仔细观察一下, 你会发现&lt;code&gt;FileSiz&lt;/code&gt;通常不会大于相应的&lt;code&gt;MemSiz&lt;/code&gt;, 这又是为什么?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答： 相对文件偏移&lt;code&gt;Offset&lt;/code&gt;指出&lt;strong&gt;相应segment的内容从ELF文件&lt;/strong&gt;的第&lt;code&gt;Offset&lt;/code&gt;字节开始,&lt;strong&gt;在文件中的大小&lt;/strong&gt;为&lt;code&gt;FileSiz&lt;/code&gt;, 它需要被分配到以&lt;code&gt;VirtAddr&lt;/code&gt;为首地址的虚拟内存位置, &lt;strong&gt;在内存中它占用大小&lt;/strong&gt;为&lt;code&gt;MemSiz&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这个segment使用的内存就是&lt;code&gt;[VirtAddr, VirtAddr + MemSiz)&lt;/code&gt;这一连续区间, 然后将segment的内容从ELF文件中读入到这一内存区间, &lt;/p&gt;
&lt;p&gt;想想为什么要预留nobits的空间——本质是.bss相关。&lt;/p&gt;
&lt;p&gt;你需要找出每一个需要加载的segment的&lt;code&gt;Offset&lt;/code&gt;, &lt;code&gt;VirtAddr&lt;/code&gt;, &lt;code&gt;FileSiz&lt;/code&gt;和&lt;code&gt;MemSiz&lt;/code&gt;这些参数. 其中相对文件偏移&lt;code&gt;Offset&lt;/code&gt;指出相应segment的内容从ELF文件的第&lt;code&gt;Offset&lt;/code&gt;字节开始, 在文件中的大小为&lt;code&gt;FileSiz&lt;/code&gt;, 它需要被分配到以&lt;code&gt;VirtAddr&lt;/code&gt;为首地址的虚拟内存位置, 在内存中它占用大小为&lt;code&gt;MemSiz&lt;/code&gt;. 也就是说, 这个segment使用的内存就是&lt;code&gt;[VirtAddr, VirtAddr + MemSiz)&lt;/code&gt;这一连续区间, 然后将segment的内容从ELF文件中读入到这一内存区间, 并将&lt;code&gt;[VirtAddr + FileSiz, VirtAddr + MemSiz)&lt;/code&gt;对应的物理区间清零.&lt;/p&gt;
&lt;h4 id=&#34;问为什么要清零&#34;&gt;问：为什么要清零?&lt;/h4&gt;
&lt;p&gt;为什么需要将 &lt;code&gt;[VirtAddr + FileSiz, VirtAddr + MemSiz)&lt;/code&gt; 对应的物理区间清零?&lt;/p&gt;
&lt;p&gt;.bss清零的原因:(注意初始化为0的全局变量也在bss）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 138; 
			flex-basis: 333px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_z90Ix8LOpx.png&#34; data-size=&#34;1163x837&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_z90Ix8LOpx.png&#34;
			width=&#34;1163&#34;
			height=&#34;837&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_z90Ix8LOpx_hu8a7a4bcb602858122046c9a941b795ba_1003185_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_z90Ix8LOpx_hu8a7a4bcb602858122046c9a941b795ba_1003185_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a class=&#34;link&#34; href=&#34;http://www.zhihu.com/question/23147702/answer/23738366&#34;  title=&#34;http://www.zhihu.com/question/23147702/answer/23738366&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.zhihu.com/question/23147702/answer/23738366&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BSS段清零的原因是因为这个段是BSS  &lt;/p&gt;
&lt;p&gt;要说为什么要有BSS的话，历史就比较久远了。  &lt;/p&gt;
&lt;p&gt;BSS段我所知道的起源是Unix最初的时候（当然，不排除可能有更早的情况）。变量分两种：局部变量、全局变量。根据C语法的规定，局部变量不设置初始值的时候，其初始值是不确定的，局部变量（不含静态局部变量）的存储位置位于栈上，具体位置不固定。全局变量（和静态局部变量）有专门数据段存储，初始值是0，具体位置是固定的。其实说到底，就两种，一种是位置固定（数据段里），一种是位置不固定的（栈上）。  &lt;/p&gt;
&lt;p&gt;要知道，早期的计算机存储设备是很贵的，而很多时候，数据段里的全局变量都是0（或者没有初始值），那么存储这么多的0到目标文件里其实是没有必要的。所以为了节约空间，在生成目标文件的时候，就把没有初始值（实际就是0）的数据段里的变量都放到BSS段里，这样目标文件就不需要那么大的体积里（节约磁盘空间）。只有当目标文件被载入的时候，加载器负责把BSS段清零（一个循环就可以搞定）。  &lt;/p&gt;
&lt;p&gt;之后，这个规则慢慢的成为一个标准配置，大多数编译器也就都支持了BSS段。&lt;/p&gt;
&lt;p&gt;Q:如果BSS不清零可不可以？  &lt;/p&gt;
&lt;p&gt;A:可以，如果编译器规定BSS段不清零，也是可以的，但这样的话C语言语法就要改了：未初始化的全局变量和静态局部变量，其值是未知的。甚至其它语言也要跟着改语法。  &lt;/p&gt;
&lt;p&gt;所以，BSS段清零的原因是因为这个段是BSS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;插播ld过程&#34;&gt;插播ld过程：&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86/08%20%20ELF%e5%92%8c%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e7%a8%8b%e5%ba%8f%e6%97%a0%e6%b3%95%e5%90%8c%e6%97%b6%e5%9c%a8Linux%e5%92%8cWindows%e4%b8%8b%e8%bf%90%e8%a1%8c%ef%bc%9f.md&#34;  title=&#34;http://learn.lianglianglee.com/专栏/深入浅出计算机组成原理/08  ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？.md&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://learn.lianglianglee.com/专栏/深入浅出计算机组成原理/08  ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 153; 
			flex-basis: 367px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_11S_HDcVAv.png&#34; data-size=&#34;3106x2026&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_11S_HDcVAv.png&#34;
			width=&#34;3106&#34;
			height=&#34;2026&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_11S_HDcVAv_hu31d239c5dffcdef5029307f3d14e9829_1131615_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_11S_HDcVAv_hu31d239c5dffcdef5029307f3d14e9829_1131615_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;自己的补充c语言的标准对于未初始化的数据是ub还是0&#34;&gt;自己的补充：C语言的标准对于未初始化的数据是UB还是0&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value&#34;  title=&#34;https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/image/N_U5X%5c%28VF@QS8%7b7Q8V-ARE5Q_iWbJj-ywv2.png&#34; &gt;
		&lt;img src=&#34;https://sanbuphy.github.io/image/N_U5X%5c%28VF@QS8%7b7Q8V-ARE5Q_iWbJj-ywv2.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/image/BQ%5c[%7d%6054A3D%5c~UU%605%7bI50H-%5c$9_slHPMz0vDW.png&#34; &gt;
		&lt;img src=&#34;https://sanbuphy.github.io/image/BQ%5c[%7d%6054A3D%5c~UU%605%7bI50H-%5c$9_slHPMz0vDW.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;自己的补充why-are-global-and-static-variables-initialized-to-their-default-values&#34;&gt;自己的补充：Why are global and static variables initialized to their default values&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/2091499/why-are-global-and-static-variables-initialized-to-their-default-values/2091505#2091505&#34;  title=&#34;https://stackoverflow.com/questions/2091499/why-are-global-and-static-variables-initialized-to-their-default-values/2091505#2091505&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/2091499/why-are-global-and-static-variables-initialized-to-their-default-values/2091505#2091505&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Security&lt;/strong&gt;&lt;/em&gt;: leaving memory alone would leak information from other processes or the kernel.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Efficiency&lt;/strong&gt;&lt;/em&gt;: the values are useless until initialized to something, and it&amp;rsquo;s more efficient to zero them in a block with unrolled loops. The OS can even zero freelist pages when the system is otherwise idle, rather than when some client or user is waiting for the program to start.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Reproducibility&lt;/strong&gt;&lt;/em&gt;: leaving the values alone would make program behavior non-repeatable, making bugs really hard to find.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Elegance&lt;/strong&gt;&lt;/em&gt;: it&amp;rsquo;s cleaner if programs can start from 0 without having to clutter the code with default initializers.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One might then wonder why the &lt;code&gt;auto&lt;/code&gt; storage class &lt;em&gt;does&lt;/em&gt; start as garbage. The answer is two-fold:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;It doesn&amp;rsquo;t,&lt;/strong&gt; in a sense. The very first stack frame page at each level (i.e., every new page added to the stack) does receive zero values. The &amp;ldquo;garbage&amp;rdquo;, or &amp;ldquo;uninitialized&amp;rdquo; values that subsequent function instances at the same stack level see are really the previous values left by other method instances of your own program and its library.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There might be a quadratic (or whatever) &lt;strong&gt;runtime performance penalty&lt;/strong&gt; associated with initializing &lt;code&gt;auto&lt;/code&gt; (function locals) to anything. A function might not use any or all of a large array, say, on any given call, and it could be invoked thousands or millions of times. The initialization of statics and globals, OTOH, only needs to happen once.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当操作系统将控制权交给它的时候, 计算机把它解释成指令并逐条执行. loader让计算机的生命周期突破程序的边界: 一个程序结束并不意味着计算机停止工作, 计算机将终其一生履行执行程序的使命.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;实现loader&#34;&gt;实现loader&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;你需要在Nanos-lite中实现loader的功能, 来把用户程序加载到正确的内存位置, 然后执行用户程序. &lt;code&gt;loader()&lt;/code&gt;函数在&lt;code&gt;nanos-lite/src/loader.c&lt;/code&gt;中定义, 其中的&lt;code&gt;pcb&lt;/code&gt;参数目前暂不使用, 可以忽略, 而因为ramdisk中目前只有一个文件, &lt;code&gt;filename&lt;/code&gt;参数也可以忽略. 在下一个阶段实现文件系统之后, &lt;code&gt;filename&lt;/code&gt;就派上用场了.&lt;/p&gt;
&lt;p&gt;实现后, 在&lt;code&gt;init_proc()&lt;/code&gt;中调用&lt;code&gt;naive_uload(NULL, NULL)&lt;/code&gt;, 它会调用你实现的loader来加载第一个用户程序, 然后跳转到用户程序中执行. 如果你的实现正确, 你会看到执行&lt;code&gt;dummy&lt;/code&gt;程序时在Nanos-lite中触发了一个未处理的4号事件. 这说明loader已经成功加载dummy, 并且成功地跳转到dummy中执行了. 关于未处理的事件, 我们会在下文进行说明.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我犯傻了一下。。。实际上读取的都是整数类型，我在那一直打印字符串数据格式就说一直怎么不对- -。。。习惯了char * arr[]直接打印arr而不习惯普通int arr[]需要取数值了233333&amp;hellip;&lt;/p&gt;
&lt;p&gt;直接调用函数可以打印出魔数&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/image/4Q%5c%29]5XFRXIIKBD186XDEI8G_aplRYGibwG.png&#34; &gt;
		&lt;img src=&#34;https://sanbuphy.github.io/image/4Q%5c%29]5XFRXIIKBD186XDEI8G_aplRYGibwG.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;和我们dump出来的结果是一致的：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/image/CQ%5c%28DCNMO_B6WF]8H%7d@%5c%29OPB2_Zd7NRHA0bl.png&#34; &gt;
		&lt;img src=&#34;https://sanbuphy.github.io/image/CQ%5c%28DCNMO_B6WF]8H%7d@%5c%29OPB2_Zd7NRHA0bl.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;把用户程序加载到正确的内存位置,这意味着我们要获取程序开始地址以及程序头表（段头表），具体是什么需要自己RTFM，看了袁妈的视频就会觉得这并不难。&lt;/p&gt;
&lt;p&gt;返回开始地址和读取elf头很简单，段头的处理有一点点操作，主要是注意我们只需要读取LOAD相关段，需要做一个拦截（最好有个数组），然后根据讲义说的：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 323; 
			flex-basis: 776px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TDNCsr74_4.png&#34; data-size=&#34;877x271&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TDNCsr74_4.png&#34;
			width=&#34;877&#34;
			height=&#34;271&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TDNCsr74_4_hu975045d4be4bf4662c607e9d489c985a_70644_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_TDNCsr74_4_hu975045d4be4bf4662c607e9d489c985a_70644_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后注意一下我们要写入到virtaddr的位置要用指针（也就是这个地址本身指针）&lt;/p&gt;
&lt;p&gt;此时发现进入死循环（别紧张，其实是对的。。。。可以接下去看讲义，我们发现调用了两次ecall。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 194; 
			flex-basis: 465px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tkqeRmL18j.png&#34; data-size=&#34;916x472&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tkqeRmL18j.png&#34;
			width=&#34;916&#34;
			height=&#34;472&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tkqeRmL18j_hu804333b32914439ffdea1993f9f90864_96784_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_tkqeRmL18j_hu804333b32914439ffdea1993f9f90864_96784_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;diff大坑的解说memcpy&#34;&gt;DIFF大坑的解说【memcpy】&lt;/h3&gt;
&lt;p&gt;(本问题有不少群友都遇到了，提出解决方法的是pony哥）&lt;/p&gt;
&lt;p&gt;在loader实现阶段，你可能会用diff遇到pc漂移diff出错很离谱的神奇状况，甚至在之后也会遇到（但仍然有结果不会陷入奇怪的循环等等）也许你需要考虑这个问题：&lt;/p&gt;
&lt;h3 id=&#34;操作系统的运行时环境&#34;&gt;操作系统的运行时环境&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt; 程序的运行需要运行时环境的支撑. 而操作系统希望加载并运行程序, 自然有责任来提供运行时环境的功能.&lt;/p&gt;
&lt;p&gt;需要有一个角色来对系统中的资源进行统一的管理: 程序不能擅自使用资源了, 使用的时候需要向资源管理者提出申请. 既然操作系统位于高特权级, 享受着至高无上的权利, 自然地它也需要履行相应的义务: 作为资源管理者管理着系统中的所有资源, 操作系统还需要为用户程序提供相应的服务. 这些服务需要以一种统一的接口来呈现, 用户程序也只能通过这一接口来请求服务.&lt;/p&gt;
&lt;p&gt;这一接口就是系统调用. 这是操作系统从诞生那一刻就被赋予的使命: &lt;/p&gt;
&lt;p&gt;我们之前提到GM-NAA I/O的一个主要任务就是加载新程序, 而它的另一个主要功能, 就是为程序提供输入输出的公共接口. GM-NAA I/O所提供的公共接口, 可以认为是系统调用的初原形态.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;问系统调用的必要性&#34;&gt;问：系统调用的必要性&lt;/h4&gt;
&lt;p&gt;对于批处理系统来说, 系统调用是必须的吗? 如果直接把AM的API暴露给批处理系统中的程序, 会不会有问题呢?&lt;/p&gt;
&lt;p&gt;答：可能会有各种奇怪的并发资源竞争问题，而且会被恶意程序利用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统调用把整个运行时环境分成两部分, 一部分是操作系统内核区, 另一部分是用户区. 那些会访问系统资源的功能会放到内核区中实现, 而用户区则保留一些无需使用系统资源的功能(比如strcpy()), 以及用于请求系统资源相关服务的系统调用接口.&lt;/p&gt;
&lt;p&gt;在这个模型之下, 用户程序只能在用户区安分守己地&amp;quot;计算&amp;quot;, 任何超越纯粹计算能力之外的任务, 都需要通过系统调用向操作系统请求服务. 如果用户程序尝试进行任何非法操作, CPU就会向操作系统抛出一个异常信号, 让非法操作的指令执行&amp;quot;失败&amp;quot;, 并交由操作系统进行处理. 对, 这就是之前介绍的硬件保护机制, 操作系统需要借助这一天然屏障来阻挡程序的恶意行为.&lt;/p&gt;
&lt;p&gt;虽然操作系统需要为用户程序服务, 但这并不意味着操作系统需要把所有信息都暴露给用户程序. 有些信息是用户进程没有必要知道的, 也永远不应该知道, 例如一些与内存管理相关的数据结构. 如果一个恶意程序获得了这些信息, 可能会为恶意攻击提供了信息基础. 因此, 通常不存在一个系统调用来获取这些操作系统的私有数据.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 130; 
			flex-basis: 313px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X4u4Mt9KJd.png&#34; data-size=&#34;893x683&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X4u4Mt9KJd.png&#34;
			width=&#34;893&#34;
			height=&#34;683&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X4u4Mt9KJd_hud017a677d2e77736734c46dda9142da6_163027_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_X4u4Mt9KJd_hud017a677d2e77736734c46dda9142da6_163027_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统调用的过程：用户程序通过一种方法描述自己的需求, 然后告诉操作系统。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;告诉操作系统&amp;rdquo;, 这是通过自陷指令来实现的。&lt;/p&gt;
&lt;p&gt;在GNU/Linux中, 用户程序通过自陷指令来触发系统调用, Nanos-lite也沿用这个约定. CTE中的&lt;code&gt;yield()&lt;/code&gt;也是通过自陷指令来实现,&lt;/p&gt;
&lt;p&gt;对用户程序来说, 用来向操作系统描述需求的最方便手段就是使用通用寄存器了, 因为执行自陷指令之后, 执行流就会马上切换到事先设置好的入口, 通用寄存器也会作为上下文的一部分被保存起来. 系&lt;strong&gt;统调用处理函数只需要从上下文中获取必要的信息, 就能知道用户程序发出的服务请求是什么了.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前&lt;code&gt;dummy&lt;/code&gt;已经通过&lt;code&gt;_syscall_()&lt;/code&gt;直接触发系统调用, 你需要让Nanos-lite识别出系统调用事件&lt;code&gt;EVENT_SYSCALL&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;abstract-machine/am/include/arch/$ISA-nemu.h&lt;/code&gt;中实现正确的&lt;code&gt;GPR?&lt;/code&gt;宏, 让它们从上下文&lt;code&gt;c&lt;/code&gt;中获得正确的系统调用参数寄存器.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加&lt;code&gt;SYS_yield&lt;/code&gt;系统调用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置系统调用的返回值.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;处理系统调用的最后一件事就是设置系统调用的返回值. 对于不同的ISA, 系统调用的返回值存放在不同的寄存器中, 宏&lt;code&gt;GPRx&lt;/code&gt;用于实现这一抽象, 所以我们通过&lt;code&gt;GPRx&lt;/code&gt;来进行设置系统调用返回值即可.&lt;/p&gt;
&lt;p&gt;经过CTE, 执行流会从&lt;code&gt;do_syscall()&lt;/code&gt;一路返回到用户程序的&lt;code&gt;_syscall_()&lt;/code&gt;函数中. 代码最后会从相应寄存器中取出系统调用的返回值, 并返回给&lt;code&gt;_syscall_()&lt;/code&gt;的调用者,&lt;/p&gt;
&lt;p&gt;重新运行dummy程序, 如果你的实现正确, 你会看到dummy程序又触发了一个号码为&lt;code&gt;0&lt;/code&gt;的系统调用. 查看&lt;code&gt;nanos-lite/src/syscall.h&lt;/code&gt;, 你会发现它是一个&lt;code&gt;SYS_exit&lt;/code&gt;系统调用. 这说明之前的&lt;code&gt;SYS_yield&lt;/code&gt;已经成功返回, 触发&lt;code&gt;SYS_exit&lt;/code&gt;是因为dummy已经执行完毕, 准备退出了.&lt;/p&gt;
&lt;p&gt;你需要实现&lt;code&gt;SYS_exit&lt;/code&gt;系统调用, 它会接收一个退出状态的参数. 为了方便测试, 我们目前先直接使用这个参数调用&lt;code&gt;halt()&lt;/code&gt;. 实现成功后, 再次运行dummy程序, 你会看到&lt;code&gt;HIT GOOD TRAP&lt;/code&gt;的信息.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;【你需要阅读上面提到的所有函数，这样就能完成所需内容。】&lt;/p&gt;
&lt;h4 id=&#34;问risc-v系统调用号的传递&#34;&gt;问：RISC-V系统调用号的传递&lt;/h4&gt;
&lt;p&gt;如果你选择的是RISC-V, 你会发现它并不是通过&lt;code&gt;a0&lt;/code&gt;来传递系统调用号. 事实上, 我们参考了RISC-V Linux的系统调用参数传递的约定: 即在RISC-V Linux上也是通过这个寄存器来传递系统调用号的. 你觉得RISC-V Linux为什么没有使用&lt;code&gt;a0&lt;/code&gt;来传递系统调用号呢?&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;经过一顿操作猛如虎补充好了对应内容。（认真看讲义即可）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 145; 
			flex-basis: 348px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_PpJHgLc8AC.png&#34; data-size=&#34;921x635&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_PpJHgLc8AC.png&#34;
			width=&#34;921&#34;
			height=&#34;635&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_PpJHgLc8AC_hu2ebc1caaf177a0e9d92ef0813323e040_126788_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_PpJHgLc8AC_hu2ebc1caaf177a0e9d92ef0813323e040_126788_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;操作系统之上的trm&#34;&gt;操作系统之上的TRM&lt;/h3&gt;
&lt;p&gt;我们需要构造os的运行时环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户程序还可以做什么呢? 最基本的,  为了满足程序的基本计算能力, 需要有这些条件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;机器提供基本的运算指令  （机器提供了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能输出字符 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有堆区可以动态申请内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以结束运行 （sys_exit）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 为了向用户程序提供输出字符和内存动态申请的功能, 我们需要实现更多的系统调用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;write实现&#34;&gt;write实现&lt;/h4&gt;
&lt;p&gt;简单实现一下write： 发现打印不全&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 141; 
			flex-basis: 338px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image__nY7sYc5IA.png&#34; data-size=&#34;833x590&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image__nY7sYc5IA.png&#34;
			width=&#34;833&#34;
			height=&#34;590&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image__nY7sYc5IA_hu3b5d16cc8f54c8456186c3bde4f8a56d_151225_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image__nY7sYc5IA_hu3b5d16cc8f54c8456186c3bde4f8a56d_151225_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实这是后面提到的：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 403; 
			flex-basis: 968px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-4dIQXf6Nb.png&#34; data-size=&#34;973x241&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-4dIQXf6Nb.png&#34;
			width=&#34;973&#34;
			height=&#34;241&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-4dIQXf6Nb_hu0d567b71e1686c910261f513f493ffc1_79548_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_-4dIQXf6Nb_hu0d567b71e1686c910261f513f493ffc1_79548_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;堆区管理&#34;&gt;堆区管理&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;调整堆区大小是通过&lt;code&gt;sbrk()&lt;/code&gt;库函数来实现的,用于将用户程序的program break增长&lt;strong&gt;increment&lt;/strong&gt;字节, 其中&lt;code&gt;increment&lt;/code&gt;可为负数.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;malloc()&lt;/code&gt;被第一次调用的时候, 会通过&lt;code&gt;sbrk(0)&lt;/code&gt;来查询用户程序当前program break的位置, 之后就可以通过后续的&lt;code&gt;sbrk()&lt;/code&gt;调用来动态调整用户程序program break的位置了&lt;/p&gt;
&lt;p&gt;在Navy的Newlib中, &lt;code&gt;sbrk()&lt;/code&gt;最终会调用&lt;code&gt;_sbrk()&lt;/code&gt;, 它在&lt;code&gt;navy-apps/libs/libos/src/syscall.c&lt;/code&gt;中定义. 框架代码让&lt;code&gt;_sbrk()&lt;/code&gt;总是返回&lt;code&gt;-1&lt;/code&gt;, 表示堆区调整失败, &lt;/p&gt;
&lt;p&gt;事实上,** 用户程序在第一次调用**&lt;code&gt;printf()&lt;/code&gt;的时候会尝试通过&lt;code&gt;malloc()&lt;/code&gt;&lt;strong&gt;申请一片缓冲区, 来存放格式化的内容.&lt;/strong&gt; &lt;strong&gt;若申请失败, 就会逐个字符进行输出&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;我们还需要提供一个用于设置堆区大小的系统调用. 在GNU/Linux中, 这个系统调用是&lt;code&gt;SYS_brk&lt;/code&gt;, 它接收一个参数&lt;code&gt;addr&lt;/code&gt;, 用于&lt;strong&gt;指示新的program break的位置&lt;/strong&gt;. &lt;code&gt;_sbrk()&lt;/code&gt;通过记录的方式来对用户程序的program break位置进行管理, 其工作方式如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;program break一开始的位置位于&lt;code&gt;_end&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被调用时, 根据记录的&lt;strong&gt;program break位置&lt;/strong&gt;和参数&lt;code&gt;increment&lt;/code&gt;, 计算出新program break&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;SYS_brk&lt;/code&gt;系统调用来让操作系统设置新program break&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若&lt;code&gt;SYS_brk&lt;/code&gt;系统调用成功, 该系统调用会返回&lt;code&gt;0&lt;/code&gt;, 此时更新之前记录的program break的位置, 并将旧program break的位置作为&lt;code&gt;_sbrk()&lt;/code&gt;的返回值返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若该系统调用失败, &lt;code&gt;_sbrk()&lt;/code&gt;会返回&lt;code&gt;-1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述代码是在用户层的库函数中实现的, 我们还需要在Nanos-lite中实现&lt;code&gt;SYS_brk&lt;/code&gt;的功能. 由于目前Nanos-lite还是一个单任务操作系统, 空闲的内存都可以让用户程序自由使用, 因此我们只需要让&lt;code&gt;SYS_brk&lt;/code&gt;系统调用总是返回&lt;code&gt;0&lt;/code&gt;即可, 表示堆区大小的调整总是成功. 在PA4中, 我们会对这一系统调用进行修改, 实现真正的内存分配.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据上述内容在Nanos-lite中实现&lt;code&gt;SYS_brk&lt;/code&gt;系统调用, 然后在用户层实现&lt;code&gt;_sbrk()&lt;/code&gt;. 你可以通过&lt;code&gt;man 2 sbrk&lt;/code&gt;来查阅libc中&lt;code&gt;brk()&lt;/code&gt;和&lt;code&gt;sbrk()&lt;/code&gt;的行为, 另外通过&lt;code&gt;man 3 end&lt;/code&gt;来查阅如何使用&lt;code&gt;_end&lt;/code&gt;符号.&lt;/p&gt;
&lt;p&gt;需要注意的是, 调试的时候不要在&lt;code&gt;_sbrk()&lt;/code&gt;中通过&lt;code&gt;printf()&lt;/code&gt;进行输出, 这是因为&lt;code&gt;printf()&lt;/code&gt;还是会尝试通过&lt;code&gt;malloc()&lt;/code&gt;来申请缓冲区, 最终会再次调用&lt;code&gt;_sbrk()&lt;/code&gt;, 造成死递归. 你可以通过&lt;code&gt;sprintf()&lt;/code&gt;先把调试信息输出到一个字符串缓冲区中, 然后通过&lt;code&gt;_write()&lt;/code&gt;进行输出.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里按照一步步操作就好，其实就是pa2的malloc的稍微改写。至于end怎么拿看man就懂了。&lt;/p&gt;
&lt;p&gt;（这里其实有个坑，要注意堆分配的作用域。不然多次堆分配就没有意义了）&lt;/p&gt;
&lt;p&gt;这里其实我不太理解一个问题，那就是“malloc的系统调用失败”，怎么算失败呢？访问到不可访问的内存应该会直接panic，或者出界也会直接panic。也许应该有机制会在pa自己panic的情况前拦截（比如再次提前检查地址是否出界）&lt;/p&gt;
&lt;p&gt;然后我发现了一个乱码问题（检查了很多次应该不是堆的问题）&lt;/p&gt;
&lt;p&gt;后面突然想到是不是缓冲区的问题（没有遇到\n就暂停），修改了write逻辑后恢复正常：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 126; 
			flex-basis: 302px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Yn6Ma-eb3b.png&#34; data-size=&#34;803x637&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Yn6Ma-eb3b.png&#34;
			width=&#34;803&#34;
			height=&#34;637&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Yn6Ma-eb3b_hu48afed5a30e2a1900b729b5b640e0caa_156351_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Yn6Ma-eb3b_hu48afed5a30e2a1900b729b5b640e0caa_156351_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果通过系统调用千辛万苦地陷入操作系统只是为了输出区区一个字符, 那就太不划算了. 于是有了批处理(batching)的技术: 将一些简单的任务累积起来, 然后再一次性进行处理. 缓冲区是批处理技术的核心, libc中的&lt;code&gt;fread()&lt;/code&gt;和&lt;code&gt;fwrite()&lt;/code&gt;正是通过缓冲区来将数据累积起来, 然后再通过一次系统调用进行处理. 例如通过一个1024字节的缓冲区, 就可以通过一次系统调用直接输出1024个字符, 而不需要通过1024次系统调用来逐个字符地输出. 显然, 后者的开销比前者大得多.&lt;/p&gt;
&lt;p&gt;有兴趣的同学可以在GNU/Linux上编写相应的程序, 来粗略测试一下一次&lt;code&gt;write()&lt;/code&gt;系统调用的开销, 然后和&lt;a class=&#34;link&#34; href=&#34;http://arkanis.de/weblog/2017-01-05-measurements-of-system-call-performance-and-overhead&#34;  title=&#34;这篇文章&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这篇文章&lt;/a&gt;对比一下&lt;/p&gt;
&lt;p&gt; &lt;code&gt;printf()&lt;/code&gt;打印的字符不一定会马上通过&lt;code&gt;write()&lt;/code&gt;系统调用输出, 但遇到&lt;code&gt;\n&lt;/code&gt;时可以强行将缓冲区中的内容进行输出. 有兴趣的同学可以阅读&lt;code&gt;navy-apps/libs/libc/src/stdio/wbuf.c&lt;/code&gt;, 这个文件实现了缓冲区的功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;必答题---hello程序是什么-它从而何来-要到哪里去&#34;&gt;必答题 - hello程序是什么, 它从而何来, 要到哪里去&lt;/h4&gt;
&lt;p&gt;到此为止, PA中的所有组件已经全部亮相, 整个计算机系统也开始趋于完整. 你也已经在这个自己创造的计算机系统上跑起了hello这个第一个还说得过去的用户程序 (dummy是给大家热身用的, 不算), 好消息是, 我们已经距离运行仙剑奇侠传不远了(下一个阶段就是啦).&lt;/p&gt;
&lt;p&gt;不过按照PA的传统, 光是跑起来还是不够的, 你还要明白它究竟怎么跑起来才行. 于是来回答这道必答题吧:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们知道&lt;code&gt;navy-apps/tests/hello/hello.c&lt;/code&gt;只是一个C源文件, 它会被编译链接成一个ELF文件. 那么, &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello程序一开始在哪里?&lt;/p&gt;
&lt;p&gt;它是怎么出现内存中的? &lt;/p&gt;
&lt;p&gt;为什么会出现在目前的内存位置? &lt;/p&gt;
&lt;p&gt;它的第一条指令在哪里? &lt;/p&gt;
&lt;p&gt;究竟是怎么执行到它的第一条指令的?&lt;/p&gt;
&lt;p&gt; hello程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>python进阶 有关元类的派生</title>
        <link>https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/</link>
        <pubDate>Sat, 13 Aug 2022 09:03:03 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/</guid>
        <description>&lt;p&gt;一天看到有个群友问了这样一个问题：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 136; 
			flex-basis: 327px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_UAZmrxVbps.png&#34; data-size=&#34;773x566&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_UAZmrxVbps.png&#34;
			width=&#34;773&#34;
			height=&#34;566&#34;
			srcset=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_UAZmrxVbps_hu3dc5fa3e6c74c73060025a8ce8e4b527_66222_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_UAZmrxVbps_hu3dc5fa3e6c74c73060025a8ce8e4b527_66222_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么这个类没有看到继承于谁，但是在里面可以直接super？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个栏目中我们先不谈有关__setattr__魔术方法的具体作用（其实就是反射）和应用场景，就单纯谈为什么在这里可以凭空super。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__setattr__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;setting attribute [&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;] to &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;fm&#34;&gt;__setattr__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看似没有集成任何类，为什么在这里我们直接可以super呢？其实相当于重写了Person类的父类的__setattr__方法，person类的父类是什么呢？这里我们需要了解元类的概念：（转载自b站阿岳同学）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 187; 
			flex-basis: 449px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_PwtziD3Kfj.png&#34; data-size=&#34;700x374&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_PwtziD3Kfj.png&#34;
			width=&#34;700&#34;
			height=&#34;374&#34;
			srcset=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_PwtziD3Kfj_huf37cc2ef6526d5c9f49021d269da9ff0_278808_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_PwtziD3Kfj_huf37cc2ef6526d5c9f49021d269da9ff0_278808_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;实际上我们创建的类person本身就是object的派生类，所以当我们在person里直接super的时候，事实上使用的是object的魔术方法。&lt;/p&gt;
&lt;p&gt;我们可以做个实验：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 137; 
			flex-basis: 329px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_Nl-pOigBwe.png&#34; data-size=&#34;744x542&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_Nl-pOigBwe.png&#34;
			width=&#34;744&#34;
			height=&#34;542&#34;
			srcset=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_Nl-pOigBwe_hu31ed83e77021dfc953400e60a3642862_44413_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_Nl-pOigBwe_hu31ed83e77021dfc953400e60a3642862_44413_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用__base__查看父类能够看到class&amp;rsquo;object&#39;，那么到底他是个什么呢？&lt;/p&gt;
&lt;p&gt;在builtins.pyi中我们能一探究竟：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 119; 
			flex-basis: 286px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_99vZwIU0Og.png&#34; data-size=&#34;961x806&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_99vZwIU0Og.png&#34;
			width=&#34;961&#34;
			height=&#34;806&#34;
			srcset=&#34;https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_99vZwIU0Og_hu4a0f1aaa5fb44b68efe333f82d3769d4_180549_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/python%E8%BF%9B%E9%98%B6-%E6%9C%89%E5%85%B3%E5%85%83%E7%B1%BB%E7%9A%84%E6%B4%BE%E7%94%9F/image/image_99vZwIU0Og_hu4a0f1aaa5fb44b68efe333f82d3769d4_180549_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所以一切都很显然了，我们能够直接super原因是我们创造的class本身也是一种派生。&lt;/p&gt;
&lt;p&gt;“一生二，二生三，三生万物“ —— 如果老子是个程序员，应该很喜欢python&lt;/p&gt;
</description>
        </item>
        <item>
        <title>NJU计算机课程基础实验 PA2笔记（二）</title>
        <link>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
        <pubDate>Sat, 13 Aug 2022 08:50:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
        <description>&lt;h2 id=&#34;基础设施2还未全完成&#34;&gt;基础设施(2)（还未全完成&lt;/h2&gt;
&lt;p&gt;trace系列暂时待填坑。。。。&lt;/p&gt;
&lt;p&gt;NEMU是一个用来执行其它程序的程序. 在可计算理论中, 这种程序有一个专门的名词, 叫通用程序(Universal Program),&lt;/p&gt;
&lt;p&gt;NEMU和各种模拟器只不过是通用程序的实例化, 我们也可以毫不夸张地说, 计算机就是一个通用程序的实体化. 通用程序的存在性为计算机的出现奠定了理论基础, 是可计算理论中一个极其重要的结论,&lt;/p&gt;
&lt;p&gt;memset通过测试&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 251; 
			flex-basis: 602px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_fPHJw8irIL.png&#34; data-size=&#34;1025x408&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_fPHJw8irIL.png&#34;
			width=&#34;1025&#34;
			height=&#34;408&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_fPHJw8irIL_huec358530ccf3651fbceb2e310353de56_79393_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_fPHJw8irIL_huec358530ccf3651fbceb2e310353de56_79393_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;推荐阅读-计算的极限&#34;&gt;推荐阅读 计算的极限：&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/270155475&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/270155475&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;阅读相关makefile-尝试理解abstract-machine是如何生成native的可执行文件的&#34;&gt;阅读相关Makefile, 尝试理解abstract-machine是如何生成native的可执行文件的.&lt;/h3&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;h3 id=&#34;奇怪的错误码&#34;&gt;奇怪的错误码&lt;/h3&gt;
&lt;p&gt;为什么错误码是&lt;code&gt;1&lt;/code&gt;呢? 你知道&lt;code&gt;make&lt;/code&gt;程序是如何得到这个错误码的吗?&lt;/p&gt;
&lt;p&gt;别高兴太早了, 框架代码编译到&lt;code&gt;native&lt;/code&gt;的时候默认链接到glibc, 我们需要把这些库函数的调用链接到我们编写的klib来进行测试. 我们可以通过在&lt;code&gt;abstract-machine/klib/include/klib.h&lt;/code&gt; 中通过定义宏&lt;code&gt;__NATIVE_USE_KLIB__&lt;/code&gt;来把库函数链接到klib. 如果不定义这个宏, 库函数将会链接到glibc, 可以作为正确的参考实现来进行对比.&lt;/p&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;h3 id=&#34;这是如何实现的&#34;&gt;这是如何实现的?&lt;/h3&gt;
&lt;p&gt;为什么定义宏&lt;code&gt;__NATIVE_USE_KLIB__&lt;/code&gt;之后就可以把&lt;code&gt;native&lt;/code&gt;上的这些库函数链接到klib? 这具体是如何发生的? 尝试根据你在课堂上学习的链接相关的知识解释这一现象.&lt;/p&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;h2 id=&#34;输入输出&#34;&gt;输入输出&lt;/h2&gt;
&lt;h3 id=&#34;设备与cpu&#34;&gt;设备与CPU&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;要向设备发送一些有意义的数字信号, 设备就会按照这些信号的含义来工作. 让一些信号来指导设备如何工作, 这不就像&amp;quot;程序的指令指导CPU如何工作&amp;quot;一样吗? &lt;strong&gt;恰恰就是这样!&lt;/strong&gt; 设备也有自己的状态寄存器(相当于CPU的寄存器), 也有自己的功能部件(相当于CPU的运算器). 当然不同的设备有不同的功能部件, 例如&lt;strong&gt;键盘有一个把按键的模拟信号转换成扫描码的部件, 而VGA则有一个把像素颜色信息转换成显示器模拟信号的部件. 控制设备工作的信号称为&amp;quot;命令字&amp;quot;, 可以理解成&lt;/strong&gt;【设备的指令】, 设备的工作就是负责接收命令字, 并进行译码和执行&amp;hellip; 你已经知道CPU的工作方式, 这一切对你来说都太熟悉了.&lt;/p&gt;
&lt;p&gt;所谓的访问设备, 说白了就是从设备获取数据(输入), 比如从键盘控制器获取按键扫描码, 或者是向设备发送数据(输出), 比如向显存写入图像的颜色信息. 但是, 如果万一用户没有敲键盘, 或者是用户想调整屏幕的分辨率, 怎么办呢? 这说明, 除&lt;strong&gt;了纯粹的数据读写之外, 我们还需要对设备进行控制&lt;/strong&gt;: 比如需要&lt;strong&gt;获取键盘控制器的状态&lt;/strong&gt;, 查看当前是否有按键被按下; 或者是需要有方式可以&lt;strong&gt;查询或设置VGA控制器的分辨率&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;所以, 在程序看来,访问设备 = 读出数据 + 写入数据 + 控制状态.&lt;/p&gt;
&lt;p&gt;既然设备也有寄存器, 一种最简单的方法就是把设备的寄存器作为接口, 让CPU来访问这些寄存器. &lt;/p&gt;
&lt;p&gt;CPU要如何访问设备寄存器呢? 我们先来回顾一下CPU是如何访问CPU自己的寄存器的: 首先给这些寄存器编个号, 比如&lt;code&gt;eax&lt;/code&gt;是&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;ecx&lt;/code&gt;是&lt;code&gt;1&lt;/code&gt;&amp;hellip; 然后在指令中引用这些编号, 电路上会有相应的选择器, 来选择相应的寄存器并进行读写. 对设备寄存器的访问也是类似的: 我们也可以给设备中允许CPU访问的寄存器逐一编号, 然后通过指令来引用这些编号. 设备中可能会有一些私有寄存器, 它们是由设备自己维护的, 它们没有这样的编号, CPU不能直接访问它们.&lt;/p&gt;
&lt;p&gt;这些编号也称为设备的地址. 常用的编址方式有两种：&lt;strong&gt;端口I/O、內存映射I/O&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;端口io&#34;&gt;端口I/O&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;端口映射I/O(port-mapped I/O), CPU&lt;strong&gt;使用专门的I/O指令对设备进行访问, 并把设备的地址称作端口号&lt;/strong&gt;. &lt;strong&gt;有了端口号以后, 在I/O指令中给出端口号, 就知道要访问哪一个设备寄存器了&lt;/strong&gt;. 市场上的计算机绝大多数都是IBM PC兼容机, IBM PC兼容机对常见设备端口号的分配有&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Input/output_base_address&#34;  title=&#34;专门的规定&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;专门的规定&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;x86提供了&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;指令用于访问设备, 其中&lt;code&gt;in&lt;/code&gt;指令用于将设备寄存器中的数据传输到CPU寄存器中, &lt;code&gt;out&lt;/code&gt;指令用于将CPU寄存器中的数据传送到设备寄存器中.&lt;/p&gt;
&lt;p&gt;movl $0x41, %al&lt;/p&gt;
&lt;p&gt;movl $0x3f8, %edx&lt;/p&gt;
&lt;p&gt;outb %al, (%dx)&lt;/p&gt;
&lt;p&gt;上述代码把数据0x41传送到0x3f8号端口所对应的设备寄存器中. CPU执行上述代码后, 会将0x41这个数据传送到串口的一个寄存器中, 串口接收之后, 发现是要输出一个字符&lt;code&gt;A&lt;/code&gt;; 但对CPU来说, 它并不关心设备会怎么处理0x41这个数据, 只会老老实实地把0x41传送到0x3f8号端口. 事实上, 设备的API及其行为都会在相应的文档里面有清晰的定义, 在PA中我们无需了解这些细节, 只需要知道, 驱动开发者可以通过RTFM, 来编写相应程序来访问设备即可.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API, 行为, RTFM&amp;hellip; 没错, 我们又再次看到了计算机系统设计的一个例子: 设备向CPU暴露设备寄存器的接口, 把设备内部的复杂行为(甚至一些模拟电路的特性)进行抽象, CPU只需要使用这一接口访问设备, 就可以实现期望的功能.&lt;/strong&gt; 计算机系统处处蕴含抽象的思想, 只要理解其中的原理, 再加上RTFM的技能, 你就能掌握计算机系统的全部!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;內存映射io&#34;&gt;內存映射I/O&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;端口映射I/O把端口号作为I/O指令的一部分, 这种方法很简单, 但同时也是它最大的缺点. 指令集为了兼容已经开发的程序, 是只能添加但不能修改的.这意味着, &lt;strong&gt;端口映射I/O所能访问的I/O地址空间的大小, 在设计I/O指令的那一刻就已经决定下来了.&lt;/strong&gt; 所谓I/O地址空间, 其实就是所有能访问的设备的地址的集合. 随着设备越来越多, 功能也越来越复杂, I/O地址空间有限的端口映射I/O已经逐渐不能满足需求了. 有的设备需要让CPU访问一段较大的连续存储空间, 如VGA的显存, 24色加上Alpha通道的1024x768分辨率的显存就需要3MB的编址范围. 于是内存映射I/O(memory-mapped I/O, MMIO)应运而生.&lt;/p&gt;
&lt;p&gt;编址方式将一部分物理内存的访问&amp;quot;重定向&amp;quot;到I/O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I/O设备,&lt;/p&gt;
&lt;p&gt;现代计算机都已经是64位计算机, 物理地址线都有48根,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（注意64位并不需要2的64次方，而是48就够了，因为过大空间导致了资源浪费。32位的时候寻址是32次方。每个地址总线可以对两个存储单元寻址，确定两种状态（0或1）1GB是2的30次方Byte，1TB是2的40次方B，再乘上256即2的8次方即是）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这意味着物理地址空间有256TB这么大, 从里面划出3MB的地址空间给显存, 根本就是不痛不痒. 正因为如此, 内存映射I/O成为了现代计算机主流的I/O编址方式: RISC架构只提供内存映射I/O的编址方式, 而PCI-e, 网卡, x86的APIC等主流设备, 都支持通过内存映射I/O来访问.&lt;/p&gt;
&lt;p&gt;作为RISC架构, mips32和riscv32都是采用内存映射I/O的编址方式. 对x86来说, 内存映射I/O的一个例子是NEMU中的物理地址区间&lt;code&gt;[0xa1000000, 0xa1800000)&lt;/code&gt;. 这段物理地址区间被映射到VGA内部的显存, 读写这段物理地址区间就相当于对读写VGA显存的数据. 例如&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memset((void *)0xa1000000, 0, SCR_SIZE);&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;会将显存中一个屏幕大小的数据清零, 即往整个屏幕写入黑色像素, 作用相当于清屏. 可以看到, 内存映射I/O的编程模型和普通的编程完全一样: 程序员可以直接把I/O设备当做内存来访问. 这一特性也是深受驱动开发者的喜爱.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;状态机视角下的输入输出&#34;&gt;状态机视角下的输入输出&lt;/h3&gt;
&lt;p&gt;我们可以把设备分成两部分, &lt;strong&gt;一部分是数字电路. &lt;strong&gt;我们刚才粗略地介绍了一些设备控制器的功能, 例如我们CPU可以从键盘控制器中读出按键信息. 既然是&lt;/strong&gt;数字电路, 我们就可以把其中的时序逻辑电路看成是设备数字电路部分的状态D.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但D比较特殊, 计算机只能通过端口I/O指令或者内存映射I/O的访存指令来访问和修改&lt;/strong&gt;.​&lt;/p&gt;
&lt;p&gt;有意思的是&lt;strong&gt;设备的另一部分: 模拟电路, 它也可以改变D. 例如键盘通过检查按键位置的电容变化来判断是否有按键被按下,&lt;/strong&gt; 若有, 则会将按键信息写入到键盘控制器的寄存器中. 而按键位置的电容是否发生变化, 又是由物理世界中的用户是否按下按键决定的. 所以我们会说, 设备是连接计算机和物理世界的桥梁.&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 328; 
			flex-basis: 788px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_E-jt9oZc0s.png&#34; data-size=&#34;808x246&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_E-jt9oZc0s.png&#34;
			width=&#34;808&#34;
			height=&#34;246&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_E-jt9oZc0s_hudf24d27b895a25a274a61d710b4db62b_22892_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_E-jt9oZc0s_hudf24d27b895a25a274a61d710b4db62b_22892_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;要对设备的状态和行为进行建模是一件很困难的事情, 除了设备本身的行为五花八门之外, 设备的状态还时时刻刻受到物理世界的影响. 于是, &lt;strong&gt;我们在对状态机模型的行为进行扩展的时候, 并不考虑将D加入到S中, 而是仅仅对输入输出相关指令的行为进行建模:&lt;/strong&gt; ​&lt;/p&gt;
&lt;h4 id=&#34;通过内存进行数据交互的输入输出&#34;&gt;通过内存进行数据交互的输入输出&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;我们知道&lt;code&gt;S = &amp;lt;R, M&amp;gt;&lt;/code&gt;, 上文介绍的端口I/O和内存映射I/O都是通过寄存器&lt;code&gt;R&lt;/code&gt;来进行数据交互的. 很自然地, 我们可以考虑, &lt;strong&gt;有没有通过内存&lt;/strong&gt;​&lt;strong&gt;来进行数据交互的输入输出方式呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实是有的, 这种方式叫&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Direct_memory_access&#34;  title=&#34;DMA&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;DMA&lt;/a&gt;. 为了提高性能, 一些复杂的设备一般都会带有DMA的功能. 不过在NEMU中的设备都比较简单, 关于DMA的细节我们就不展开介绍了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;nemu中的输入输出&#34;&gt;NEMU中的输入输出&lt;/h2&gt;
&lt;p&gt;终于进入紧张刺激的正式话题！&lt;/p&gt;
&lt;p&gt;NEMU的框架代码已经在&lt;code&gt;nemu/src/device/&lt;/code&gt;目录下提供了设备相关的代码,&lt;/p&gt;
&lt;h3 id=&#34;映射和io方式&#34;&gt;映射和I/O方式&lt;/h3&gt;
&lt;p&gt;这部分蛮重要的，多读读原文把，可以在之后回头读。&lt;/p&gt;
&lt;h3 id=&#34;设备&#34;&gt;设备&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;NEMU使用SDL库来实现设备的模拟, &lt;code&gt;nemu/src/device/device.c&lt;/code&gt;含有和SDL库相关的代码. &lt;code&gt;init_device()&lt;/code&gt;函数主要进行以下工作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;init_map()&lt;/code&gt;进行初始化.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;code&gt;cpu_exec()&lt;/code&gt;在执行每条指令之后就会调用&lt;code&gt;device_update()&lt;/code&gt;函数, &lt;strong&gt;这个函数首先会检查距离上次设备更新是否已经超过一定时间, 若是, 则会尝试刷新屏幕, 并进一步检查是否有按键按下/释放, 以及是否点击了窗口的&lt;/strong&gt;​&lt;strong&gt;按钮; 否则则直接返回, 避免检查过于频繁, 因为上述事件发生的频率是很低的.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;将输入输出抽象成ioe&#34;&gt;将输入输出抽象成IOE&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;设备访问的具体实现是架构相关的, 比如NEMU的VGA显存位于物理地址区间[0xa1000000, 0xa1080000), 但对native的程序来说, 这是一个不可访问的非法区间, 因此&lt;strong&gt;native程序需要通过别的方式来实现类似的功能. 自然地, 设备访问这一架构相关的功能, 应该归入AM中&lt;/strong&gt;. 与TRM不同, &lt;strong&gt;设备访问是为计算机提供输入输出的功能, 因此我们把它们划入一类新的API, 名字叫IOE(I/O Extension).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问设备其实想做什么: 访问设备 = 读出数据 + 写入数据 + 控制状态. &lt;strong&gt;进一步的, 控制状态本质上也是读/写设备寄存器的操作, 所以访问设备 = 读/写操作.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bool ioe_init();&lt;/p&gt;
&lt;p&gt;void ioe_read(int reg, void *buf);&lt;/p&gt;
&lt;p&gt;void ioe_write(int reg, void *buf);&lt;/p&gt;
&lt;p&gt;第一个API用于进行IOE相关的初始化操作. 后两个API分别用于从编号为&lt;code&gt;reg&lt;/code&gt;的寄存器中读出内容到缓冲区&lt;code&gt;buf&lt;/code&gt;中, 以及往编号为&lt;code&gt;reg&lt;/code&gt;寄存器中写入缓冲区&lt;code&gt;buf&lt;/code&gt;中的内容.&lt;/p&gt;
&lt;p&gt;【这里的&lt;code&gt;reg&lt;/code&gt;寄存器并不是上文讨论的设备寄存器, 因为设备寄存器的编号是架构相关的.】&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/am/include/amdev.h&lt;/code&gt;中定义了常见设备的&amp;quot;抽象寄存器&amp;quot;编号和相应的结构. 这些定义是架构无关的, 每个架构在实现各自的IOE API时, 都需要遵循这些定义(约定). &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NEMU作为一个平台, 设备的行为是与ISA无关的&lt;/strong&gt;, 只需要在&lt;code&gt;abstract-machine/am/src/platform/nemu/ioe/&lt;/code&gt;目录下&lt;strong&gt;实现一份IOE, 来供NEMU平台的架构共享&lt;/strong&gt;. 其中, &lt;code&gt;abstract-machine/am/src/platform/nemu/ioe/ioe.c&lt;/code&gt;中实现了上述的三个IOE API, &lt;code&gt;ioe_read()&lt;/code&gt;和&lt;code&gt;ioe_write()&lt;/code&gt;都是&lt;strong&gt;通过抽象寄存器的编号索引到一个处理函数, 然后调用它. 处理函数的具体功能和寄存器编号相关, 下面我们来逐一介绍NEMU中每个设备的功能.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一些重要的文件函数记录&#34;&gt;一些重要的文件、函数记录&lt;/h2&gt;
&lt;p&gt;代码框架可参考：&lt;a class=&#34;link&#34; href=&#34;https://ysyx.oscc.cc/forum/topic/16/pa2-3-nemu-am-am-kernels%e5%85%b1%e5%90%8c%e6%9e%84%e5%bb%ba%e7%9a%84%e8%99%9a%e6%8b%9f%e4%b8%96%e7%95%8c%e6%a6%82%e5%bf%b5%e5%9b%be&#34;  title=&#34;https://ysyx.oscc.cc/forum/topic/16/pa2-3-nemu-am-am-kernels共同构建的虚拟世界概念图&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ysyx.oscc.cc/forum/topic/16/pa2-3-nemu-am-am-kernels共同构建的虚拟世界概念图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随着代码复杂度越来越高，对框架的熟悉度要求指数上涨，必须开始记录每个框架的功能及其使用方式：&lt;/p&gt;
&lt;h3 id=&#34;基础文件&#34;&gt;基础文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令集相关文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;各类指令RTL调用函数实现部分：/home/physico/ics2021/nemu/src/isa/riscv32/instr/ *.h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;译码函数部分：/home/physico/ics2021/nemu/src/isa/riscv32/instr/decode.c&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数名-宏展开需要部分：/home/physico/ics2021/nemu/src/isa/riscv32/include/isa-all-instr.h（旁边的isa-exec可以包括1提到的）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISADecodeInfo：/home/physico/ics2021/nemu/src/isa/riscv32/include/isa-def.h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTL实现相关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/home/physico/ics2021/nemu/src/engine/interpreter/rtl-basic.h （def_rtl_compute_reg_imm）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/home/physico/ics2021/nemu/src/engine/interpreter/c_op.h（c_add(a, b) ((a) + (b)) 以及 interpret_relop类似RELOP_NE）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调试测试用指令与文件我以自己的路径为准&#34;&gt;调试测试用指令与文件（我以自己的路径为准）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IOE（包括时间等）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：/home/physico/ics2021/am-kernels/tests/am-tests&lt;/p&gt;
&lt;p&gt;测试方式：make ARCH=riscv32-nemu run mainargs=t  （其他测试方式自行读代码）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;benchmark测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：/home/physico/ics2021/am-kernels/benchmarks/microbench&lt;/p&gt;
&lt;p&gt;测试方式：make ARCH=riscv32-nemu run （其他benchmark同样方法可测）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;马里奥测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：home/physico/ics2021/fceux-am&lt;/p&gt;
&lt;p&gt;测试方式： make ARCH=riscv32-nemu run mainargs=mario&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设备相关文件&#34;&gt;设备相关文件：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时钟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AM的相关实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/home/physico/ics2021/abstract-machine/am/src/platform/nemu/ioe/timer.c （需要实现）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;native的相关实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/home/physico/ics2021/abstract-machine/am/src/native/ioe/timer.c&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nemu的相关实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/home/physico/ics2021/nemu/src/device/timer.c&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/home/physico/ics2021/nemu/src/utils/timer.c&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;串口&#34;&gt;串口&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;nemu/src/device/serial.c&lt;/code&gt;模拟了串口的功能. 其大部分功能也被简化, &lt;strong&gt;只保留了数据寄存器.&lt;/strong&gt; 串口初始化时会分别注册&lt;code&gt;0x3F8&lt;/code&gt;处长度为8个字节的端口, 以及&lt;code&gt;0xa00003F8&lt;/code&gt;处长度为8字节的MMIO空间, 它们都会映射到串口的数据寄存器. &lt;/p&gt;
&lt;p&gt;由于NEMU串行模拟计算机系统的工作, 串口的状态寄存器可以一直处于空闲状态; 每当CPU往数据寄存器中写入数据时, 串口会将数据传送到主机的标准错误流进行输出.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/am/src/platform/nemu/trm.c&lt;/code&gt;中的&lt;code&gt;putch()&lt;/code&gt;会将字符输出到串口.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 130; 
			flex-basis: 312px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_JmykngWSPV.png&#34; data-size=&#34;591x454&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_JmykngWSPV.png&#34;
			width=&#34;591&#34;
			height=&#34;454&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_JmykngWSPV_hu798079399d6dcfc4e2f1a670248e3bf8_75079_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_JmykngWSPV_hu798079399d6dcfc4e2f1a670248e3bf8_75079_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以配合vsprintf做成Printf。&lt;/p&gt;
&lt;h4 id=&#34;理解mainargs&#34;&gt;理解mainargs&lt;/h4&gt;
&lt;p&gt;请你通过RTFSC理解这个参数是如何从&lt;code&gt;make&lt;/code&gt;命令中传递到&lt;code&gt;hello&lt;/code&gt;程序中的, &lt;code&gt;$ISA-nemu&lt;/code&gt;和&lt;code&gt;native&lt;/code&gt;采用了不同的传递方法, 都值得你去了解一下.&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;ISA-NEMU通过ics2021/abstract-machine/scripts/platform/nemu.mk中的宏定义：-D&lt;/p&gt;
&lt;p&gt;CFLAGS += -DMAINARGS=\&amp;quot;$(mainargs)\&amp;ldquo;然后就在main（mainargs）&lt;/p&gt;
&lt;h3 id=&#34;时钟埋了大坑&#34;&gt;时钟【埋了大坑】&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 134; 
			flex-basis: 323px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Sb6pxH3RgZ.png&#34; data-size=&#34;598x444&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Sb6pxH3RgZ.png&#34;
			width=&#34;598&#34;
			height=&#34;444&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Sb6pxH3RgZ_hu82fd8750565bd6cb16432e82780786d6_77820_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_Sb6pxH3RgZ_hu82fd8750565bd6cb16432e82780786d6_77820_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有了时钟, 程序才可以提供时间相关的体验, 例如游戏的帧率, 程序的快慢等. &lt;code&gt;nemu/src/device/timer.c&lt;/code&gt;模拟了i8253计时器的功能. 计时器的大部分功能都被简化, 只保留了&amp;quot;发起时钟中断&amp;quot;的功能(目前我们不会用到). 同时添加了一个自定义的时钟. i8253计时器初始化时会分别注册&lt;code&gt;0x48&lt;/code&gt;处长度为8个字节的端口, 以及&lt;code&gt;0xa0000048&lt;/code&gt;处长度为8字节的MMIO空间, 它们都会映射到RTC寄存器. CPU可以访问这两个寄存器来获得当前时间.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/am/include/amdev.h&lt;/code&gt;中为时钟的功能定义了两个抽象寄存器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AM_TIMER_RTC&lt;/code&gt;, AM实时时钟(RTC, Real Time Clock), 可读出当前的年月日时分秒. PA中暂不使用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AM_TIMER_UPTIME&lt;/code&gt;, AM系统启动时间, 可读出系统启动后的微秒数.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;实现IOE&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;abstract-machine/am/src/platform/nemu/ioe/timer.c&lt;/code&gt;中实现&lt;code&gt;AM_TIMER_UPTIME&lt;/code&gt;的功能. 在&lt;code&gt;abstract-machine/am/src/platform/nemu/include/nemu.h&lt;/code&gt;和 &lt;code&gt;abstract-machine/am/src/$ISA/$ISA.h&lt;/code&gt;中有一些输入输出相关的代码供你使用.&lt;/p&gt;
&lt;p&gt;实现后, 在&lt;code&gt;$ISA-nemu&lt;/code&gt;中运行&lt;code&gt;am-kernel/tests/am-tests&lt;/code&gt;中的&lt;code&gt;real-time clock test&lt;/code&gt;测试. 如果你的实现正确, 你将会看到程序每隔1秒往终端输出一行信息. 由于我们没有实现&lt;code&gt;AM_TIMER_RTC&lt;/code&gt;, 测试总是输出1900年0月0日0时0分0秒, 这属于正常行为, 可以忽略.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;native&lt;/code&gt;的IOE是基于SDL库实现的, 它们假设常用库函数的行为会符合glibc标准, 但我们自己实现的klib通常不能满足这一要求. 因此&lt;code&gt;__NATIVE_USE_KLIB__&lt;/code&gt;仅供测试klib实现的时候使用, 我们不要求在定义&lt;code&gt;__NATIVE_USE_KLIB__&lt;/code&gt;的情况下正确运行所有程序.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我卡了一段时间（主要是跑分过高甚至有些跑不了。），我参考了一生一芯论坛某个大佬的思路：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ysyx.oscc.cc/forum/topic/56/pa2-3%e5%ae%9e%e7%8e%b0%e6%97%b6%e9%92%9f%e4%b8%ba%e4%be%8b%e7%9a%84%e4%b8%80%e4%ba%9brtsc%e6%80%9d%e8%b7%af&#34;  title=&#34;https://ysyx.oscc.cc/forum/topic/56/pa2-3实现时钟为例的一些rtsc思路&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ysyx.oscc.cc/forum/topic/56/pa2-3实现时钟为例的一些rtsc思路&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;解决时钟问题的钥匙理解更新过程&#34;&gt;解决时钟问题的钥匙——理解更新过程&lt;/h3&gt;
&lt;p&gt;我们需要思考，内存映射的逻辑是什么，为什么我们通过学习类似abstract-machine/am/src/platform/nemu/ioe/timer.c 的方法能够读出数据？或者使用文档里让我们看文件中的读写方式能够读出时间数据？（具体可以看上面那个大佬的思路）关键在于——时间是被更新到地址上的，那么什么造成了地址对应数据的更新？讲义给出了答案，让我们反复阅读&lt;strong&gt;映射和IO方式&lt;/strong&gt;： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;框架代码为映射定义了一个结构体类型&lt;code&gt;IOMap&lt;/code&gt;(在&lt;code&gt;nemu/include/device/map.h&lt;/code&gt;中定义), 包括名字, 映射的起始地址和结束地址, 映射的目标空间, 以及一个回调函数.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nemu/src/device/io/map.c&lt;/code&gt;实现了映射的管理, 包括I/O空间的分配及其映射, 还有映射的访问接口.&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;map_read()&lt;/code&gt;和&lt;code&gt;map_write()&lt;/code&gt;用于将地址&lt;code&gt;addr&lt;/code&gt;&lt;strong&gt;映射到&lt;/strong&gt;​&lt;strong&gt;所指示的目标空间&lt;/strong&gt;, 并进行访问. &lt;strong&gt;访问时, 可能会触发相应的回调函数, 对设备和目标空间的状态进行更新.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;nemu/src/device/io/port-io.c&lt;/code&gt;是对端口映射I/O的模拟. &lt;code&gt;add_pio_map()&lt;/code&gt;函数&lt;strong&gt;用于为设备的初始化注册一个端口映射I/O的映射关系.&lt;/strong&gt; &lt;code&gt;pio_read()&lt;/code&gt;和&lt;code&gt;pio_write()&lt;/code&gt;是面向CPU的端口I/O读写接口, 它们最终会调用&lt;code&gt;map_read()&lt;/code&gt;和&lt;code&gt;map_write()&lt;/code&gt;, &lt;strong&gt;对通过&lt;/strong&gt;​&lt;strong&gt;注册的I/O空间进行访问.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时候我们就会想到，这个对设备和目标空间状态更新的函数，对时钟来说，是什么呢？&lt;/p&gt;
&lt;p&gt;注意到———— nemu/src/device/timer.c模拟了i8253计时器的功能&lt;/p&gt;
&lt;p&gt;此时进入后会发现熟悉的add_pio_map，还有一个rtc_io_handler这里出现了gettime! 感觉是我们想要的答案，但此时会发现一个offset，那么这个offset到底是什么呢，让我们继续打开add_pio_map，继续一路寻找用到callback的地方会发现回到了map，其中的map_read的write告诉了我们原来在这里传入callback,其中offset也就不言而喻了。&lt;/p&gt;
&lt;p&gt;得知offset = addr - map-&amp;gt;low后，我们再倒回去看某个函数就显得可疑了， addr 可以就是 map-&amp;gt;low，也可以是low+4。那么哪个才是对的呢？让我们再复习这句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中&lt;code&gt;map_read()&lt;/code&gt;和&lt;code&gt;map_write()&lt;/code&gt;用于将地址&lt;code&gt;addr&lt;/code&gt;&lt;strong&gt;映射到&lt;/strong&gt;​&lt;strong&gt;所指示的目标空间&lt;/strong&gt;, 并进行访问. &lt;strong&gt;访问时, 可能会触发相应的回调函数, 对设备和目标空间的状态进行更新.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时候问题就变成addr到底是等于什么的时候更新才是对的呢？我们怎么访问地址更新数据才是正确的？&lt;/p&gt;
&lt;p&gt;这个访问会对我们读取时钟数据有什么影响？我们读取地址上的时钟数据的时候是怎么做的？&lt;/p&gt;
&lt;p&gt;在反复阅读一下前面大佬分享的RTFC的过程，相信你能得到答案。&lt;/p&gt;
&lt;h3 id=&#34;键盘&#34;&gt;键盘&lt;/h3&gt;
&lt;p&gt;这部分只要弄懂了时钟，非常简单。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 131; 
			flex-basis: 314px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_kkwo6gla7L.png&#34; data-size=&#34;787x600&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_kkwo6gla7L.png&#34;
			width=&#34;787&#34;
			height=&#34;600&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_kkwo6gla7L_hud62c878b0f7197ce13a04b2eccd85dcb_147592_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_kkwo6gla7L_hud62c878b0f7197ce13a04b2eccd85dcb_147592_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;vga&#34;&gt;VGA&lt;/h3&gt;
&lt;p&gt;现代的显示器一般都支持24位的颜色(R, G, B各占8个bit, 共有&lt;code&gt;2^8*2^8*2^8&lt;/code&gt;约1600万种颜色)&lt;/p&gt;
&lt;p&gt;为了让屏幕显示不同的颜色成为可能, 在8位颜色深度时会使用调色板的概念. 调色板是一个颜色信息的数组, 每一个元素占4个字节, 分别代表R(red), G(green), B(blue), A(alpha)的值&lt;/p&gt;
&lt;p&gt;一个像素存储的就不再是颜色的信息, 而是一个调色板的索引&lt;/p&gt;
&lt;p&gt;要得到一个像素的颜色信息, 就要把它的值当作下标, 在调色板这个数组中做下标运算, 取出相应的颜色信息. 因此, 只要使用不同的调色板, 就可以在不同的时刻使用不同的256种颜色了.&lt;/p&gt;
&lt;p&gt;Q：在一些90年代的游戏中(比如仙剑奇侠传), 很多渐出渐入效果都是通过调色板实现的, 聪明的你知道其中的玄机吗?&lt;/p&gt;
&lt;p&gt;A:通过线性改变索引？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在NEMU中, GPU仅仅保留绘制像素的基本功能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/am/include/amdev.h&lt;/code&gt;中为GPU定义了五个抽象寄存器, 在NEMU中只会用到其中的两个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AM_GPU_CONFIG&lt;/code&gt;, AM显示控制器信息, 可读出屏幕大小信息&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;height&lt;/code&gt;. 另外AM假设系统在运行过程中, 屏幕大小不会发生变化.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AM_GPU_FBDRAW&lt;/code&gt;, AM帧缓冲控制器, 可写入绘图信息, 向屏幕&lt;code&gt;(x, y)&lt;/code&gt;坐标处绘制&lt;code&gt;w*h&lt;/code&gt;的矩形图像. &lt;strong&gt;图像像素按行优先方式&lt;/strong&gt;存储在&lt;code&gt;pixels&lt;/code&gt;中, 每个像素&lt;strong&gt;用32位整数&lt;/strong&gt;以&lt;code&gt;00RRGGBB&lt;/code&gt;的方式描述颜色. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;若&lt;/strong&gt;&lt;code&gt;sync&lt;/code&gt;&lt;strong&gt;为&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;strong&gt;, 则马上将帧缓冲中的内容同步到屏幕上.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; VGA设备还有两个寄存器: 屏幕大小寄存器和同步寄存器.&lt;/p&gt;
&lt;p&gt; 屏幕大小寄存器的硬件(NEMU)功能已经实现, 但软件(AM)还没有去使用它;&lt;/p&gt;
&lt;p&gt; 同步寄存器软件(AM)已经实现了同步屏幕的功能, 但硬件(NEMU)尚未添加相应的支持.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我卡的最久的是1、如何理解隐藏的同步信息  2、如何绘制像素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;针对第一个问题，&lt;/strong&gt; 其实关键是不理解抽象寄存器是如何与实际硬件寄存器联系起来的。经过RTFSC我们能知道形如“_port_base”（在内存读取中参数为space）才是真正的寄存器位置，而且也在地址空间中开辟了对应的内存。(当然你不仅可以通过开辟的空间去猜测只有两个寄存器，因为你会找到一个newplace（8）；同时也可以找到SYNC_ADDR的地址，那里是同步的地址，再配合VGA本体映射的地址猜猜看即可；或者你也可以参考有一个叫做pixel *render的地方，那里也可以参考）&lt;/p&gt;
&lt;p&gt;（同时这里我也还不知道指针也可以直接取下标运算，我一直记着指针不等同数组，直到查阅知道了其实编译器中这是一个东西：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了优先级不同之外，下标表达式 array[ value ] 和间接访问表达式 *（array + ( value )） 是一样的。因此，下标不仅可以用作数组名，也可以用于指针表达式中。不过这样一来，编译器就很难检查下标的有效性。（斟酌）（意思是如果用指针加下标的方式来表达数组的元素，编译器无法检测到是否越界！）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.51cto.com/u_15338162/5206658&#34;  title=&#34;https://blog.51cto.com/u_15338162/5206658&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.51cto.com/u_15338162/5206658&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/399327901&#34;  title=&#34;https://zhuanlan.zhihu.com/p/399327901&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/399327901&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们回来继续思考问题，抽象寄存器的编号又是如何与实际寄存器的编号（比如5、6、7和具体的[0] [1]）联系起来的呢？&lt;/p&gt;
&lt;p&gt;所以，如果实现了AM的同步寄存器但没有硬件支持，说明硬件部分实际上缺少了一个对同步寄存器的读取，那么哪一个才是硬件同步寄存器呢？他在哪呢？这就需要RTFSC了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;针对第二个问题，&lt;/strong&gt; 实际上pa2021的框架比2020的难，因为2021的native没有办法参考，而2020的native代码给出了绘制实现。这里我是参考了2020的native才做出来的。实际上要理解这一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 向屏幕&lt;code&gt;(x, y)&lt;/code&gt;坐标处绘制&lt;code&gt;w*h&lt;/code&gt;的矩形图像. 图像像素按行优先方式存储在&lt;code&gt;pixels&lt;/code&gt;中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 这个x y w h的含义，实际上是从绘制理解的。我们图像的绘制从左上角开始，也就是多维数组展平成一维数据一直画下去（你可以更改fb(i)=[i]的值和for范围查看），而一个好的理解方式是把x,y当做开始绘制的点。也就是说如果你要绘制一个小矩形框，本质是一个点“拖出来的”，因为本质是从一维数组从左到右画。那么我们知道了此时的x,y是基础偏移坐标（也就是绘制小矩形框的基础坐标），而我们绘制需要for循环表达的是i和j坐标也就是小矩形框的坐标，其中pixels是我们将要画的小矩形的像素信息。&lt;/p&gt;
&lt;p&gt;我们的目的是把小矩形的像素信息从行开始遍历一个个i和j,再通过fb绘制到大矩形框（gpu内存映射地址）上，所以你应该思考这个映射是怎么做的，如何表达“从某一行开始，一列列的画过去？”，具体的坐标信息该如何转换？这就是你应该思考的了。实在不行，你可以参考2020naitive有关gpu的相关实现。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 132; 
			flex-basis: 318px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_RP0_t5brvH.png&#34; data-size=&#34;787x593&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_RP0_t5brvH.png&#34;
			width=&#34;787&#34;
			height=&#34;593&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_RP0_t5brvH_hud2e09f0d8704a7975126f380f32e61b8_206093_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/image/image_RP0_t5brvH_hud2e09f0d8704a7975126f380f32e61b8_206093_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;实现完后你就可以跑马里奥等程序了，我的fps大概是25左右，好好享受自己的作品！&lt;/p&gt;
&lt;h3 id=&#34;声卡部分&#34;&gt;声卡部分&lt;/h3&gt;
&lt;p&gt;暂时坑了&lt;/p&gt;
&lt;h2 id=&#34;做完pa2应该熟悉的代码待完成&#34;&gt;【做完PA2应该熟悉的代码】（待完成&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NEMU中除了&lt;code&gt;fixdep&lt;/code&gt;, &lt;code&gt;kconfig&lt;/code&gt;, 以及没有选择的ISA之外的全部已有代码(包括Makefile)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/am/&lt;/code&gt;下与$ISA-nemu相关的, 除去CTE和VME之外的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/klib/&lt;/code&gt;中的所有代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/Makefile&lt;/code&gt;和&lt;code&gt;abstract-machine/scripts/&lt;/code&gt;中的所有代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;am-kernels/tests/cpu-tests/&lt;/code&gt;中的所有代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;am-kernels/tests/am-tests/&lt;/code&gt;中运行过的测试代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;am-kernels/benchmarks/microbench/bench.c&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;am-kernels/kernels/&lt;/code&gt;中的&lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;slider&lt;/code&gt;和&lt;code&gt;typing-game&lt;/code&gt;的所有代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你发现自己不能理解这些代码的行为, 就赶紧看看吧. 多看一个文件, bug少调几天, 到了PA3你就会领教到了. （这句话我还是非常相信的，所以宁愿慢一点一个个去看，慢就是快。）&lt;/p&gt;
&lt;h2 id=&#34;你应该知道并理解的知识待完成&#34;&gt;【你应该知道并理解的知识】（待完成&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序是个状态机 理解YEMU的执行过程, 具体请参考&lt;a class=&#34;link&#34; href=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/2.1.html#%e7%90%86%e8%a7%a3yemu%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%a8%8b%e5%ba%8f&#34;  title=&#34;这里&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTFSC 请整理一条指令在NEMU中的执行过程, 具体请参考&lt;a class=&#34;link&#34; href=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/2.2.html#rtfsc%e7%90%86%e8%a7%a3%e6%8c%87%e4%bb%a4%e6%89%a7%e8%a1%8c%e7%9a%84%e8%bf%87%e7%a8%8b&#34;  title=&#34;这里&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序如何运行 理解打字小游戏如何运行, 具体请参考&lt;a class=&#34;link&#34; href=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/2.5.html#%e6%b8%b8%e6%88%8f%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%90%e8%a1%8c%e7%9a%84&#34;  title=&#34;这里&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译与链接 在&lt;code&gt;nemu/src/engine/interpreter/rtl-basic.h&lt;/code&gt;中, 你会看到由&lt;code&gt;static inline&lt;/code&gt;开头定义的各种RTL指令函数. 选择其中一个函数, 分别尝试去掉&lt;code&gt;static&lt;/code&gt;, 去掉&lt;code&gt;inline&lt;/code&gt;或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生/不发生? 你有办法证明你的想法吗?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译与链接&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;nemu/include/common.h&lt;/code&gt;中添加一行&lt;code&gt;volatile static int dummy;&lt;/code&gt; 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个&lt;code&gt;dummy&lt;/code&gt;变量的实体? 你是如何得到这个结果的?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加上题中的代码后, 再在&lt;code&gt;nemu/include/debug.h&lt;/code&gt;中添加一行&lt;code&gt;volatile static int dummy;&lt;/code&gt; 然后重新编译NEMU. 请问此时的NEMU含有多少个&lt;code&gt;dummy&lt;/code&gt;变量的实体? 与上题中&lt;code&gt;dummy&lt;/code&gt;变量实体数目进行比较, 并解释本题的结果.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改添加的代码, 为两处&lt;code&gt;dummy&lt;/code&gt;变量进行初始化:&lt;code&gt;volatile static int dummy = 0;&lt;/code&gt; 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;了解Makefile 请描述你在&lt;code&gt;am-kernels/kernels/hello/&lt;/code&gt;目录下敲入&lt;code&gt;make ARCH=$ISA-nemu&lt;/code&gt; 后, &lt;code&gt;make&lt;/code&gt;程序如何组织.c和.h文件, 最终生成可执行文件&lt;code&gt;am-kernels/kernels/hello/build/hello-$ISA-nemu.elf&lt;/code&gt;. (这个问题包括两个方面:&lt;code&gt;Makefile&lt;/code&gt;的工作方式和编译链接的过程.) 关于&lt;code&gt;Makefile&lt;/code&gt;工作方式的提示:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt;中使用了变量, 包含文件等特性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Makefile&lt;/code&gt;运用并重写了一些implicit rules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;man make&lt;/code&gt;中搜索&lt;code&gt;-n&lt;/code&gt;选项, 也许会对你有帮助&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021&#34;  title=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://nju-projectn.github.io/ics-pa-gitbook/ics2021&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络上搜到的一些细节，但由于学术诚信不予放出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>NJU计算机课程基础实验 PA2笔记（一）</title>
        <link>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
        <pubDate>Fri, 12 Aug 2022 21:50:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
        <description>&lt;h2 id=&#34;pa21-冯诺依曼计算机&#34;&gt;PA2.1 冯诺依曼计算机&lt;/h2&gt;
&lt;p&gt;写在前面：&lt;/p&gt;
&lt;p&gt;首先要感谢jyy群一直帮助我的pony小哥、17号小哥、YSYX论坛（还有很多帮助我的人，没写出来但我都很感谢！）&lt;/p&gt;
&lt;p&gt;没有你们我是不可能能这么快理解（甚至完全做不出）这一部分的。&lt;/p&gt;
&lt;p&gt;我的基础很薄弱，对于ISA真的一无所知，感谢无私的帮助&lt;/p&gt;
&lt;p&gt;注意，包老师的中文版手册有些地方是有错的，建议只看概念，具体的编码参考英文的资料，比如：&lt;a class=&#34;link&#34; href=&#34;https://msyksphinz-self.github.io/riscv-isadoc/html/rvi.html#fence-i&#34;  title=&#34;https://msyksphinz-self.github.io/riscv-isadoc/html/rvi.html#fence-i&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://msyksphinz-self.github.io/riscv-isadoc/html/rvi.html#fence-i&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体还是要以英文手册的译码为准。&lt;/p&gt;
&lt;p&gt;【前半部分都是纯粹的抄讲义阶段。。但是抄了后真的能比较好理解】&lt;/p&gt;
&lt;p&gt;PA2一开始的任务是实现译码的流程，补充辅助译码函数（注意一下伪指令不用实现，函数体可以留空）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 130; 
			flex-basis: 314px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_i18vYAuiKq.png&#34; data-size=&#34;585x447&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_i18vYAuiKq.png&#34;
			width=&#34;585&#34;
			height=&#34;447&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_i18vYAuiKq_hu276bc6bf00340cfea100b6aab7a3d506_85708_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_i18vYAuiKq_hu276bc6bf00340cfea100b6aab7a3d506_85708_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;rtfsc2&#34;&gt;RTFSC(2)&lt;/h2&gt;
&lt;h3 id=&#34;fetch_decode_exec_updatepc-取指-译码-执行-更新pc&#34;&gt;fetch_decode_exec_updatepc()： 取指, 译码, 执行, 更新PC&lt;/h3&gt;
&lt;p&gt;在cpu_exec——fetch_decode_exec_updatepc——fetch_decode&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fetch_decode_exec_updatepc()&lt;/code&gt;接受一个&lt;code&gt;Decode&lt;/code&gt;类型的结构体指针&lt;code&gt;s&lt;/code&gt;, 这个结构体用于存放在执行一条指令过程中的译码和执行信息, 包括指令的PC, 执行方式, 以及操作数的信息. 还有一些信息是ISA相关的, NEMU用一个结构类型&lt;code&gt;ISADecodeInfo&lt;/code&gt;来对这些信息进行抽象, 具体的定义在&lt;code&gt;nemu/src/isa/$ISA/include/isa-def.h&lt;/code&gt;中. &lt;code&gt;fetch_decode_exec_updatepc()&lt;/code&gt;首先会调用&lt;code&gt;fetch_decode()&lt;/code&gt;进行取指和译码, &lt;code&gt;fetch_decode()&lt;/code&gt;会先把当前的PC保存到&lt;code&gt;s&lt;/code&gt;的成员&lt;code&gt;pc&lt;/code&gt;和&lt;code&gt;snpc&lt;/code&gt;中, 其中&lt;code&gt;s-&amp;gt;pc&lt;/code&gt;就是当前指令的PC, 而&lt;code&gt;s-&amp;gt;snpc&lt;/code&gt;则是下一条指令的PC, 这里的&lt;code&gt;snpc&lt;/code&gt;是 &lt;strong&gt;&amp;ldquo;static next PC&amp;quot;的意思.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后代码会调用&lt;code&gt;isa_fetch_decode()&lt;/code&gt;函数(在&lt;code&gt;nemu/src/isa/$ISA/instr/decode.c&lt;/code&gt;中定义), 它会随着取指的过程修改&lt;code&gt;s-&amp;gt;snpc&lt;/code&gt;的值, 使得从&lt;code&gt;isa_fetch_decode()&lt;/code&gt;返回后&lt;code&gt;s-&amp;gt;snpc&lt;/code&gt;正好为下一条指令的PC.  这里的&lt;code&gt;dnpc&lt;/code&gt;**是&amp;quot;dynamic next PC&amp;quot;的意思. **&lt;/p&gt;
&lt;p&gt;此外, &lt;code&gt;isa_fetch_decode()&lt;/code&gt;还会返回一个编号&lt;code&gt;idx&lt;/code&gt;, 用于对&lt;code&gt;g_exec_table&lt;/code&gt;这一数组进行索引. &lt;code&gt;g_exec_table&lt;/code&gt;是一个函数指针的数组, 数组中的每个元素都会指向一个用于模拟指令执行的函数, 我们把这样的函数称为&amp;quot;执行辅助函数&amp;rdquo;(execution helper function). 通过&lt;code&gt;idx&lt;/code&gt;索引这个数组, 可以找到与一条指令相匹配的执行辅助函数, 并把它记录到&lt;code&gt;s-&amp;gt;EHelper&lt;/code&gt;中.&lt;/p&gt;
&lt;p&gt;忽略&lt;code&gt;fetch_decode()&lt;/code&gt;中剩下与trace相关的代码, 我们就返回到&lt;code&gt;fetch_decode_exec_updatepc()&lt;/code&gt;中. &lt;strong&gt;&lt;strong&gt;&lt;strong&gt;将会调用刚才记录到&lt;/strong&gt;&lt;/strong&gt;的执行辅助函数, 来模拟指令执行的真正操作. 最后会更新PC, 让PC指向下一条指令.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然, &lt;code&gt;fetch_decode_exec_updatepc()&lt;/code&gt;函数覆盖了指令周期的所有阶段: &lt;strong&gt;取指, 译码, 执行, 更新PC.&lt;/strong&gt; 在这些阶段中, 代码都可以对&lt;code&gt;s&lt;/code&gt;进行记录和访问. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;取指instruction-fetch-if&#34;&gt;取指(instruction fetch, IF)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;isa_fetch_decode()&lt;/code&gt;做的第一件事情就是取指令. 在NEMU中, 有一个函数&lt;code&gt;instr_fetch()&lt;/code&gt;(在&lt;code&gt;nemu/include/cpu/ifetch.h&lt;/code&gt;中定义)专门负责取指令的工作. &lt;code&gt;instr_fetch()&lt;/code&gt;最终会根据参数&lt;code&gt;len&lt;/code&gt;来调用&lt;code&gt;vaddr_ifetch()&lt;/code&gt;(在&lt;code&gt;nemu/src/memory/vaddr.c&lt;/code&gt;中定义), 而目前&lt;code&gt;vaddr_ifetch()&lt;/code&gt;又会通过&lt;code&gt;paddr_read()&lt;/code&gt;来访问物理内存中的内容. 因此, 取指操作的本质只不过就是一次内存的访问而已.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isa_fetch_decode()&lt;/code&gt;在调用&lt;code&gt;instr_fetch()&lt;/code&gt;的时候传入了&lt;code&gt;s-&amp;gt;snpc&lt;/code&gt;的地址, 因此&lt;code&gt;instr_fetch()&lt;/code&gt;最后还会根据&lt;code&gt;len&lt;/code&gt;来更新&lt;code&gt;s-&amp;gt;snpc&lt;/code&gt;, 从而让&lt;code&gt;s-&amp;gt;snpc&lt;/code&gt;指向下一条指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Motorola 68k系列的处理器都是大端架构的. 现在问题来了, 考虑以下两种情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设我们需要将NEMU运行在Motorola 68k的机器上(把NEMU的源代码编译成Motorola 68k的机器码)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设我们需要把Motorola 68k作为一个新的ISA加入到NEMU中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这两种情况下, 你需要注意些什么问题? 为什么会产生这些问题? 怎么解决它们?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：我猜想可以在memory的host.h处以及map.c的地方通过位置调整（改变addr指针的偏移）解决问题。有朋友提出可以固定len然后再拼起来，也有朋友建议可以了解一下ntohl和ntohs的现有转换库&lt;/p&gt;
&lt;h3 id=&#34;译码instruction-decode-id&#34;&gt;译码(instruction decode, ID)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;译码的目的是得到指令的操作和操作对象, 这主要是通过查看指令的opcode来决定的. 不同ISA的opcode会出现在指令的不同位置, 我们只需要根据指令的编码格式, 从取出的指令中识别出相应的opcode即可.&lt;/p&gt;
&lt;p&gt;和YEMU相比, NEMU使用一种抽象层次更高的译码方式: 模式匹配, NEMU可以通过一个模式字符串来指定指令中opcode:(def_INSTR_IDTAB 在 decode.c)&lt;/p&gt;
&lt;p&gt;nemu/include/cpu/decode.h 定义了这些各种各样的宏，包括模式匹配规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宏展开def的定义宏后是这样的：（根据def_INSTR_raw）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;pattern_decode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;??????? ????? ????? ??? ????? 01101 11&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;37&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;decode_U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;table_lui&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;操作对象(比如立即数是多少, 读入到哪个寄存器). 为了解决这个问题, 代码需要进行进一步的译码工作, 这是通过调用相应的&lt;code&gt;译码辅助函数&lt;/code&gt;(decode helper function)来完成的. 译码辅助函数统一通过宏&lt;code&gt;def_DHelper&lt;/code&gt;(在&lt;code&gt;nemu/include/cpu/decode.h&lt;/code&gt;中定义)来定义&lt;/p&gt;
&lt;p&gt;每个译码辅助函数负责进行一种类型的操作数译码, 把指令中的操作数信息分别记录在译码信息&lt;code&gt;s&lt;/code&gt;的&lt;code&gt;dest&lt;/code&gt;成员, &lt;code&gt;src1&lt;/code&gt;成员和&lt;code&gt;src2&lt;/code&gt;成员中, 它们分别代表&lt;strong&gt;目的操作数和两个源操作数&lt;/strong&gt;. &lt;code&gt;nemu/include/cpu/decode.h&lt;/code&gt;中还定义了三个宏&lt;code&gt;id_dest&lt;/code&gt;, &lt;code&gt;id_src1&lt;/code&gt;和&lt;code&gt;id_src2&lt;/code&gt;, 用于方便地访问它们.【注意，这里的关键是原操作数和目的操作数的是否可写入权限】&lt;/p&gt;
&lt;p&gt;寄存器和立即数这些操作数, 其实是非常常见的操作数类型. 为了进一步实现操作数译码和指令译码的解耦, 框架代码对这些操作数的译码进行了抽象封装, 指令译码过程由若干&lt;code&gt;译码操作数辅助函数&lt;/code&gt;(decode operand helper function)组成. 译码操作数辅助函数统一通过宏&lt;code&gt;def_DopHelper&lt;/code&gt;来定义&lt;/p&gt;
&lt;p&gt;DopHelper带有一个&lt;code&gt;flag&lt;/code&gt;参数, 不同的DopHelper可以用它来进行不同的处理. 例如寄存器的DopHelper可以通过&lt;code&gt;flag&lt;/code&gt;来指示是否写入（可以参考def_DopHelper(r)实现中的）&lt;/p&gt;
&lt;p&gt;&lt;code&gt; void concat(decode_op_, name) (Decode *s, Operand *op, word_t val, bool flag)&lt;/code&gt;可以匹配decode_op_r和decode_op_i(&lt;code&gt;def_DopHelper(r)&lt;/code&gt;, &lt;code&gt;def_DopHelper(i)&lt;/code&gt; )&lt;/p&gt;
&lt;p&gt;DopHelper带有一个&lt;code&gt;flag&lt;/code&gt;参数, 不同的DopHelper可以用它来进行不同的处理. 例如寄存器的DopHelper可以通过&lt;code&gt;flag&lt;/code&gt;来指示是否写入（可参考&lt;code&gt;def_DopHelper(r)&lt;/code&gt;中的实现）&lt;/p&gt;
&lt;p&gt;有了这些译码操作数辅助函数, 我们就可以用它们来编写译码辅助函数:&lt;code&gt;def_DHelper(I)&lt;/code&gt;、&lt;/p&gt;
&lt;p&gt;&lt;code&gt;def_DHelper(U)&lt;/code&gt;、 &lt;code&gt;def_DHelper(S)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;由于CISC指令变长的特性, x86指令长度和指令形式需要一边取指一边译码来确定, 而不像RISC指令集那样可以泾渭分明地处理取指和译码阶段, 因此你会在x86的译码操作数辅助函数中看到&lt;/strong&gt;​&lt;strong&gt;的操作.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Q：mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样, 把C代码中的32位常数直接编码到一条指令中. 思考一下, mips32和riscv32应该如何解决这个问题?&lt;/p&gt;
&lt;p&gt;A：指令和储存分开，而且可以用两个拼成一个，把数据存在32位寄存器，或者变成几个寄存器加减结果。或者有朋友说的可以高位低位分开储存(实际上你在手册中能看到部指令这样的实现之类的）。&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;def_INSTR_IDTAB&lt;/code&gt;的宏展开结果,：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;pattern_decode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;??????? ????? ????? ??? ????? 01101 11&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;37&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;decode_U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;table_lui&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于&lt;code&gt;lui&lt;/code&gt;指令, 在译码辅助函数&lt;code&gt;decode_U()&lt;/code&gt;执行结束后, 代码将会执行&lt;code&gt;table_lui()&lt;/code&gt;. &lt;code&gt;table_lui()&lt;/code&gt;的定义方式比较特殊, 部分宏展开后的定义:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;def_THelper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lui&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EXEC_ID_lui&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;其中宏&lt;code&gt;def_THelper&lt;/code&gt;(在&lt;code&gt;nemu/include/cpu/decode.h&lt;/code&gt;中定义) 用于**统一定义&amp;quot;表格辅助函数&amp;quot;(table helper function). **&lt;code&gt;table_lui()&lt;/code&gt;做的事情很简单, 它直接返回一个标识&lt;code&gt;lui&lt;/code&gt;指令的唯一ID. 这个ID会作为译码结果的返回值, 在&lt;code&gt;fetch_decode()&lt;/code&gt;中索引&lt;code&gt;g_exec_table&lt;/code&gt;数组.&lt;/p&gt;
&lt;p&gt;事实上, 译码的过程可以看成是若干查表的操作, 每一条模式匹配的规则都可以看成是表格中的一个表项, 因此我们可以使用表格辅助函数来描述这些译码的规则. 以riscv为例:&lt;/p&gt;
&lt;p&gt;这一模式字符串只能通过&lt;code&gt;opcode&lt;/code&gt;匹配到load类型的指令, 为了进一步确定是哪一条load指令, 我们还需要匹配&lt;code&gt;funct3&lt;/code&gt;字段（具体查看riscv手册就直到为什么要匹配那三个了。）, 因此我们引入一个新的表格辅助函数&lt;code&gt;table_load()&lt;/code&gt;, 匹配到load类型指令的时候, 会进一步调用&lt;code&gt;table_load()&lt;/code&gt;, 然后在其中通过额外的模式字符串来匹配&lt;code&gt;funct3&lt;/code&gt;字段, 例如: 以riscv为例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;n&#34;&gt;def_THelper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;def_INSTR_TAB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;??????? ????? ????? 010 ????? ????? ??&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EXEC_ID_inv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;def_INSTR_TAB&lt;/code&gt;也是一条字符串匹配规则, 但它&lt;strong&gt;并不需要调用译码辅助函数&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;这条规则描述了&amp;quot;在load类型指令中, 如果&lt;code&gt;funct3&lt;/code&gt;为&lt;code&gt;010&lt;/code&gt;, 则为&lt;code&gt;lw&lt;/code&gt;指令&amp;quot;.&lt;/p&gt;
&lt;p&gt;** NEMU把译码时的如下情况都看作是查表过程:** ​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;isa_fetch_decode()&lt;/code&gt;中查主表(main decode table)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在译码过程中分别匹配指令中的每一个域(如上文介绍的&lt;code&gt;table_load()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;译码出最终的指令时认为是一种特殊的查表操作, 直接返回标识该指令的唯一ID&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果所有模式匹配规则都无法成功匹配, 代码将会返回一个标识非法指令的ID.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;执行execute-ex&#34;&gt;执行(execute, EX)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;之前的关键是&lt;strong&gt;译码辅助函数&lt;/strong&gt;（decode_U）——译码辅助函数统一通过宏&lt;code&gt;def_DHelper&lt;/code&gt;(在&lt;code&gt;nemu/include/cpu/decode.h&lt;/code&gt;)来定义；以及&amp;quot;&lt;strong&gt;表格辅助函数&lt;/strong&gt;&amp;quot;&lt;code&gt;def_THelper&lt;/code&gt;(也在&lt;code&gt;nemu/include/cpu/decode.h&lt;/code&gt;)，他返回一个标识&lt;code&gt;lui&lt;/code&gt;指令的唯一ID. 这个ID会作为译码结果的返回值, 在&lt;code&gt;fetch_decode()&lt;/code&gt;中索引&lt;code&gt;g_exec_table&lt;/code&gt;数组。&lt;/p&gt;
&lt;p&gt;一种好的做法是把译码, 执行和操作数宽度的相关代码分离来, 实现解耦. 在框架代码中, 实现译码和执行之间的解耦的是&lt;code&gt;isa_fetch_decode()&lt;/code&gt;返回的编号, 这样我们就可以分别编写译码和执行的辅助函数, 然后进行组合:这很容易实现执行行为相同但译码方式不同的多条指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在我们需要注意的是&lt;strong&gt;执行辅助函数&lt;/strong&gt;&lt;code&gt;def_EHelper&lt;/code&gt;（在g_exec_table）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译码过程结束之后, 接下来会返回到&lt;code&gt;fetch_decode()&lt;/code&gt;中, 并通过返回的ID来从&lt;code&gt;g_exec_table&lt;/code&gt;数组中选择相应的执行辅助函数(execution helper function), 然后记录到&lt;code&gt;s-&amp;gt;EHelper&lt;/code&gt;中. 返回到&lt;code&gt;fetch_decode_exec_updatepc()&lt;/code&gt;后, 代码将会调用刚才记录的执行辅助函数. 执行辅助函数统一通过宏&lt;code&gt;def_EHelper&lt;/code&gt;(在&lt;code&gt;nemu/include/cpu/exec.h&lt;/code&gt;中定义)来定义&lt;/p&gt;
&lt;p&gt;（对x86来说, 大部分计算指令都可以访问内存, 来根据目的操作数类型的不同, 决定是写入寄存器还是写入内存; 对于mips32和riscv32, 访问内存只能通过特定的访存指令进行, 因此每条指令的目的操作数类型都是唯一的.）&lt;/p&gt;
&lt;p&gt;每个执行辅助函数都需要有一个标识该指令的ID以及一个表格辅助函数与之相对应, 通过一系列宏定义实现的. 在&lt;code&gt;nemu/src/isa/$ISA/include/isa-all-instr.h&lt;/code&gt;&lt;strong&gt;中定义用于表示指令列表的宏&lt;/strong&gt;&lt;code&gt;INSTR_LIST&lt;/code&gt;, 它定义了NEMU支持的所有指令. 然后代码通过一种类似函数式编程的方式来定义如下相关的内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;nemu/include/cpu/decode.h&lt;/code&gt;中为所有的执行辅助函数定义相应的ID. 以riscv32为例, 对&lt;code&gt;def_all_EXEC_ID()&lt;/code&gt;进行宏展开后, 结果如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#define def_all_EXEC_ID() enum { MAP(INSTR_LIST, def_EXEC_ID) TOTAL_INSTR }&lt;/p&gt;
&lt;p&gt;变为enum { EXEC_ID_lui, EXEC_ID_lw, EXEC_ID_sw, EXEC_ID_inv, EXEC_ID_nemu_trap, TOTAL_INSTR }&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;TOTAL_INSTR&lt;/code&gt;的值正好为目前所有指令的总数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只需要维护&lt;/strong&gt;​&lt;strong&gt;中的指令列表, 就可以正确维护执行辅助函数和译码之间的关系了.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;更新pc&#34;&gt;更新PC&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;更新PC的操作非常简单, 在fetch_decode_exec_updatepc把&lt;code&gt;s-&amp;gt;dnpc&lt;/code&gt;赋值给&lt;code&gt;cpu.pc&lt;/code&gt;即可. &lt;/p&gt;
&lt;p&gt;之前提到了&lt;code&gt;snpc&lt;/code&gt;和&lt;code&gt;dnpc&lt;/code&gt;, 它们的区别如下：&lt;/p&gt;
&lt;p&gt;在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;snpc&lt;/code&gt;是指代码中的下一条指令, 而&lt;code&gt;dnpc&lt;/code&gt;是指程序运行过程中的下一条指令. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;dnpc&lt;/code&gt;应该指向跳转目标的指令. 显然, 我们应该使用&lt;code&gt;s-&amp;gt;dnpc&lt;/code&gt;来更新PC, 并且在执行辅助函数中正确维护&lt;code&gt;s-&amp;gt;dnpc&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;用rtl表示指令行为&#34;&gt;用RTL表示指令行为&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个很重要！大部分译码函数都通过这个实现（具体有些行为在op_c中可以找到）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要详细查看&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在NEMU中,使用&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Register_transfer_language&#34;  title=&#34;RTL(寄存器传输语言)&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RTL(寄存器传输语言)&lt;/a&gt;来描述（先实现这些简单操作, 然后再用它们来实现指令）. &lt;/p&gt;
&lt;p&gt;RTL寄存器的定义. 在NEMU中, RTL寄存器统一使用&lt;code&gt;rtlreg_t&lt;/code&gt;来定义, 而&lt;code&gt;rtlreg_t&lt;/code&gt;(在&lt;code&gt;nemu/include/common.h&lt;/code&gt;中定义)其实只是一个&lt;code&gt;word_t&lt;/code&gt;类型:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rtlreg_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在NEMU中的RTL寄存器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不同ISA的通用寄存器(在&lt;code&gt;nemu/src/isa/$ISA/include/isa-def.h&lt;/code&gt;中定义)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时寄存器&lt;code&gt;s0, s1, s2&lt;/code&gt;和&lt;code&gt;t0&lt;/code&gt;(在&lt;code&gt;nemu/include/rtl/rtl.h&lt;/code&gt;中定义)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;零寄存器&lt;code&gt;rz&lt;/code&gt;(在&lt;code&gt;nemu/include/rtl/rtl.h&lt;/code&gt;中定义), 它的值总是0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;（其实不需要使用 临时寄存器就可以完成大部分指令&lt;/p&gt;
&lt;h2 id=&#34;实现新指令&#34;&gt;实现新指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;对译码, 执行和操作数宽度的解耦实现以及RTL的引入, 对在NEMU中实现客户指令提供了很大的便利, 为了实现一条新指令, 只需要&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;nemu/src/isa/$ISA/instr/decode.c&lt;/code&gt;中添加正确的模式匹配规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用RTL实现正确的执行辅助函数, &lt;strong&gt;需要注意使用RTL伪指令时要遵守上文提到的小型调用约定&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;nemu/src/isa/$ISA/include/isa-all-instr.h&lt;/code&gt;中把指令添加到&lt;code&gt;INSTR_LIST&lt;/code&gt;中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必要时在&lt;code&gt;nemu/src/isa/$ISA/include/isa-exec.h&lt;/code&gt;中添加相应的头文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;请整理一条指令在nemu中的执行过程&#34;&gt;请整理一条指令在NEMU中的执行过程.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令集相关文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;各类指令RTL调用函数实现部分：/home/physico/ics2021/nemu/src/isa/riscv32/instr/ *.h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;译码函数部分：/home/physico/ics2021/nemu/src/isa/riscv32/instr/decode.c&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数名-宏展开需要部分：/home/physico/ics2021/nemu/src/isa/riscv32/include/isa-all-instr.h（旁边的isa-exec可以包括1提到的）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISADecodeInfo：/home/physico/ics2021/nemu/src/isa/riscv32/include/isa-def.h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTL实现相关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/home/physico/ics2021/nemu/src/engine/interpreter/rtl-basic.h （def_rtl_compute_reg_imm）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/home/physico/ics2021/nemu/src/engine/interpreter/c_op.h（c_add(a, b) ((a) + (b)) 以及 interpret_relop类似RELOP_NE）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;踩坑心得&#34;&gt;踩坑心得&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;关键：理解立即数的符号位是怎么确定的，什么时候用无符号数有符号数，怎么样正确移位置，怎么样设置好src与dest的是否可读写权限。友情建议先实现diff（具体在哪请看讲义）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(注意，接下来的叙述是有问题的，之后会说问题在哪)&lt;/p&gt;
&lt;p&gt;一开始实现li，最后才知道li原来是伪指令，所以关键是先实现R、S、U的基础指令（RTSM有关中文部分）。一开始怎么样都无法编译，原来是忘记了computer相关头文件的函数实现，顺带修改了一下isa-def当中的结构体，终于编译通过（后来改成了先实现addi也就是R型指令）&lt;/p&gt;
&lt;p&gt;编译通过后，si还是会报错，在确定def_DHelper(R)初始化后反复检查发现是def_THelper(main)模式匹配就没匹配到（还好Log大法好一个个检查。。）直接看前面的指令是不正确的（不太清楚原因，就是手册开头有整理好基础类型，我对照结尾填写），通过直接搜addi（决定看英文的手册）改正后能搜到了不会报错。&lt;/p&gt;
&lt;p&gt;解决了编译和报错问题，写了一段a0相关的相加代码，发现还是有问题；最后排查是自己不够理解RTL的实现，要深入pseudo.h理解相关函数作用，然后再理解功能的实现套用即可得到正确的结果（一开始还把src2的立即数写成了src1.imm闹了笑话）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 118; 
			flex-basis: 283px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XDgiWvrVJ3.png&#34; data-size=&#34;697x590&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XDgiWvrVJ3.png&#34;
			width=&#34;697&#34;
			height=&#34;590&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XDgiWvrVJ3_hu8003b93f47ebbec98fd9614c73504636_123679_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_XDgiWvrVJ3_hu8003b93f47ebbec98fd9614c73504636_123679_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时候发现前面写的基础设施还是派上用场了&lt;/p&gt;
&lt;p&gt;一顿操作猛如虎，一样在做pa的朋友告诉我addi和lw一样都是I型，我一开始还不信（我以为相同低位表示一个类型）然后发现他们的低位不同也是I型（所以直接新增一个I类型的主表再同样的初始化后执行对应函数即可）&amp;hellip;..只能重新阅读手册理解类型是怎么区别的：&lt;/p&gt;
&lt;p&gt;当然前面虽然不小心“造了轮子”，但也不是坏事，还是能派上用场的。&lt;/p&gt;
&lt;p&gt;最困难的部分——怎么了解立即数？&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_39507748/article/details/120150936&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/qq_39507748/article/details/120150936&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/mikewolf2002/p/11196680.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/mikewolf2002/p/11196680.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有朋友建议我看cs61b，于是我去翻了一下&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://inst.eecs.berkeley.edu/%5c~cs61c/su20/pdfs/lectures/lec08.pdf&#34;  title=&#34;https://inst.eecs.berkeley.edu/\~cs61c/su20/pdfs/lectures/lec08.pdf&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://inst.eecs.berkeley.edu/~cs61c/su20/pdfs/lectures/lec08.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;理解这张图的含义（看不懂就多读几遍，2.4是下面一张图）【关键是指令给了组成imm的部分，imm图展示了要从指令的哪儿拿】&lt;/p&gt;
&lt;p&gt;猜测：拿inst[31]是不是就是00000000000或者1111111111111，也是一种拓展&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 124; 
			flex-basis: 299px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/1bd03668-bdc2-44d7-b2e1-e763b9f1fd04_XIr8lrpU_J.jpg&#34; data-size=&#34;1217x976&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/1bd03668-bdc2-44d7-b2e1-e763b9f1fd04_XIr8lrpU_J.jpg&#34;
			width=&#34;1217&#34;
			height=&#34;976&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/1bd03668-bdc2-44d7-b2e1-e763b9f1fd04_XIr8lrpU_J_hu77ccd8e5472a1d3b2a20ba4d352dbeb5_269388_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/1bd03668-bdc2-44d7-b2e1-e763b9f1fd04_XIr8lrpU_J_hu77ccd8e5472a1d3b2a20ba4d352dbeb5_269388_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Q:为什么要左移？&lt;/p&gt;
&lt;p&gt;A:我的看法是，我们的立即数一开始都要移位才能组装成真正的编码好的立即数（都是从0开始，为了让他到拼接的地方 我们必须移位）然后拼好后的立即数都要是这样的（2.4中都是组装好的立即数）也就是符号位扩展的。为什么说符号位扩展了？比如有inst31 的就是都000000 或者111111&lt;/p&gt;
&lt;p&gt;注意：伪函数是不需要实现的，编译器会帮你选择实现它真正的执行的函数，甚至都不用写。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 159; 
			flex-basis: 382px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Xw3IVa0aNN.png&#34; data-size=&#34;941x590&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Xw3IVa0aNN.png&#34;
			width=&#34;941&#34;
			height=&#34;590&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Xw3IVa0aNN_hu19954e5003bafd08a6d36fdd8e6360eb_144030_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_Xw3IVa0aNN_hu19954e5003bafd08a6d36fdd8e6360eb_144030_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;完成最简单的开始后~接下来就需要运行除了dummy各种各样的C文件了，确保指令都实现（比如基础的add和ifelse）&lt;/p&gt;
&lt;p&gt;Q：如果不知道哪个指令没实现怎么办？&lt;/p&gt;
&lt;p&gt;A：想想有了内存地址后在什么情况下能让他显示指令&lt;/p&gt;
&lt;p&gt;当然，更优雅的你可以在修改nemu.mk 中取消-b后缀即可让他完美停下来可以一步步看（在test中make的阶段），或者你也可以用这样的操作：（测试这个命令函参数找的我有点抑郁，注意-d后面的-，你也可以写-1）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;./riscv32-nemu-interpreter -d - 
--diff&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/xxxxxx/ics2021/nemu/tools/spike-diff/build/riscv32-spike-so  
/xxxxxxx/ics2021/am-kernels/tests/cpu-tests/build/add-riscv32-nemu.bin  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;提前加了diff后，发现一直卡在add.c无法实现的痛苦（bne一直有问题）查了非常久的compute和decode译码都无法找到错误，最后发现是isa-def立即数环节出错。。。。。。只有最高位int其他uint我却把B指令的其他立即数也写成了int&amp;hellip;&amp;hellip;所以旧报错了，改完后成功通过add测试，感觉人生到了一种大和谐~~~~&lt;/p&gt;
&lt;p&gt;这里引发了一个思考：为什么中间不能用int？有个老哥说这是因为有符号数字在bitfield中会自动补1，这是不行的，我们可以做实验来验证是不是位域都会有这个性质（其实就是有符号数的扩展性质，如果无符号数直接零拓展）。&lt;/p&gt;
&lt;p&gt;后面在实现R型指令的时候又遇到了bug，也是同样的寄存器问题，后面排查发现是译码阶段寄存器写入开关我写成了true，但得是false&amp;hellip;.原因是：&lt;/p&gt;
&lt;p&gt;另外，对于RTL你需要有更深入的理解，R和I其实都在32位寄存器-寄存器类型和寄存器-立即数类型的基本算术/逻辑运算里了。包括&lt;code&gt;rtl_(add|sub|and|or|xor|sll|srl|sra|setrelop)i?&lt;/code&gt;, 它们的定义用到了&lt;code&gt;nemu/src/engine/interpreter/c_op.h&lt;/code&gt;中的C语言运算。当想不出来的时候思考一下add和addi的区别，他们是怎么得到的。有关寄存器和imm的操作都有了，可以直接用。&lt;/p&gt;
&lt;p&gt;这里还涉及到mul，当我们看到op_c会发现都是64位，为什么呢？因为32乘法的话是错误的（不是溢出而是就是错，涉及到符号位的问题），具体原因可以看：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pages.cs.wisc.edu/~markhill/cs354/Fall2008/beyond354/int.mult.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pages.cs.wisc.edu/~markhill/cs354/Fall2008/beyond354/int.mult.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;程序-运行时环境与am&#34;&gt;程序, 运行时环境与AM&lt;/h2&gt;
&lt;p&gt;应用程序的运行需要&lt;a class=&#34;link&#34; href=&#34;http://en.wikipedia.org/wiki/Runtime_system&#34;  title=&#34;运行时环境&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;运行时环境&lt;/a&gt;的支持, 包括加载, 销毁程序, 以及提供程序运行时的各种动态链接库(你经常使用的库函数就是运行时环境提供的)等. 为了让客户程序在NEMU中运行, 现在需要相应的运行时环境的支持了.&lt;/p&gt;
&lt;p&gt;计算机可以永不停止地执行指令, 但一般的程序都是会结束的, 所以运行时环境需要向程序提供一种结束运行的方法. PA1中提到的那条人工添加的&lt;code&gt;nemu_trap&lt;/code&gt;指令, 就是让程序来结束运行的.&lt;/p&gt;
&lt;p&gt; 只要有内存, 有结束运行的方式, 加上实现正确的指令, 就可以支撑最简单程序的运行了. 而这, 也可以算是最简单的运行时环境了.&lt;/p&gt;
&lt;h3 id=&#34;将运行时环境封装成库函数&#34;&gt;将运行时环境封装成库函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API, 也就相当于实现了支撑程序运行的运行时环境, 这提升了程序开发的效率: 需要的时候只要调用这些API, 就能使用运行时环境提供的相应功能.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;am---裸机bare-metal运行时环境&#34;&gt;AM - 裸机(bare-metal)运行时环境&lt;/h3&gt;
&lt;p&gt;应用程序的运行都需要运行时环境的支持; 只进行纯粹计算任务的程序在TRM上就可以运行&lt;/p&gt;
&lt;p&gt;更高级的游戏需要运行时环境提供输入输出等的支持，我们需要收集这些需求，统一成一个API给程序，这样就可以支撑不同程序在各种架构上运行的库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个架构都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个架构上. 由于这组统一抽象的API代表了程序运行对计算机的需求, 所以我们把这组API称为抽象计算机&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;AM(Abstract machine)项目就是这样诞生的. 作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AM = TRM + IOE + CTE + VME + MPE&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;解耦和分层的艺术！&lt;/p&gt;
&lt;p&gt;(在NEMU中)实现硬件功能 -&amp;gt; (在AM中)提供运行时环境 -&amp;gt; (在APP层)运行程序&lt;/p&gt;
&lt;p&gt;(在NEMU中)实现更强大的硬件功能 -&amp;gt; (在AM中)提供更丰富的运行时环境 -&amp;gt; (在APP层)运行更复杂的程序&lt;/p&gt;
&lt;p&gt;整个AM项目分为两大部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/am/&lt;/code&gt; - 不同架构的AM API实现, 目前我们只需要关注NEMU相关的内容即可. 此外, &lt;code&gt;abstract-machine/am/include/am.h&lt;/code&gt;列出了AM中的所有API, 我们会在后续逐一介绍它们.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;abstract-machine/klib/&lt;/code&gt; - 一些架构无关的库函数, 方便应用程序的开发&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阅读&lt;code&gt;abstract-machine/am/src/platform/nemu/trm.c&lt;/code&gt;中的代码, 你会发现只需要实现很少的API就可以支撑起程序在TRM上运行了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Area heap&lt;/code&gt;结构用于指示堆区的起始和末尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void putch(char ch)&lt;/code&gt;用于输出一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void halt(int code)&lt;/code&gt;用于结束程序的运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void _trm_init()&lt;/code&gt;用于进行TRM相关的初始化工作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;am.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;nemu.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_heap_start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Area&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;heap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RANGE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_heap_start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PMEM_END&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#ifndef MAINARGS
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#define MAINARGS &amp;#34;&amp;#34;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mainargs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAINARGS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;putch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;outb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SERIAL_PORT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;halt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;nemu_trap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// should not reach here
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_trm_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mainargs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;halt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后来看看&lt;code&gt;halt()&lt;/code&gt;. &lt;code&gt;halt()&lt;/code&gt;里面调用了&lt;code&gt;nemu_trap()&lt;/code&gt;宏 (在&lt;code&gt;abstract-machine/am/src/platform/nemu/include/nemu.h&lt;/code&gt;中定义), 这个宏展开之后是一条&lt;a class=&#34;link&#34; href=&#34;http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html&#34;  title=&#34;内联汇编&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;内联汇编&lt;/a&gt;语句, 内联汇编语句允许我们在C代码中嵌入汇编语句, 显然, 这个宏的定义是和ISA相关的.&lt;/p&gt;
&lt;p&gt;这条特殊的指令是人为添加的, 标准的汇编器并不能识别它, objdump的反汇编结果也无法按照我们的想法将其反汇编为&lt;code&gt;nemu_trap&lt;/code&gt;. &lt;code&gt;nemu_trap()&lt;/code&gt;宏还会把一个标识结束的结束码移动到通用寄存器中, 这样, 这段汇编代码的功能就和&lt;code&gt;nemu/src/isa/$ISA/instr/special.h&lt;/code&gt; 中的执行辅助函数&lt;code&gt;def_EHelper(nemu_trap)&lt;/code&gt;对应起来了: 通用寄存器中的值将会作为参数传给&lt;code&gt;rtl_hostcall&lt;/code&gt;, &lt;code&gt;rtl_hostcall&lt;/code&gt;将会根据传入的&lt;code&gt;id&lt;/code&gt;(此处为&lt;code&gt;HOSTCALL_EXIT&lt;/code&gt;)来调用&lt;code&gt;set_nemu_state()&lt;/code&gt;, 将&lt;code&gt;halt()&lt;/code&gt;中的结束码设置到NEMU的monitor中, monitor将会根据结束码来报告程序结束的原因.&lt;/p&gt;
&lt;p&gt;（在哪结束，为什么结束）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译生成一个可以在NEMU的运行时环境上运行的程序的过程大致如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（这部分看得我头痛）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gcc将&lt;code&gt;$ISA-nemu&lt;/code&gt;的AM实现源文件编译成目标文件, 然后通过ar将这些目标文件作为一个库, 打包成一个归档文件&lt;code&gt;abstract-machine/am/build/am-$ISA-nemu.a&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gcc把应用程序源文件(如&lt;code&gt;am-kernels/tests/cpu-tests/tests/dummy.c&lt;/code&gt;)编译成目标文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过gcc和ar把程序依赖的运行库(如&lt;code&gt;abstract-machine/klib/&lt;/code&gt;)也编译并打包成归档文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据Makefile文件&lt;code&gt;abstract-machine/scripts/$ISA-nemu.mk&lt;/code&gt;中的指示, 让ld根据链接脚本&lt;code&gt;abstract-machine/scripts/linker.ld&lt;/code&gt;, 将上述目标文件和归档文件链接成可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述链接脚本的指示, 可执行程序重定位后的节从&lt;code&gt;0x100000&lt;/code&gt;或&lt;code&gt;0x80000000&lt;/code&gt;开始 (取决于&lt;code&gt;_pmem_start&lt;/code&gt;和&lt;code&gt;_entry_offset&lt;/code&gt;的值), 首先是&lt;code&gt;.text&lt;/code&gt;节, 其中又以&lt;code&gt;abstract-machine/am/src/$ISA/nemu/start.S&lt;/code&gt;中自定义的&lt;code&gt;entry&lt;/code&gt;节开始, 然后接下来是其它目标文件的&lt;code&gt;.text&lt;/code&gt;节. 这样, 可执行程序起始处总是放置&lt;code&gt;start.S&lt;/code&gt;的代码, 而不是其它代码, 保证客户程序总能从&lt;code&gt;start.S&lt;/code&gt;开始正确执行. 链接脚本也定义了其它节(包括&lt;code&gt;.rodata&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt;)的链接顺序, 还定义了一些关于位置信息的符号, 包括每个节的末尾, 栈顶位置, 堆区的起始和末尾.&lt;/p&gt;
&lt;p&gt;我们对编译得到的可执行文件的行为进行简单的梳理:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一条指令从&lt;code&gt;abstract-machine/am/src/$ISA/nemu/start.S&lt;/code&gt;开始, 设置好栈顶之后就跳转到&lt;code&gt;abstract-machine/am/src/platform/nemu/trm.c&lt;/code&gt;的&lt;code&gt;_trm_init()&lt;/code&gt;函数处执行.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;_trm_init()&lt;/code&gt;中调用&lt;code&gt;main()&lt;/code&gt;函数执行程序的主体功能, &lt;code&gt;main()&lt;/code&gt;函数还带一个参数, 目前我们暂时不会用到, 后面我们再介绍它.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从&lt;code&gt;main()&lt;/code&gt;函数返回后, 调用&lt;code&gt;halt()&lt;/code&gt;结束运行.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了TRM这个简单的运行时环境, 我们就可以很容易地在上面运行各种&amp;quot;简单&amp;quot;的程序了. 当然, 我们也可以运行&amp;quot;不简单&amp;quot;的程序: 我们可以实现任意复杂的算法, 甚至是各种理论上可计算的问题, 都可以在TRM上解决.&lt;/p&gt;
&lt;h3 id=&#34;实现更多库函数&#34;&gt;实现更多库函数&lt;/h3&gt;
&lt;p&gt;经过哭天喊地的实现终于。。。。。（sprintf实在是难度太大，我从网上找了好久找到一个最小实现printf魔改了一下，等更强了再来理解，实际上是要理解可变参数管理之类的才能解答。）&lt;/p&gt;
&lt;p&gt;批量测试通过 做个纪念:)  （做ISA的时候真的感觉人要没了，但是就这样慢慢前进还是看到了曙光） ：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 249; 
			flex-basis: 598px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_33TJP2y00Q.png&#34; data-size=&#34;1835x736&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_33TJP2y00Q.png&#34;
			width=&#34;1835&#34;
			height=&#34;736&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_33TJP2y00Q_hu0de1c487e05a2ff7b29582ea02fc3def_101992_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_33TJP2y00Q_hu0de1c487e05a2ff7b29582ea02fc3def_101992_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;重新认识计算机-计算机是个抽象层&#34;&gt;重新认识计算机: 计算机是个抽象层&lt;/h3&gt;
&lt;p&gt;微观视角: 程序是个状态机
宏观视角: 计算机是个抽象层&lt;/p&gt;
&lt;p&gt;大家在做实验的时候也可以多多思考: 我现在写的代码究竟位于哪一个抽象层? 代码的具体行为究竟是什么?&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 153; 
			flex-basis: 367px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_2UPNT_fep3.png&#34; data-size=&#34;655x428&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_2UPNT_fep3.png&#34;
			width=&#34;655&#34;
			height=&#34;428&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_2UPNT_fep3_hu15eebf432018fd6073ccbff8c04f19e5_73310_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/image/image_2UPNT_fep3_hu15eebf432018fd6073ccbff8c04f19e5_73310_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;状态机视角可以从指令层次精确地描述程序运行的每一处细节, 但丢失了程序的语义. 为了更好地理解复杂程序, 我们需要从一个新的视角来切入.&lt;/p&gt;
&lt;p&gt;先来讨论在TRM上运行的程序, 看计算机系统是如何支撑这些需求的.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;TRM&lt;/th&gt;
&lt;th&gt;计算&lt;/th&gt;
&lt;th&gt;内存申请&lt;/th&gt;
&lt;th&gt;结束运行&lt;/th&gt;
&lt;th&gt;打印信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;运行环境&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;malloc()/free()&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;printf()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AM API&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;heap&lt;/td&gt;
&lt;td&gt;halt()&lt;/td&gt;
&lt;td&gt;putch()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISA接口&lt;/td&gt;
&lt;td&gt;指令&lt;/td&gt;
&lt;td&gt;物理内存地址空间&lt;/td&gt;
&lt;td&gt;nemu_trap指令&lt;/td&gt;
&lt;td&gt;I/O方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬件模块&lt;/td&gt;
&lt;td&gt;处理器&lt;/td&gt;
&lt;td&gt;物理内存&lt;/td&gt;
&lt;td&gt;Monitor&lt;/td&gt;
&lt;td&gt;串口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;电路实现&lt;/td&gt;
&lt;td&gt;cpu_exec()&lt;/td&gt;
&lt;td&gt;pmem[]&lt;/td&gt;
&lt;td&gt;nemu_state&lt;/td&gt;
&lt;td&gt;serial_io_handler()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算. 这是程序最基本的需求, 以至于它甚至不属于运行时环境和AM的范畴. 所有计算相关的代码(顺序语句, 分支, 循环, 函数调用等), 都会被编译器编译成功能等价的指令序列, 最终在CPU上执行. 在NEMU中, 我们通过&lt;code&gt;cpu_exec()&lt;/code&gt;函数来实现&amp;quot;CPU执行指令&amp;quot;的功能.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存申请. 有的程序需要在运行时刻动态地申请内存来使用. 和libc类似, klib提供了&lt;code&gt;malloc()&lt;/code&gt;和&lt;code&gt;free()&lt;/code&gt;来实现内存的动态管理(你将来会实现它们), 它们又会使用TRM中提供的API &lt;code&gt;heap&lt;/code&gt;来获得堆区的起始和末尾. 而&lt;code&gt;heap&lt;/code&gt;&lt;strong&gt;的区间又是由ISA-平台这个二元组对应的物理内存地址空间来决定的&lt;/strong&gt;. 这一地址空间对应着物理内存的大小, 在NEMU中, 它就是大数组&lt;code&gt;pmem[]&lt;/code&gt;的大小.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束运行. 一般程序都会有结束运行的时候, TRM提供了一个&lt;code&gt;halt()&lt;/code&gt;的API来实现这一功能. 由于这个需求过于简单, 因此无需运行时环境提供更复杂的接口. &lt;code&gt;halt()&lt;/code&gt;的具体实现和ISA有关, 我们使用了人为添加的&lt;code&gt;nemu_trap&lt;/code&gt;指令来实现这一点. 执行&lt;code&gt;nemu_trap&lt;/code&gt;指令会让NEMU从CPU执行指令的循环中跳出, 返回到Monitor中, 这是通过设置Monitor中的一个状态变量&lt;code&gt;nemu_state&lt;/code&gt;来实现的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打印信息. 输出是程序的另一个基本需求. 程序可以调用klib中的&lt;code&gt;printf()&lt;/code&gt;来输出, 它会通过TRM的API &lt;code&gt;putch()&lt;/code&gt;来输出字符. 不同的ISA-平台有不同的字符输出方式, 在$ISA-nemu中, &lt;code&gt;putch()&lt;/code&gt;通过I/O相关的指令把字符写入到串口, 最终在NEMU中通过&lt;code&gt;serial_io_handler()&lt;/code&gt;将字符打印到终端. 关于输入输出的更多细节会在PA2的最后部分进行介绍.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一层抽象都有它存在的理由:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念相同的一个硬件模块有着不同的实现方式, 比如处理器既可以通过NEMU中简单的解释方式来实现, 也可以通过类似QEMU中高性能的二进制翻译方式来实现, 甚至可以通过verilog等硬件描述语言来实现一个真实的处理器.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISA是硬件向软件提供的可以操作硬件的接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AM的API对不同ISA(如x86/mips32/riscv32)的接口进行了抽象, 为上层的程序屏蔽ISA相关的细节&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时环境可以通过对AM的API进行进一步的封装, 向程序提供更方便的功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对am的进一步理解待完成&#34;&gt;对AM的进一步理解（待完成&lt;/h2&gt;
&lt;p&gt;暂时待填坑。。。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>推荐尝试的小工具</title>
        <link>https://sanbuphy.github.io/p/%E6%8E%A8%E8%8D%90%E5%B0%9D%E8%AF%95%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
        <pubDate>Sun, 31 Jul 2022 11:48:46 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%8E%A8%E8%8D%90%E5%B0%9D%E8%AF%95%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
        <description>&lt;h2 id=&#34;一些小工具&#34;&gt;一些小工具&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;让你能做出和&lt;a class=&#34;link&#34; href=&#34;http://jyywiki.cn/OS/2022/slides/1.slides#/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jyy一样的优雅ppt&lt;/a&gt;：https://sli.dev/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代替grep的超级命令行工具——ripgrep：https://github.com/BurntSushi/ripgrep&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;ripgrep is a line-oriented search tool that recursively searches the current directory for a regex pattern. By default, ripgrep will respect gitignore rules and automatically skip hidden files/directories and binary files. ripgrep has first class support on Windows, macOS and Linux, with binary downloads available for every release. ripgrep is similar to other popular search tools like The Silver Searcher, ack and grep.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;网络包分析——Wireshark：https://www.cnblogs.com/linyfeng/p/9496126.html&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#########待更新&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C语言标准IO的缓冲区介绍</title>
        <link>https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86io%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%8B%E7%BB%8D/</link>
        <pubDate>Sun, 31 Jul 2022 11:33:06 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86io%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%8B%E7%BB%8D/</guid>
        <description>&lt;p&gt;详细的缓冲区介绍请看这篇文章，非常详细   &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/lanhaicode/p/10575049.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/lanhaicode/p/10575049.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全缓冲：当缓冲区被填满以后才进行真正的输入输出操作&lt;/p&gt;
&lt;p&gt;行缓冲：当在输入或者输出的过程中遇到换行符时，才执行真正的输入输出操作&lt;/p&gt;
&lt;p&gt;无缓冲：没有缓冲区，立即进行输入输出&lt;/p&gt;
&lt;p&gt;实际上printf是行缓冲，如果&lt;code&gt;printf(&amp;quot;hello&amp;quot;)&lt;/code&gt;而不加上&lt;code&gt;\n&lt;/code&gt;是不会出现结果的(之前在fork()的时候遇到这个问题)&lt;/p&gt;
&lt;p&gt;但为什么我们直接看结果是会出现的呢？&lt;/p&gt;
&lt;p&gt;原因是标准输出在程序正常退出的时候，会调用 fclose(stdout)，而 fclose 函数会调用 fflush。因此，如果你的程序提前崩溃了，那是看不到缓冲区中的内容打印到控制台上的。特别注意的是，exit（正常退出）的话会输出，exit在调用系统_exit 之前，首先调用退出处理函数，刷新I/O缓冲，关闭文件描述符，最后调用_exit 退出进程；_exit（立即终止进程）不会输出缓冲区。&lt;/p&gt;
&lt;h2 id=&#34;待补充内容fork试验下printf失效的原理jyy某一课&#34;&gt;待补充内容：fork试验下printf失效的原理（jyy某一课&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/takashi77/article/details/108077328&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/takashi77/article/details/108077328&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;待补充内容常见io的缓冲分类&#34;&gt;待补充内容：常见IO的缓冲分类&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>C位段/位域(bit field)的排序原理</title>
        <link>https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/</link>
        <pubDate>Sun, 31 Jul 2022 09:18:16 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;p&gt;在做PA的过程中，发现这样的一段代码（模拟cpu的过程）：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 108; 
			flex-basis: 261px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/1.jpg&#34; data-size=&#34;719x661&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/1.jpg&#34;
			width=&#34;719&#34;
			height=&#34;661&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/1_hu1b1c0d6cd8681b981052b127d1d0b03a_89441_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/1_hu1b1c0d6cd8681b981052b127d1d0b03a_89441_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么问题就来了——为什么这里op位段会自动匹配前面的部分？（为什么不匹配后面） 和大端法有关系吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我怀疑就是小端定义，但不明白原因，于是开始了漫长的搜索&amp;hellip;..&lt;/p&gt;
&lt;p&gt;（直接看结果【不一定对，如果有疑问欢迎提出一起讨论，谢谢，我对编译器也不熟悉】）：&lt;br&gt;
我认为bit field的反向读取本质上也是由于计算机结构大小端实现的，编译器会先看机器是否有定义当然也可以改变定义，C语言标准中本身没有定义。）&lt;/p&gt;
&lt;p&gt;查到了也有人遇到类似的问题：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 130; 
			flex-basis: 312px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/2.jpg&#34; data-size=&#34;719x552&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/2.jpg&#34;
			width=&#34;719&#34;
			height=&#34;552&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/2_hu49bc3661a9dae00847946ab189ada07c_41752_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/2_hu49bc3661a9dae00847946ab189ada07c_41752_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在一个&lt;a class=&#34;link&#34; href=&#34;https://downloads.ti.com/docs/esd/SPRUI04C/bit-fields-stdz0545438.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;编译器的网站&lt;/a&gt;下，我发现了这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For big-endian mode, bit fields are packed into registers from most significant bit (MSB) to least significant bit (LSB) in the order in which they are defined. Bit fields are packed in memory from most significant byte (MSbyte) to least significant byte (LSbyte). For little-endian mode, bit fields are packed into registers from the LSB to the MSB in the order in which they are defined, and packed in memory from LSbyte to MSbyte.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那此时我们知道确实可能和大小端法是有关的,至少在C语言上是这样的。而C++上只给了说明，没有为什么，只给出了定义。&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 181; 
			flex-basis: 434px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/4.jpg&#34; data-size=&#34;1495x825&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/4.jpg&#34;
			width=&#34;1495&#34;
			height=&#34;825&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/4_hud4e476bde7169636115399407e5c21f1_125637_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/4_hud4e476bde7169636115399407e5c21f1_125637_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但问题又来了，一般机器中大小端看的是字节排序，但是我发的位域是对一个字节进行划分，一个字节内的bit也要遵循大小端排序吗？&lt;/p&gt;
&lt;p&gt;在查阅C标准中我发现原来这个位域排布是&lt;strong&gt;implementation-dependent&lt;/strong&gt;的（也就是说不管怎么样，首先位域排布是C标准没有明确定义的，取决于编译器）
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 204; 
			flex-basis: 489px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/5.jpg&#34; data-size=&#34;800x392&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/5.jpg&#34;
			width=&#34;800&#34;
			height=&#34;392&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/5_hu51ea6bb6635ccaa3ade16a364cf44263_42036_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/5_hu51ea6bb6635ccaa3ade16a364cf44263_42036_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 161; 
			flex-basis: 386px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/6.jpg&#34; data-size=&#34;1326x823&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/6.jpg&#34;
			width=&#34;1326&#34;
			height=&#34;823&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/6_hu8344c42327541e227437acab86c05c0c_137807_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/c%E4%BD%8D%E6%AE%B5/%E4%BD%8D%E5%9F%9Fbit-field%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86/images/6_hu8344c42327541e227437acab86c05c0c_137807_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Implementation dependent means that the standard says nothing about some occurance in C/C++ and leaves the choice up to the people who create compilers and operating systems. It means that what you use on one system/compiler may not work the same way on another, but the behavior is well defined for that particular implementation. For example, whether the result of a right bitwise shift on a signed variable results in a logical or arithmetic shift is implementation defined.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么我们的检索范围就可以缩小了，只要知道这个行为是不是编译器规定的即可。&lt;/p&gt;
&lt;p&gt;继续查看&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/onlinedocs/gccint/Bit-Fields.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCC的手册&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This represents a reference to a sign-extended bit-field contained or starting in loc (a memory or register reference). The bit-field is size bits wide and starts at bit pos. The compilation option BITS_BIG_ENDIAN says which end of the memory unit pos counts from.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案很接近了，我猜想只要知道BITS_BIG_ENDIAN是做什么的即可&lt;/p&gt;
&lt;p&gt;同样继续查看&lt;a class=&#34;link&#34; href=&#34;https://www.cse.unr.edu/~sushil/class/cs202/help/man/gcc-2.7.0/gcc_181.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GCC的手册StorageLayout&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;BITS_BIG_ENDIAN&lt;/strong&gt; &lt;br&gt;
Define this macro to have the value 1 if the most significant bit in a byte has the lowest number; otherwise define it to have the value zero. This means that bit-field instructions count from the most significant bit. If the machine has no bit-field instructions, then this must still be defined, but it doesn&amp;rsquo;t matter which value it is defined to. This macro need not be a constant. This macro does not affect the way structure fields are packed into bytes or words; that is controlled by BYTES_BIG_ENDIAN.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面出现了“If the machine has no bit-field instructions”，所以倾向于还是机器为准的。&lt;/p&gt;
&lt;p&gt;综上所述，我认为bit field的反向读取本质上也是由于计算机结构大小端实现的，编译器会先看机器是否有定义当然也可以改变定义，C语言标准中本身没有定义。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>利用笔记本电脑进行推流</title>
        <link>https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%B5%81/</link>
        <pubDate>Sun, 31 Jul 2022 08:32:51 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%B5%81/</guid>
        <description>&lt;p&gt;开始测试多线程的检测与英伟达板卡拉流压力测试，摄像头不够就用笔记本上。本文实现功能：&lt;/p&gt;
&lt;p&gt;将本地摄像头作为设备获取图像，用电脑建立服务器推送rtsp流并在其他同网段电脑下拉流。&lt;/p&gt;
&lt;p&gt;使用软件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FFmpeg(音视频编解码)&lt;/li&gt;
&lt;li&gt;EasyDarwin(流媒体服务器)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整参考以下文章即可：（记得推送IP要改成指定的一个IP，而不是127那指的是本地IP）&lt;/p&gt;
&lt;p&gt;如果不能连接，除了ping之外还要用curl ip:port或者telnet等检测，如果不行就把推流机的公共防火墙关闭。（之前我没有关闭防火墙是不能拉流的）&lt;/p&gt;
&lt;p&gt;如果用的是ubuntu拉流，还要看看是不是虚拟网卡有所影响（虚拟网卡的ip不同可能访问策略优先）&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/NOWSHUT/article/details/108540109&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;流媒体服务器配置与管理——使用FFmpeg推流到EasyDarwin中再通过VLC观看&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_30455365/article/details/97686191&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;EasyDarwin+ffmpeg进行PC(摄像头+麦克风)流媒体直播服务&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/fkbiubiubiu/article/details/124028614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ffmpeg&amp;ndash;使用命令+EasyDarwin推流笔记本摄像头&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/EasyDarwin/EasyDarwin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;EasyDarwin开源流媒体服务器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>防止stack overflow——内存地址杀毒</title>
        <link>https://sanbuphy.github.io/p/%E9%98%B2%E6%AD%A2stack-overflow%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%9D%80%E6%AF%92/</link>
        <pubDate>Sat, 30 Jul 2022 16:08:27 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E9%98%B2%E6%AD%A2stack-overflow%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%9D%80%E6%AF%92/</guid>
        <description>&lt;p&gt;提问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们有什么检测手段（编译器或者操作系统自带检测）能防止stack overflow嘛？或者说防止出栈超界&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中的内存地址规定好r但不给w能防止栈溢出覆盖吗？或者出栈超界&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内核也是程序，如果发生了溢出会直接panic，是不是崩溃本身就作为了一种保护机制？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;答：（详细参考蒋炎岩的这一课：&lt;a class=&#34;link&#34; href=&#34;http://jyywiki.cn/OS/2022/slides/8.slides#/5/5&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;并发 Bug 和应对&lt;/a&gt;）&lt;br&gt;
1、请看如下解释&lt;/p&gt;
&lt;p&gt;2、值得做实验尝试，因为理论上我们是能够访修改内存地址权限的（这里有个小知识，为什么栈的内存地址不仅可读可写还可【执行】呢？因为这代表着CPU能读取译码并执行）&lt;/p&gt;
&lt;p&gt;3、是的，详见panic()&lt;/p&gt;
&lt;h2 id=&#34;buffer-overrun-检查&#34;&gt;Buffer Overrun 检查&lt;/h2&gt;
&lt;p&gt;Canary (金丝雀) 对一氧化碳非常敏感   &lt;br&gt;
用生命预警矿井下的瓦斯泄露 (since 1911)&lt;/p&gt;
&lt;p&gt;计算机系统中的 canary    &lt;br&gt;
“牺牲” 一些内存单元，来预警 memory error 的发生  &lt;br&gt;
(程序运行时没有动物受到实质的伤害)&lt;/p&gt;
&lt;p&gt;比如把一些内存块“涂色”，如果发现它的“颜色被覆盖了”则说明有些保护的区域被访问了，这是错误的。（或者像PA那样的越界报错&lt;/p&gt;
&lt;h2 id=&#34;没用过-lintsanitizers&#34;&gt;没用过 lint/sanitizers？&lt;/h2&gt;
&lt;p&gt;具体请点击：&lt;a class=&#34;link&#34; href=&#34;http://jyywiki.cn/OS/2022/slides/8.slides#/5/5&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;并发 Bug 和应对&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AddressSanitizer (asan); (paper): 非法内存访问   &lt;br&gt;
Buffer (heap/stack/global) overflow, use-after-free, use-after-return, double-free, &amp;hellip;
Demo: uaf.c; kasan&lt;br&gt;
ThreadSanitizer (tsan): 数据竞争 &lt;br&gt;
Demo: fish.c, sum.c, peterson-barrier.c; ktsan&lt;br&gt;
MemorySanitizer (msan): 未初始化的读取&lt;br&gt;
UBSanitizer (ubsan): undefined behavior
Misaligned pointer, signed integer overflow, &amp;hellip; &lt;br&gt;
Kernel 会带着 -fwrapv 编译&lt;/p&gt;
</description>
        </item>
        <item>
        <title>有关fps计算——先有鸡还是先有蛋</title>
        <link>https://sanbuphy.github.io/p/%E6%9C%89%E5%85%B3fps%E8%AE%A1%E7%AE%97%E5%85%88%E6%9C%89%E9%B8%A1%E8%BF%98%E6%98%AF%E5%85%88%E6%9C%89%E8%9B%8B/</link>
        <pubDate>Sat, 30 Jul 2022 15:00:59 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%9C%89%E5%85%B3fps%E8%AE%A1%E7%AE%97%E5%85%88%E6%9C%89%E9%B8%A1%E8%BF%98%E6%98%AF%E5%85%88%E6%9C%89%E8%9B%8B/</guid>
        <description>&lt;p&gt;Q：众所周知，有时候我们读取本地的视频信息，他有可能不全（比如直播录像，某些文件内容被破坏或者干脆没有比如）这是一个先有鸡还是先有蛋的问题——你怎么确定fps是对的：是opencv算的（先有了时长）还是说本身fps就是内嵌视频输出的信息而且保证不变然后opencv用这个去计算总时长（因为fps都是基本可以整除的所以基本只能看到opencv给出0.01精确度的时长）&lt;/p&gt;
&lt;p&gt;A：求总帧数是最准的，根据总时长可以计算出FPS，这才是最准确的。&lt;/p&gt;
&lt;h2 id=&#34;其他问题如何看一个视频文件的容器封装格式&#34;&gt;其他问题：如何看一个视频文件的容器/封装格式？&lt;/h2&gt;
&lt;p&gt;答：使用xxd或其他可以看十六进制内容的程序直接打开视频文件，可以看到文件头里面有相关信息直接搜索相关内容（比如在未安装解码器的情况下，海康摄像头直播保存后的文件就是mpeg ps格式，有IMKH header）&lt;/p&gt;
</description>
        </item>
        <item>
        <title>shell脚本中变量无法读取空格的解决方法</title>
        <link>https://sanbuphy.github.io/p/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%8F%98%E9%87%8F%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
        <pubDate>Sat, 30 Jul 2022 09:29:20 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%8F%98%E9%87%8F%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
        <description>&lt;p&gt;有一天遇到需要实现shell脚本中变量连着括号一起读取，实现方法如下：&lt;/p&gt;
&lt;p&gt;如果不加双引号会翻车（你可以尝试去除不同的双引号看看效果）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SH&#34; data-lang=&#34;SH&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OLDIFS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;IFS
&lt;span class=&#34;c1&#34;&gt;#IFS=`echo -e &amp;#34;\n&amp;#34;`&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;DAFS DFFS&amp;#34;&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;f2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;f3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;f4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;f1&amp;#34;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$f2&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$f3&lt;/span&gt; f4&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; element in &lt;span class=&#34;s2&#34;&gt;&amp;#34;{array[@]}&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$element&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Reference：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.e-learn.cn/topic/1622359&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;shell脚本中oldIFS=$IFS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_36258720/article/details/116875596&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;linux获得包含空白字符的行,Shell如何遍历包含空格的文本详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Classes vs. Data Structures</title>
        <link>https://sanbuphy.github.io/p/classes-vs.-data-structures/</link>
        <pubDate>Sat, 25 Jun 2022 15:07:48 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/classes-vs.-data-structures/</guid>
        <description>&lt;p&gt;很多人根据数据结构的定义：&amp;ldquo;Data structure is a storage &lt;strong&gt;that is used to store and organize data&lt;/strong&gt;. It is a way of arranging data on a computer so that it can be accessed and updated efficiently. Depending on your requirement and project, it is important to choose the right data structure for your project. &amp;ldquo;觉得类当然也是一种数据结构，因为符合定义中提到的行为。然而，经过一番查资料外加看了下经典clean coder blog的描述，发现事情没这么简单。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 401; 
			flex-basis: 963px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/1.png&#34; data-size=&#34;775x193&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/1.png&#34;
			width=&#34;775&#34;
			height=&#34;193&#34;
			srcset=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/1_hu721536594cb69feaf0946e15168e3835_85501_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/classes-vs.-data-structures/image/1_hu721536594cb69feaf0946e15168e3835_85501_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 240; 
			flex-basis: 576px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/2.png&#34; data-size=&#34;975x406&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/2.png&#34;
			width=&#34;975&#34;
			height=&#34;406&#34;
			srcset=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/2_hu7a9605331c4838a932f61286f55bca42_106211_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/classes-vs.-data-structures/image/2_hu7a9605331c4838a932f61286f55bca42_106211_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;关键还是要看“ 看你抽象了多少、抽象层级、想要对外暴露什么”，并且分析的角度也不同。&lt;/p&gt;
&lt;p&gt;潜在的标准答案&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.cleancoder.com/uncle-bob/2019/06/16/ObjectsAndDataStructures.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Classes vs. Data Structures&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 216; 
			flex-basis: 520px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/cece.png&#34; data-size=&#34;884x408&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/cece.png&#34;
			width=&#34;884&#34;
			height=&#34;408&#34;
			srcset=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/cece_hu0e14e68d72201e41848fff6f8e91ec84_82119_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/classes-vs.-data-structures/image/cece_hu0e14e68d72201e41848fff6f8e91ec84_82119_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 374; 
			flex-basis: 897px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/image_zVyBRL2yt-.png&#34; data-size=&#34;1152x308&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/image_zVyBRL2yt-.png&#34;
			width=&#34;1152&#34;
			height=&#34;308&#34;
			srcset=&#34;https://sanbuphy.github.io/p/classes-vs.-data-structures/image/image_zVyBRL2yt-_hu329bd6553c90304bba1fb6658684e493_69399_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/classes-vs.-data-structures/image/image_zVyBRL2yt-_hu329bd6553c90304bba1fb6658684e493_69399_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>系统逃生舱的必要性</title>
        <link>https://sanbuphy.github.io/p/%E7%B3%BB%E7%BB%9F%E9%80%83%E7%94%9F%E8%88%B1%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</link>
        <pubDate>Sat, 25 Jun 2022 14:50:08 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E7%B3%BB%E7%BB%9F%E9%80%83%E7%94%9F%E8%88%B1%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</guid>
        <description>&lt;p&gt;作为几个月内重装过不下十次电脑的炸机猛男，强烈建议大家应该建立一个自己的“母盘”,储备好常见需要安装的软件（Anaconda、vscode等等）&lt;/p&gt;
&lt;p&gt;首先要保存一些常见的方法（当然可以类似鱼香ROS那样封装成为一个shell文件，自动换源并安装各种库）&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/wxd1233/article/details/121779276&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【环境配置】Ubuntu20.04如何更换国内源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.javashuo.com/article/p-tnnayazt-wb.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;git clone速度太慢的解决办法技巧分享&lt;/a&gt;
注：这里有个坑需要注意一下，当重置DNS的时候不要用文中方法（我是没有效用），你可以使用：&lt;code&gt;sudo service network-manager restart&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果你喜欢使用vim，建议你安装一键配置：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/438970816&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vimplus&lt;/a&gt; 不过它的安装需要git clone，建议科学上网否则会出现大面积失败（常见功能还是能同步上的，就是非常非常慢。。。。）&lt;/p&gt;
&lt;p&gt;TODO:有时间了根据鱼香ROS的一键shell做一个属于自己的一键shell&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linux中sudo、su、su-的那些事</title>
        <link>https://sanbuphy.github.io/p/linux%E4%B8%ADsudosusu-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
        <pubDate>Sat, 25 Jun 2022 14:18:55 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/linux%E4%B8%ADsudosusu-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
        <description>&lt;p&gt;su 的作用是切换当前用户，需要的是切换后账户的名字，即“su 账户名称”，如果后面不加账户时系统默认为root账户&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;su有两种用法： su Username/ su - Username，例子如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;su root  输入root密码后切换之root用户但是pwd目录不变&lt;/li&gt;
&lt;li&gt;su - root  输入root密码后切换之root用户但是pwd目录/root&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sudo 暂时切换到超级用户模式以执行超级用户权限，提示输入密码时该密码为当前用户的密码，而不是超级账户的密码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;sudo should be read as &amp;quot;su do&amp;quot;, that is, &amp;quot;switch user and do this command&amp;quot;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sudo -i root与sudo - root、sudo -i ,sudo - ，sudo root效果相同，提示输入密码时该密码为当前账户的密码  要求执行该命令的用户必须在sudoers中才可以&lt;/p&gt;
&lt;p&gt;sudo su 运行sudo命令给su命令提权，运行su命令&lt;/p&gt;
</description>
        </item>
        <item>
        <title>论文阅读：Vision GNN: An Image is Worth Graph of Nodes</title>
        <link>https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/</link>
        <pubDate>Sat, 18 Jun 2022 11:56:50 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/</guid>
        <description>&lt;img src="https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AfAe9Ctp8A.png" alt="Featured image of post 论文阅读：Vision GNN: An Image is Worth Graph of Nodes" /&gt;&lt;h1 id=&#34;vision-gnn-an-image-is-worth-graph-of-nodes&#34;&gt;Vision GNN: An Image is Worth Graph of Nodes&lt;/h1&gt;
&lt;p&gt;论文链接： &lt;a class=&#34;link&#34; href=&#34;https://arxiv.org/abs/2206.00272&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://arxiv.org/abs/2206.00272&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码开源链接（暂无）：https://github.com/sanbuphy/CV-Backbones&lt;/p&gt;
&lt;p&gt;最近都在关注GNN在图像识别上的应用，发现已经被Huawei Noah’s Ark Lab做完了。。。&lt;/p&gt;
&lt;p&gt;但我很好奇他们是怎么处理训练集本身（loss是什么），对拆分后图结构的标注应该也是一个相对大的工程，这点需要等开源后仔细研究（也许还需要多读几遍&lt;strong&gt;Graph Representation of Image&lt;/strong&gt;以及VIG BLock）&lt;/p&gt;
&lt;p&gt;该文基于图像的图表示（graph representation）提出了 vision graph neural network (ViG)。该文应该是首次将图神经网络用于视觉任务，同时取得很好的效果，在 ImageNet 分类任务上超过了 CNN (ResNet), MLP (CycleMLP) 和 transformer (Swin-T)&lt;/p&gt;
&lt;p&gt;These parts linked by joints naturally form a graph structure. By analyzing the graph.&lt;/p&gt;
&lt;p&gt;通过图结构分解，各部分间的连接显得更加紧密：（相似的语义能够互相跨区域关联）&lt;/p&gt;
&lt;p&gt;“we are able to recognize the human. &lt;strong&gt;Moreover, graph is a generalized data structure that grid and
sequence can be viewed as a special case of graph.&lt;/strong&gt; Viewing an image as a graph is more flexible and effective for visual perception”&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 247; 
			flex-basis: 594px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AfAe9Ctp8A.png&#34; data-size=&#34;1242x501&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AfAe9Ctp8A.png&#34;
			width=&#34;1242&#34;
			height=&#34;501&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AfAe9Ctp8A_hue88e56843ed6b1870c9b31fdca73cbf5_282168_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AfAe9Ctp8A_hue88e56843ed6b1870c9b31fdca73cbf5_282168_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 239; 
			flex-basis: 574px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_EhZIW3W81C.png&#34; data-size=&#34;1331x556&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_EhZIW3W81C.png&#34;
			width=&#34;1331&#34;
			height=&#34;556&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_EhZIW3W81C_hu7bcaa21a92ebac0349b32f3d9d01e8bf_217483_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_EhZIW3W81C_hu7bcaa21a92ebac0349b32f3d9d01e8bf_217483_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;vig-block&#34;&gt;VIG Block&lt;/h2&gt;
&lt;p&gt;Huawei Noah’s Ark Lab提出了一个特殊的VIG块结构，相比GCNs可以提高特征的多样性，减少因网络深度加强导致的特征减少现象。ViG 块是构成 ViG 网络的基本构建单元，其由Grapher 模块和 FFN 模块叠加而成的。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 166; 
			flex-basis: 400px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_xAuAFW6L1j.png&#34; data-size=&#34;1046x627&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_xAuAFW6L1j.png&#34;
			width=&#34;1046&#34;
			height=&#34;627&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_xAuAFW6L1j_hu710747dadc3c1417cdecf005033dbd08_182473_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_xAuAFW6L1j_hu710747dadc3c1417cdecf005033dbd08_182473_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 220; 
			flex-basis: 528px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_KfsF1D4RJY.png&#34; data-size=&#34;1063x483&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_KfsF1D4RJY.png&#34;
			width=&#34;1063&#34;
			height=&#34;483&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_KfsF1D4RJY_hu311ba6a7f922d66c2afc5c53c5eaa4de_108793_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_KfsF1D4RJY_hu311ba6a7f922d66c2afc5c53c5eaa4de_108793_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如何避免Feature diversity of nodes as layer changes 降低，即：&lt;/p&gt;
&lt;p&gt;“The over-smoothing phenomenon in deep GCNs  will decrease the distinctiveness of node features and lead to performance degradation for visual recognition,”&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 103; 
			flex-basis: 248px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_7gKSxA15lf.png&#34; data-size=&#34;427x412&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_7gKSxA15lf.png&#34;
			width=&#34;427&#34;
			height=&#34;412&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_7gKSxA15lf_hu0ca460f294028f2282e9d046d1289414_35588_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_7gKSxA15lf_hu0ca460f294028f2282e9d046d1289414_35588_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 423; 
			flex-basis: 1016px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_sBWzbMHeo3.png&#34; data-size=&#34;1042x246&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_sBWzbMHeo3.png&#34;
			width=&#34;1042&#34;
			height=&#34;246&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_sBWzbMHeo3_hu52c75e34672b78ce5664f3e1b6844d8a_73026_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_sBWzbMHeo3_hu52c75e34672b78ce5664f3e1b6844d8a_73026_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;他们还提供了两种结构用于构建VIG，分别为各向同性与金字塔型：&lt;/p&gt;
&lt;p&gt;”we build two kinds of network architectures for ViG, i.e., isotropic architecture and pyramid architecture“&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 248; 
			flex-basis: 595px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_qHc-Hk-d9c.png&#34; data-size=&#34;1033x416&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_qHc-Hk-d9c.png&#34;
			width=&#34;1033&#34;
			height=&#34;416&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_qHc-Hk-d9c_huca6f27d18180486f94cc91a7e939d469_110607_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_qHc-Hk-d9c_huca6f27d18180486f94cc91a7e939d469_110607_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 126; 
			flex-basis: 303px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_poMH8ITmnn.png&#34; data-size=&#34;772x610&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_poMH8ITmnn.png&#34;
			width=&#34;772&#34;
			height=&#34;610&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_poMH8ITmnn_hu0d492a778fc3612d909754a229a5ba56_134865_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_poMH8ITmnn_hu0d492a778fc3612d909754a229a5ba56_134865_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 364; 
			flex-basis: 874px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_9-mM5JNGud.png&#34; data-size=&#34;1316x361&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_9-mM5JNGud.png&#34;
			width=&#34;1316&#34;
			height=&#34;361&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_9-mM5JNGud_hudfa5be39ab44ec4ac06584e86227b3c0_101816_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_9-mM5JNGud_hudfa5be39ab44ec4ac06584e86227b3c0_101816_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;验证数据集：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 547; 
			flex-basis: 1314px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wBU5LSPrC-.png&#34; data-size=&#34;1325x242&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wBU5LSPrC-.png&#34;
			width=&#34;1325&#34;
			height=&#34;242&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wBU5LSPrC-_hu6ff8641e22524f0064049f24627d8a3b_101062_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wBU5LSPrC-_hu6ff8641e22524f0064049f24627d8a3b_101062_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跑数据集的设置：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 177; 
			flex-basis: 425px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_zS0gG4eIxu.png&#34; data-size=&#34;1297x732&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_zS0gG4eIxu.png&#34;
			width=&#34;1297&#34;
			height=&#34;732&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_zS0gG4eIxu_hu3d3688ce73f08033f56fc2dc8c5fab5e_274069_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_zS0gG4eIxu_hu3d3688ce73f08033f56fc2dc8c5fab5e_274069_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后结果展示：&lt;/p&gt;
&lt;p&gt;Isotropic ViG：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 207; 
			flex-basis: 497px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_Js5lSPEJNA.png&#34; data-size=&#34;1100x531&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_Js5lSPEJNA.png&#34;
			width=&#34;1100&#34;
			height=&#34;531&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_Js5lSPEJNA_hu8cb2c90540bd25dfb4548e1542ac8a2e_119302_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_Js5lSPEJNA_hu8cb2c90540bd25dfb4548e1542ac8a2e_119302_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Pyramid ViG&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 94; 
			flex-basis: 227px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AluQut1z-C.png&#34; data-size=&#34;757x797&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AluQut1z-C.png&#34;
			width=&#34;757&#34;
			height=&#34;797&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AluQut1z-C_hu499fe3a159da6b0a8c8ebc455adc2238_208815_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_AluQut1z-C_hu499fe3a159da6b0a8c8ebc455adc2238_208815_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在目标检测的效果：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 201; 
			flex-basis: 482px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_jenq3F8_Mr.png&#34; data-size=&#34;1076x535&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_jenq3F8_Mr.png&#34;
			width=&#34;1076&#34;
			height=&#34;535&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_jenq3F8_Mr_hu21625e84881a2b19fb792c678aad7401_153557_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_jenq3F8_Mr_hu21625e84881a2b19fb792c678aad7401_153557_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Ablation Study测试的结果（关闭一些配件）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 389; 
			flex-basis: 935px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wvgTM-8Sfn.png&#34; data-size=&#34;1056x271&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wvgTM-8Sfn.png&#34;
			width=&#34;1056&#34;
			height=&#34;271&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wvgTM-8Sfn_hubba24396e9be55c3a9bb2f5e668ca83a_32960_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_wvgTM-8Sfn_hubba24396e9be55c3a9bb2f5e668ca83a_32960_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;过程的可视化：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 150; 
			flex-basis: 361px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_na_2SQ1yDV.png&#34; data-size=&#34;1036x687&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_na_2SQ1yDV.png&#34;
			width=&#34;1036&#34;
			height=&#34;687&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_na_2SQ1yDV_hue1475e7fd66ae20ed5497fc126270cdd_760405_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_na_2SQ1yDV_hue1475e7fd66ae20ed5497fc126270cdd_760405_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
通过上图可以看到，浅层网络的跨区域图只是结合了颜色或形状等一些表象语义；&lt;/p&gt;
&lt;p&gt;而深层网络的图结构则更加专注于细化特征本身“比如鱼就是鱼，人就是人”&lt;/p&gt;
&lt;p&gt;The pentagram is the center node, and the nodes with the same color are its neighbors&lt;/p&gt;
&lt;p&gt;Two center nodes are visualized as drawing all the edges will be messy.&lt;/p&gt;
&lt;p&gt;We can observe that our model can select the
&lt;strong&gt;content-related nodes&lt;/strong&gt; as the first order neighbors,&lt;/p&gt;
&lt;p&gt;In the shallow layer, the neighbor nodes tend to be selected based on low-level and local features( such as color and texture)&lt;/p&gt;
&lt;p&gt;In the deep layer, the neighbors of the center nodes are more semantic and belong to the same categor.&lt;/p&gt;
&lt;p&gt;以下是伪代码：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 237; 
			flex-basis: 570px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_v8dCLn3A0L.png&#34; data-size=&#34;1323x557&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_v8dCLn3A0L.png&#34;
			width=&#34;1323&#34;
			height=&#34;557&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_v8dCLn3A0L_hu1fac75b9c6c521c1e304d38499c8c552_121731_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_v8dCLn3A0L_hu1fac75b9c6c521c1e304d38499c8c552_121731_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 195; 
			flex-basis: 470px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_VWvyfi4fD0.png&#34; data-size=&#34;1101x562&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_VWvyfi4fD0.png&#34;
			width=&#34;1101&#34;
			height=&#34;562&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_VWvyfi4fD0_hu8c40a0442b051ea69d084f5e0a0bbb76_102894_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_VWvyfi4fD0_hu8c40a0442b051ea69d084f5e0a0bbb76_102894_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 340; 
			flex-basis: 816px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_s4RfDBf05P.png&#34; data-size=&#34;1106x325&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_s4RfDBf05P.png&#34;
			width=&#34;1106&#34;
			height=&#34;325&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_s4RfDBf05P_hu202182aab60aa5b1b2eec9035a49ea37_64972_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BBvision-gnn-an-image-is-worth-graph-of-nodes/image/image_s4RfDBf05P_hu202182aab60aa5b1b2eec9035a49ea37_64972_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>NJU计算机课程基础实验 PA1笔记</title>
        <link>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa1%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 11 Jun 2022 22:50:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa1%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;p&gt;PA0比较简单，就不再重复说明。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 144; 
			flex-basis: 345px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa1%E7%AC%94%E8%AE%B0/pa1.png&#34; data-size=&#34;775x538&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa1%E7%AC%94%E8%AE%B0/pa1.png&#34;
			width=&#34;775&#34;
			height=&#34;538&#34;
			srcset=&#34;https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa1%E7%AC%94%E8%AE%B0/pa1_hu6de49b169942b2f356730423a411cfeb_82146_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa1%E7%AC%94%E8%AE%B0/pa1_hu6de49b169942b2f356730423a411cfeb_82146_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;PA1的任务&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;PA1的任务&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从图上可以知道，我们的关键是要从Mon读取Mem和Reg的信息&lt;/p&gt;
&lt;h2 id=&#34;pa1rtfsc&#34;&gt;PA1.RTFSC&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apt-get install ccache
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;which gcc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以把gcc编译结果缓存，可跳过重复的编译过程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make -nB&lt;/code&gt;, 它会让 &lt;code&gt;make&lt;/code&gt;程序以&amp;quot;只输出命令但不执行&amp;quot;的方式强制构建目标&lt;/p&gt;
&lt;p&gt;llvm推荐用PA里面说到的11先试试看，实在不行想要升级可参考：https://blog.csdn.net/weixin_44200757/article/details/122725577&lt;/p&gt;
&lt;p&gt;最简单的计算机称为&amp;quot;图灵机&amp;quot;(Turing Machine, TRM)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构上, TRM有存储器, 有PC, 有寄存器, 有加法器&lt;/li&gt;
&lt;li&gt;工作方式上, TRM不断地重复以下过程: 从PC指示的存储器位置取出指令, 执行指令, 然后更新PC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BIOS是固化在ROM/Flash中的, 它们都是非易失性的存储介质, BIOS中的内容不会因为断电而丢失.&lt;/p&gt;
&lt;p&gt;因此在真实的计算机系统中, 计算机启动后首先会把控制权交给BIOS, BIOS经过一系列初始化工作之后, 再从磁盘中将有意义的程序读入内存中执行. 对这个过程的模拟需要了解很多超出本课程范围的细节, 我们在PA中做了简化: 采取约定的方式让CPU直接从约定的内存位置开始执行.&lt;/p&gt;
&lt;p&gt;在GNU/Linux中, 你可以很容易得知操作系统在背后做了些什么. 键入 &lt;code&gt;sudo dmesg&lt;/code&gt;, 就可以输出操作系统的启动日志, 操作系统的行为一览无余.&lt;/p&gt;
&lt;p&gt;你需要结合PA1 RTFSC内容来NEMU的框架代码.&lt;/p&gt;
&lt;p&gt;如果你不知道&amp;quot;怎么才算是看懂了框架代码&amp;quot;, 你可以先尝试进行后面的任务. 如果发现不知道如何下手, 再回来仔细阅读这一节&lt;/p&gt;
&lt;h3 id=&#34;cpu&#34;&gt;cpu&lt;/h3&gt;
&lt;p&gt;先驱为CPU创造了一个特殊的计数器, 叫&amp;quot;程序计数器&amp;quot;(Program Counter, PC). 在x86中, 它有一个特殊的名字, 叫 &lt;code&gt;EIP&lt;/code&gt;(Extended Instruction Pointer).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;从&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PC指示的存储器位置取出指令&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;执行指令&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;更新&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;第一项工作就是将一个内置的客户程序读入到内存中&#34;&gt;第一项工作就是将一个内置的客户程序读入到内存中&lt;/h3&gt;
&lt;p&gt;先打开：&lt;code&gt;nemu/src/isa/$ISA/init.c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;monitor会调用 &lt;code&gt;init_isa()&lt;/code&gt;函数(在 &lt;code&gt;nemu/src/isa/$ISA/init.c&lt;/code&gt;中定义), 来进行一些ISA相关的初始化工作.&lt;/p&gt;
&lt;p&gt;第一项工作就是将一个内置的客户程序读入到内存中.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存是什么？C语言中我们就很自然地使用一个 &lt;code&gt;uint8_t&lt;/code&gt;类型的数组来对内存进行模拟. NEMU默认为客户计算机提供128MB的物理内存(见 &lt;code&gt;nemu/src/memory/paddr.c&lt;/code&gt;中定义的 &lt;code&gt;pmem&lt;/code&gt;(如果找不到看看.h内有128*1024*1024)&lt;/li&gt;
&lt;li&gt;需要将客户程序读入到内存的什么位置？我们需要一种方式让客户计算机的CPU知道客户程序的位置. 我们采取一种最简单的方式: 约定. 具体地, 我们让monitor直接把客户程序读入到一个固定的内存位置&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;init_isa的第二项任务是初始化寄存器&#34;&gt;&lt;code&gt;init_isa()&lt;/code&gt;的第二项任务是初始化寄存器&lt;/h3&gt;
&lt;p&gt;CPU中, 寄存器是一个结构化特征较强的存储部件, 在C语言中我们就很自然地使用相应的结构体来描述CPU的寄存器结构. 不同ISA的寄存器结构也各不相同, 为此我们把寄存器结构体 &lt;code&gt;CPU_state&lt;/code&gt;的定义放在 &lt;code&gt;nemu/src/isa/$ISA/include/isa-def.h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化寄存器的一个重要工作就是设置 &lt;code&gt;cpu.pc&lt;/code&gt;的初值, 我们需要将它设置成刚才加载客户程序的内存位置, 这样就可以让CPU从我们约定的内存位置开始执行客户程序了. 对于mips32和riscv32, 它们的0号寄存器总是存放 &lt;code&gt;0&lt;/code&gt;, 因此我们也需要对其进行初始化.&lt;/p&gt;
&lt;p&gt;CONFIG_MBASE：物理内存起始地址    RESET_VECTOR：客户程序读入的固定位置&lt;/p&gt;
&lt;h3 id=&#34;物理内存的起始地址&#34;&gt;物理内存的起始地址&lt;/h3&gt;
&lt;p&gt;x86的物理内存是从0开始编址的, 但对于一些ISA来说却不是这样, 例如mips32和riscv32的物理地址均从 &lt;code&gt;0x80000000&lt;/code&gt;开始. 因此对于mips32和riscv32, 其 &lt;code&gt;CONFIG_MBASE&lt;/code&gt;将会被定义成 &lt;code&gt;0x80000000&lt;/code&gt;. 将来CPU访问内存时, 我们会将CPU将要访问的内存地址映射到 &lt;code&gt;pmem&lt;/code&gt;中的相应偏移位置, 这是通过 &lt;code&gt;nemu/src/memory/paddr.c&lt;/code&gt;中的 &lt;code&gt;guest_to_host()&lt;/code&gt;函数实现的. 例如如果mips32的CPU打算访问内存地址 &lt;code&gt;0x80000000&lt;/code&gt;, 我们会让它最终访问 &lt;code&gt;pmem[0]&lt;/code&gt;, 从而可以正确访问客户程序的第一条指令. 这种机制有一个专门的名字, 叫地址映射, 在后续的PA中我们还会再遇到它.x86的物理内存是从0开始编址的, 但对于一些ISA来说却不是这样, 例如mips32和riscv32的物理地址均从0x80000000开始. 因此对于mips32和riscv32, 其CONFIG_MBASE将会被定义成0x8000000&lt;/p&gt;
&lt;p&gt;Monitor读入客户程序并对寄存器进行初始化后, 这时内存的布局如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;pmem:

CONFIG_MBASE      RESET_VECTOR
      |                 |
      v                 v
      -----------------------------------------------
      |                 |                  |
      |                 |    guest prog    |
      |                 |                  |
      -----------------------------------------------
                        ^
                        |
                       pc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;NEMU返回到 &lt;code&gt;init_monitor()&lt;/code&gt;函数中, 继续调用 &lt;code&gt;load_img()&lt;/code&gt;函数 (在 &lt;code&gt;nemu/src/monitor/monitor.c&lt;/code&gt;中定义). 这个函数会将一个有意义的客户程序从&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Disk_image&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;镜像文件&lt;/a&gt;读入到内存, 覆盖刚才的内置客户程序.&lt;/p&gt;
&lt;p&gt;如果运行NEMU的时候没有给出这个参数, NEMU将会运行内置客户程序.&lt;/p&gt;
&lt;h4 id=&#34;思考题1-1参数&#34;&gt;思考题1：-1参数&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;cmd_c()&lt;/code&gt;函数中, 调用 &lt;code&gt;cpu_exec()&lt;/code&gt;的时候传入了参数 &lt;code&gt;-1&lt;/code&gt;, 你知道这是什么意思吗?&lt;/p&gt;
&lt;p&gt;答:参数为uint64,无符号64位整型，-1表示取最大值（整数用补码表示，负数的补码为=反码+1，正数的补码就是其原码；负数的反码为符号位不变，数值位按位&lt;a class=&#34;link&#34; href=&#34;https://so.csdn.net/so/search?q=%E5%8F%96%E5%8F%8D&amp;amp;spm=1001.2101.3001.7020&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;取反&lt;/a&gt;。-1的原码：1,000&amp;hellip;0001，因此，-1的补码为1,111&amp;hellip;111。）&lt;/p&gt;
&lt;h4 id=&#34;思考题2谁来指示程序的结束&#34;&gt;思考题2：谁来指示程序的结束?&lt;/h4&gt;
&lt;p&gt;在程序设计课上老师告诉你, 当程序执行到 &lt;code&gt;main()&lt;/code&gt;函数返回处的时候, 程序就退出了, 你对此深信不疑. 但你是否怀疑过, 凭什么程序执行到 &lt;code&gt;main()&lt;/code&gt;函数的返回处就结束了?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main()函数结束，如何再执行代码？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;strong&gt;atexit()&lt;/strong&gt; 函数，来执行相关的“ 清理 ”工作The function pointed by func is automatically called without arguments when the program terminates normally.A zero value is returned if the function was successfully registered.
If it failed, a non-zero value is returned.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几种退出函数：https://blog.csdn.net/jinchaoh/article/details/50340743&lt;/p&gt;
&lt;p&gt;exit()函数用于在程序运行的过程中随时结束程序，其原型为：
void exit(int state);
exit的参数state是返回给操作系统或当前程序的调用程序，返回0表示程序正常结束，非0表示程序非正常结束。main函数结束时也会隐式地调用exit()函数。exit()函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。&lt;/p&gt;
&lt;p&gt;atexit() 用于注册终止函数(即main执行结束后调用的函数)，其原型为：
int atexit(void (*function)(void));
很多时候我们需要在程序退出的时候做一些诸如释放资源的操作，但程序退出的方式有很多种，比如main()函数运行结束、在程序的某个地方用exit()结束程序、用户通过Ctrl+C或Ctrl+break操作来终止程序等等，因此需要有一种与程序退出方式无关的方法来进行程序退出时的必要处理。方法就是用atexit()函数来注册程序正常终止时要被调用的函数。&lt;/p&gt;
&lt;h4 id=&#34;额外思考main是怎么开始的&#34;&gt;额外思考：main是怎么开始的?&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://wen00072.github.io/blog/2015/02/14/main-linux-whos-going-to-call-in-c-language/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://wen00072.github.io/blog/2015/02/14/main-linux-whos-going-to-call-in-c-language/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;三个对调试有用的宏在-nemuincludedebugh中定义&#34;&gt;三个对调试有用的宏(在 &lt;code&gt;nemu/include/debug.h&lt;/code&gt;中定义)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Log()&lt;/code&gt;是 &lt;code&gt;printf()&lt;/code&gt;的升级版, 专门用来输出调试信息, 同时还会输出使用 &lt;code&gt;Log()&lt;/code&gt;所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置（非常好用！！！！非常推荐）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Assert()&lt;/code&gt;是 &lt;code&gt;assert()&lt;/code&gt;的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;panic()&lt;/code&gt;用于输出信息并结束程序, 相当于无条件的assertion fail&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内存通过在 &lt;code&gt;nemu/src/memory/paddr.c&lt;/code&gt;中定义的大数组 &lt;code&gt;pmem&lt;/code&gt;来模拟.&lt;/p&gt;
&lt;p&gt;在客户程序运行的过程中, 总是使用 &lt;code&gt;vaddr_read()&lt;/code&gt;和 &lt;code&gt;vaddr_write()&lt;/code&gt; (在 &lt;code&gt;nemu/src/memory/vaddr.c&lt;/code&gt;中定义)来访问模拟的内存.（这里已经告诉了你下面涉及问题的答案！）&lt;/p&gt;
&lt;p&gt;vaddr, paddr分别代表虚拟地址和物理地址.&lt;/p&gt;
&lt;h2 id=&#34;pa1简易调试器&#34;&gt;PA1.简易调试器&lt;/h2&gt;
&lt;p&gt;简易调试器(Simple Debugger, sdb)是NEMU中一项非常重要的基础设施.&lt;/p&gt;
&lt;p&gt;我们知道NEMU是一个用来执行其它客户程序的程序, 这意味着, NEMU可以随时了解客户程序执行的所有信息. 然而这些信息对外面的调试器(例如GDB)来说, 是不容易获取的. 例如在通过GDB调试NEMU的时候, 你将很难在NEMU中运行的客户程序中设置断点, 但对于NEMU来说, 这是一件不太困难的事情.&lt;/p&gt;
&lt;p&gt;为了提高调试的效率, 同时也作为熟悉框架代码的练习, 我们需要在monitor中实现一个具有如下功能的简易调试器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 命令已实现&lt;/li&gt;
&lt;li&gt;(2) 与GDB相比, 我们在这里做了简化, 更改了命令的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;使用举例&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;帮助(1)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;help&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;help&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印命令的帮助信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;继续运行(1)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;继续运行被暂停的程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;退出(1)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;退出NEMU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单步执行&lt;/td&gt;
&lt;td&gt;&lt;code&gt;si [N]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;si 10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;让程序单步执行&lt;code&gt;N&lt;/code&gt;条指令后暂停执行,``当 &lt;code&gt;N&lt;/code&gt;没有给出时, 缺省为 &lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;打印程序状态&lt;/td&gt;
&lt;td&gt;&lt;code&gt;info SUBCMD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;info rinfo w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印寄存器状态``打印监视点信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;扫描内存(2)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x N EXPR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x 10 $esp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;求出表达式&lt;code&gt;EXPR&lt;/code&gt;的值, 将结果作为起始内存``地址, 以十六进制形式输出连续的 &lt;code&gt;N&lt;/code&gt;个4字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表达式求值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;p EXPR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;p $eax + 1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;求出表达式&lt;code&gt;EXPR&lt;/code&gt;的值, &lt;code&gt;EXPR&lt;/code&gt;支持的``运算请见&lt;a class=&#34;link&#34; href=&#34;https://nju-projectn.github.io/ics-pa-gitbook/ics2021/1.6.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;调试中的表达式求值&lt;/a&gt;小节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置监视点&lt;/td&gt;
&lt;td&gt;&lt;code&gt;w EXPR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;w *0x2000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当表达式&lt;code&gt;EXPR&lt;/code&gt;的值发生变化时, 暂停程序执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除监视点&lt;/td&gt;
&lt;td&gt;&lt;code&gt;d N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;d 2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除序号为&lt;code&gt;N&lt;/code&gt;的监视点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;你需要在实现一个功能之后对它进行充分的测试. 随着时间的推移, 发现同一个bug所需要的代价会越来越大.&lt;/p&gt;
&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;p&gt;从键盘上读入命令后, NEMU需要解析该命令——利用框架代码调用单步执行——打印寄存器——扫描内存&lt;/p&gt;
&lt;p&gt;（NEMU默认会把单步执行的指令打印出来(这里面埋了一些坑, 你需要RTFSC看看指令是在哪里被打印的), 这样你就可以验证单步执行的效果了.）&lt;/p&gt;
&lt;h3 id=&#34;读入并解析&#34;&gt;读入并解析&lt;/h3&gt;
&lt;p&gt;NEMU通过 &lt;code&gt;readline&lt;/code&gt;库与用户交互&lt;/p&gt;
&lt;p&gt;解析命令的工作是通过一系列的字符串处理函数来完成的, 例如框架代码中的 &lt;code&gt;strtok()&lt;/code&gt;、&lt;code&gt;strlen()&lt;/code&gt;, &lt;code&gt;strcpy()&lt;/code&gt;、sscanf()等&lt;/p&gt;
&lt;p&gt;readline：（使用了系统库要记得-lreadline链接）&lt;/p&gt;
&lt;p&gt;strtok:要注意两个参数，第二个参数会被他替换成\0，第一个字符串读出后接下来的第一个参数就要用NULL替换&lt;/p&gt;
&lt;p&gt;strtok不能保证字符串的完整，要保持字符串的完整可以用strchr和sscanf的组合。&lt;/p&gt;
&lt;h3 id=&#34;表达式的实现&#34;&gt;表达式的实现&lt;/h3&gt;
&lt;p&gt;关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常见的operator需要匹配&lt;/li&gt;
&lt;li&gt;留下两个冗余给指针解引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我花了几天重构了（相当于重写）了一遍求解表达式的逻辑。大概消耗了一周。&lt;/p&gt;
&lt;p&gt;第一个难点在于如何优雅的把字符串保留到token[].str中，你需要搞明白什么是结构体数组与指针（之后的静态链表也会用到！&lt;/p&gt;
&lt;p&gt;第二个难点在于op匹配的过程中，需要如何给出op（优先级排列），这里参考了一下别人的算法（我自己的bug很多）采用了一个设计大到小覆盖的方法，能保证保留“最大”标识的符号作为op，（你从尾部开始扫描也行，换个方向覆盖符号罢了）。&lt;/p&gt;
&lt;p&gt;第三个难点在于如何优雅的检查括号，如果你只在p和q边界检查，容易出现(1+1)+(1+1)的错误，我尝试了很多很多办法，最后用了一个i+-并且判断会不会“还没读完i就变0了”来避免这个错误。&lt;/p&gt;
&lt;p&gt;第四个难点在于负数和指针的拦截，你需要在别的地方进行拦截，检查之前的符号。&lt;/p&gt;
&lt;h3 id=&#34;监视点的实现&#34;&gt;监视点的实现&lt;/h3&gt;
&lt;p&gt;监视点：实际上这个是一个“能改大小”的静态链表，不需要malloc，熟悉了链表操作实际上不难（我花时间手写了一下动态链表再看这儿结构体数组一开始还有点诧异）&lt;/p&gt;
&lt;p&gt;另一个关键是要理解static的奥义所在，实际上都是为了将这个链表隔离在该作用范围内不要被其他文件访问，所以所有的操作都要在sdb和watchpoint里进行，不要对外暴露变量，只需要暴露函数能够使得他被调用即可。这也是程序隔离的重要性所在（一开始我觉得麻烦，但减小耦合的角度来说这非常重要，要做到职责分离），所有的数据结构访问和操作都在链表的C文件中执行，也不要对外暴露；而CPU每次执行完后的检查也是通过调用链表C的头文件进行函数执行（直接执行），做到职责分离和隔离。至于包一个宏，这个通过RTFC多多尝试即可得到结果。&lt;/p&gt;
&lt;h2 id=&#34;reference-重点&#34;&gt;Reference 【重点】&lt;/h2&gt;
&lt;p&gt;ps:最好可以掌握一些常用的C字符串标准库，如strcpy  strnpy&lt;/p&gt;
&lt;h3 id=&#34;gdb-layout窗口&#34;&gt;gdb layout窗口&lt;/h3&gt;
&lt;p&gt;(其实也可以直接gdb xxx -tui)&lt;/p&gt;
&lt;p&gt;layout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：
layout src：显示源代码窗口
layout asm：显示汇编窗口
layout regs：显示源代码/汇编和寄存器窗口
layout split：显示源代码和汇编窗口
layout next：显示下一个layout
layout prev：显示上一个layout
Ctrl + L：刷新窗口
Ctrl + x，再按1：单窗口模式，显示一个窗口
Ctrl + x，再按2：双窗口模式，显示两个窗口
Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。&lt;/p&gt;
&lt;h3 id=&#34;gdb快捷键&#34;&gt;GDB快捷键&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wizardforcel.gitbooks.io/100-gdb-tips/content/step-and-next-function.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;100个gdb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;常见的命令：&lt;/p&gt;
&lt;p&gt;记住run和start的区别！&lt;/p&gt;
&lt;p&gt;如何打印变量的值？(print var)&lt;/p&gt;
&lt;p&gt;如何打印变量的地址？(print &amp;amp;var)
如何打印地址的数据值？(print *address)
如何查看当前运行的文件和行？(backtrace)
如何查看指定文件的代码？(list file:N)
如果程序是多文件的，怎样定位到指定文件的指定行或者函数？(list file:N)
如果循环次数很多，如何执行完当前的循环？(until)&lt;/p&gt;
&lt;p&gt;如何跳过不感兴趣的函数（n）&lt;/p&gt;
&lt;p&gt;gdb中跳入函数的命令是step，相当于Visual Studio中的快捷键F11，
gdb中跳出函数的命令是finish，相当于Visual Studio中的快捷键Shift+F11，函数完整执行后返回&lt;/p&gt;
&lt;p&gt;gdb中还有一个直接返回的命令是return，它会跳过当前函数后面的语句直接返回，返回值可以自定义，紧跟在return命令后面即可&lt;/p&gt;
&lt;p&gt;进阶命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何打印内存？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gdb中使用“&lt;code&gt;x&lt;/code&gt;”命令来打印内存的值，格式为“&lt;code&gt;x/nfu addr&lt;/code&gt;”。含义为以 &lt;code&gt;f&lt;/code&gt;格式打印从 &lt;code&gt;addr&lt;/code&gt;开始的 &lt;code&gt;n&lt;/code&gt;个长度单元为 &lt;code&gt;u&lt;/code&gt;的内存值。参数具体含义如下：
a）n：输出单元的个数。
b）f：是输出格式。比如 &lt;code&gt;x&lt;/code&gt;是以16进制形式输出，&lt;code&gt;o&lt;/code&gt;是以8进制形式输出,等等。
c）u：标明一个单元的长度。&lt;code&gt;b&lt;/code&gt;是一个 &lt;code&gt;byte&lt;/code&gt;，&lt;code&gt;h&lt;/code&gt;是两个 &lt;code&gt;byte&lt;/code&gt;（halfword），&lt;code&gt;w&lt;/code&gt;是四个 &lt;code&gt;byte&lt;/code&gt;（word），&lt;code&gt;g&lt;/code&gt;是八个 &lt;code&gt;byte&lt;/code&gt;（giant word）&lt;/p&gt;
&lt;p&gt;比如：以16进制格式打印数组前 &lt;code&gt;a&lt;/code&gt;16个byte的值： x/16xb a&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何打印堆栈信息？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用gdb调试程序时，可以使用“&lt;code&gt;i frame&lt;/code&gt;”命令（&lt;code&gt;i&lt;/code&gt;是 &lt;code&gt;info&lt;/code&gt;命令缩写）显示函数堆栈帧信息。&lt;/p&gt;
&lt;h3 id=&#34;参考文档&#34;&gt;参考文档&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;余子濠  从mov指令到仙剑：通过NEMU构建简单完整的计算机系统&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>c语言编译过程简介</title>
        <link>https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Wed, 18 May 2022 13:24:37 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</guid>
        <description>&lt;p&gt;如果想要了解更仔细地过程，建议看csapp或者《程序员的自我修养》&lt;/p&gt;
&lt;h2 id=&#34;最直接的编译过程&#34;&gt;最直接的编译过程&lt;/h2&gt;
&lt;p&gt;初始.c文件通过预处理器、编译器、汇编器、链接器得到最后的可执行程序（比如linux系统下的a.out）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 580; 
			flex-basis: 1392px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5lokPRa2gQ.png&#34; data-size=&#34;702x121&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5lokPRa2gQ.png&#34;
			width=&#34;702&#34;
			height=&#34;121&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5lokPRa2gQ_hu6ef559bff2296e82b1d747cbc7b9b303_75989_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5lokPRa2gQ_hu6ef559bff2296e82b1d747cbc7b9b303_75989_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;hello.i：hello.c经预处理生成的文本文件。&lt;/p&gt;
&lt;p&gt;hello.s：hello.i经编译生成的汇编语言文件。&lt;/p&gt;
&lt;p&gt;hello.o：hello.s经汇编生成的可重定位目标文件。&lt;/p&gt;
&lt;p&gt;hello：hello.o经链接生成的可执行目标文件。&lt;/p&gt;
&lt;p&gt;在经过不同处理阶段的程序到底是怎么样的呢？让我们用gcc分步调试即可：&lt;/p&gt;
&lt;p&gt;你可以使用这个命令获得所有输出：&lt;code&gt;gcc -save-temps main.c –o main&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;一预处理过程&#34;&gt;一、预处理过程&lt;/h2&gt;
&lt;p&gt;在预处理阶段，编译器主要完成了这几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;去掉所有的注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;展开所有的宏定义（也就是做字符替换）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入#include文件的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理所有的条件编译（形如#ifndef的语句，详见 &lt;a class=&#34;link&#34; href=&#34;https://docs.microsoft.com/zh-cn/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=msvc-170&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;条件编译&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想要获得.i的预处理文件，需要输入 &lt;code&gt;gcc -E main.c -o main.i&lt;/code&gt;  ，&lt;code&gt;-E&lt;/code&gt;选项保留预处理器的输出文件，但默认输出到标准输出流，你需要&lt;code&gt;-o&lt;/code&gt;指定一个输出文件。&lt;/p&gt;
&lt;p&gt;因为头文件可能相当大，如果源文件包括了多个头文件，那么它的预处理器输出可能会庞杂难读。使用&lt;code&gt;-C&lt;/code&gt;选项会很有帮助，这个选项可以阻止预处理器删除源文件和头文件中的注释：&lt;code&gt;gcc -E -C main.c -o main.c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;测试效果如下，我们能确实看到上述几件事情的发生：（可以使用&lt;code&gt;cat main.i&lt;/code&gt;或者&lt;code&gt;vim main.i&lt;/code&gt;查看结果）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 99; 
			flex-basis: 238px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_-Ur0teQruS.png&#34; data-size=&#34;831x837&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_-Ur0teQruS.png&#34;
			width=&#34;831&#34;
			height=&#34;837&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_-Ur0teQruS_hu1ea939da5f8587b60a3db6abf686e2b0_83722_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_-Ur0teQruS_hu1ea939da5f8587b60a3db6abf686e2b0_83722_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有关预编译，如果想知道更多信息，可以参考 &lt;a class=&#34;link&#34; href=&#34;https://docs.microsoft.com/zh-cn/cpp/preprocessor/preprocessor-directives?view=msvc-170&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;预编译器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准输出流默认是显示器，但理论上通过控制stdout的实现来源dup可以修改成文件或者其他可写空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二编译过程&#34;&gt;二、编译过程&lt;/h2&gt;
&lt;p&gt;编译能够将hello.i 文件编译生成汇编语言程序 hello.s，为之后的汇编过程做铺垫。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令，汇编语言为不同高级语言的不同编译器提供了通用的输出语言。如果想看懂他们，可以去看看csapp的第三章。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;gcc -S main.i -o main.s &lt;/code&gt;或者 &lt;code&gt;gcc -S main.c&lt;/code&gt;生成汇编程序，即可看到效果：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 68; 
			flex-basis: 164px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5Jrln9qA38.png&#34; data-size=&#34;576x841&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5Jrln9qA38.png&#34;
			width=&#34;576&#34;
			height=&#34;841&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5Jrln9qA38_hueb4ee5983f8388013ee1a0ffbe847c36_66558_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_5Jrln9qA38_hueb4ee5983f8388013ee1a0ffbe847c36_66558_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你尝试不同代码，你会发现汇编代码逻辑比起源代码逻辑发生了简化甚至更换位置，这是因为编译器会自动对程序的汇编实现进行优化，编译器是很聪明的。但如果你想获得原汁原味结构的汇编代码，可以使用&lt;code&gt;gcc -0g -E main.c&lt;/code&gt;获得符合结构的优化等级（如果要获得较好的优化一般需要把&lt;code&gt;-0g&lt;/code&gt;改为&lt;code&gt;-01&lt;/code&gt;或者&lt;code&gt;-01&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三汇编过程&#34;&gt;三、汇编过程&lt;/h2&gt;
&lt;p&gt;接下来，汇编器将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件main.o中。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;gcc -c main.s -o main.o&lt;/code&gt;或者&lt;code&gt;gcc -c main.c&lt;/code&gt;得到main.o目标文件。main.o文件是一个二进制文件，它的字节编码是机器语言指令而不是字符，如果vim强制打开main.o文件，看到的将是一堆乱码：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 210; 
			flex-basis: 504px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_wk6JTo08Bs.png&#34; data-size=&#34;1527x727&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_wk6JTo08Bs.png&#34;
			width=&#34;1527&#34;
			height=&#34;727&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_wk6JTo08Bs_hu2726989d3d99956272074790433e9d76_118441_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_wk6JTo08Bs_hu2726989d3d99956272074790433e9d76_118441_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果想看他的汇编代码，可以用反汇编器来查看它的编码：&lt;code&gt;objdump –d main.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 89; 
			flex-basis: 215px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_7aliivaPsO.png&#34; data-size=&#34;706x785&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_7aliivaPsO.png&#34;
			width=&#34;706&#34;
			height=&#34;785&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_7aliivaPsO_hu906d14d1537abae3f635bec25f8f137d_92797_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_7aliivaPsO_hu906d14d1537abae3f635bec25f8f137d_92797_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际上，二进制文件也能直接改，在jyy操作系统课程中你能学到这种有趣的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四链接过程&#34;&gt;四、链接过程&lt;/h2&gt;
&lt;p&gt;链接器（ld）负责将多个可重定位的目标文件（.o文件）合并为一个可执行文件，虽然前面已经得到了机器语言文件，但我们还需要把目标文件、操作系统的启动代码和用到的库文件进行组织得到最后的执行文件（比如printf就是从别的库文件来的）。&lt;/p&gt;
&lt;p&gt;通过链接过程将main.o变为可执行文件，使用&lt;code&gt;gcc main.c -o main&lt;/code&gt;或者&lt;code&gt;gcc main.c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于这里用到了其他文件的函数（实际上尝试实现了一个静态库，如果是单文件就按照前面的方法即可）需要使用&lt;code&gt;gcc main.c get_minus.c -o run&lt;/code&gt; ，可以看到最后生成了run，使用&lt;code&gt;./run&lt;/code&gt;即可看到结果：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 715; 
			flex-basis: 1716px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_T5cDkpVB4w.png&#34; data-size=&#34;808x113&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_T5cDkpVB4w.png&#34;
			width=&#34;808&#34;
			height=&#34;113&#34;
			srcset=&#34;https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_T5cDkpVB4w_hu89c4c874b6604e17e9d4d63aec332f0c_22232_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/image/image_T5cDkpVB4w_hu89c4c874b6604e17e9d4d63aec332f0c_22232_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果直接进行&lt;code&gt;gcc main.c&lt;/code&gt;的操作，得到的将是a.out文件，用同样的方法可以运行得到结果。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;ls -l&lt;/code&gt;我们可以将.o文件与最后可执行文件进行大小比较，可以发现最后的执行文件大小还是大很多的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果想用gdb进行调试，你需要这样对文件进行编译：&lt;code&gt;gcc main.c -o main -g&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果想进一步学习怎么生成自己的静态链接库与动态链接库，可以参考：&lt;a class=&#34;link&#34; href=&#34;https://wangjunstf.github.io/2021/09/30/jing-tai-ku-he-dong-tai-ku-zhi-zuo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;静态链接库与动态链接库&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/Shrimp_millet/article/details/94574406&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/Shrimp_millet/article/details/94574406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/307730265&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/307730265&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u012184539/article/details/81348529&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/u012184539/article/details/81348529&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.runoob.com/cprogramming/c-examples.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.runoob.com/cprogramming/c-examples.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wangjunstf.github.io/2021/09/30/jing-tai-ku-he-dong-tai-ku-zhi-zuo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wangjunstf.github.io/2021/09/30/jing-tai-ku-he-dong-tai-ku-zhi-zuo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.runoob.com/cprogramming/c-functions.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.runoob.com/cprogramming/c-functions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://c.biancheng.net/view/2375.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://c.biancheng.net/view/2375.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Disco Diffusion关键字大赏</title>
        <link>https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/</link>
        <pubDate>Thu, 12 May 2022 22:25:38 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/</guid>
        <description>&lt;img src="https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry2.png" alt="Featured image of post Disco Diffusion关键字大赏" /&gt;&lt;p&gt;长话短说，直接贴图！     &lt;br&gt;
[部分收集自b站]    &lt;br&gt;
以下是图片及其对应生成输入（因为图片命名更改了格式，含有&#39;_&amp;lsquo;字样，请自行处理一下或者写一个 str.replace()方法替换成空格,且吧末尾的200去除）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 166; 
			flex-basis: 400px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/HUNLI.png&#34; data-size=&#34;724x434&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/HUNLI.png&#34;
			width=&#34;724&#34;
			height=&#34;434&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/HUNLI_hu57be4c8cf4f569af55fe8eb4b8314839_438511_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/HUNLI_hu57be4c8cf4f569af55fe8eb4b8314839_438511_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;A_beautiful_painting_of_a_romantic_and_elegant_wedding_at_sunset_A_bride_white_wedding_dress_A_church_by_the_sea_rose_beach_light_effect_Dream_Caspar_David_Friedrich_artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A_beautiful_painting_of_a_romantic_and_elegant_wedding_at_sunset_A_bride_white_wedding_dress_A_church_by_the_sea_rose_beach_light_effect_Dream_Caspar_David_Friedrich_artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 161; 
			flex-basis: 387px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/SHITOU.png&#34; data-size=&#34;729x452&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/SHITOU.png&#34;
			width=&#34;729&#34;
			height=&#34;452&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/SHITOU_hu8083aaaf20cdd3d99879a2639271d59e_414287_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/SHITOU_hu8083aaaf20cdd3d99879a2639271d59e_414287_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Light_effect_Dream_Galaxy_StarsGreg_Rutkowski_Unreal_engine_Artstation_Towering_waves_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Light_effect_Dream_Galaxy_StarsGreg_Rutkowski_Unreal_engine_Artstation_Towering_waves_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 165; 
			flex-basis: 397px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/YANHUA.png&#34; data-size=&#34;726x438&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/YANHUA.png&#34;
			width=&#34;726&#34;
			height=&#34;438&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/YANHUA_hu8f3409a8ecaf71a4b684177f986ed425_456326_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/YANHUA_hu8f3409a8ecaf71a4b684177f986ed425_456326_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Splendid_colorful_fireworks_in_the_sky_desert_Dream_Karlsimon_Greg_Rutkowski_Unreal_Engine_James_Gurney_Artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Splendid_colorful_fireworks_in_the_sky_desert_Dream_Karlsimon_Greg_Rutkowski_Unreal_Engine_James_Gurney_Artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 166; 
			flex-basis: 398px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/MONTAIN.png&#34; data-size=&#34;734x442&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/MONTAIN.png&#34;
			width=&#34;734&#34;
			height=&#34;442&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/MONTAIN_hud9303e8d604812231fc0e33d72e201be_498004_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/MONTAIN_hud9303e8d604812231fc0e33d72e201be_498004_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;The_mountains_follow_the_plains_and_the_river_flows_into_the_great_wildernessTrending_on_artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;The_mountains_follow_the_plains_and_the_river_flows_into_the_great_wildernessTrending_on_artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 169; 
			flex-basis: 406px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/A.png&#34; data-size=&#34;729x430&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/A.png&#34;
			width=&#34;729&#34;
			height=&#34;430&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/A_hube4f578665231f9dfbcf5eb27c3b0db1_532799_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/A_hube4f578665231f9dfbcf5eb27c3b0db1_532799_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;A_beautiful_painting_of_a_building_full_of_sakura_bridge_clouds_sunset_fairy_tale_Distant_town_light_effect_dream_Josan_Gonzalez_artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A_beautiful_painting_of_a_building_full_of_sakura_bridge_clouds_sunset_fairy_tale_Distant_town_light_effect_dream_Josan_Gonzalez_artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 167; 
			flex-basis: 401px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/aa.png&#34; data-size=&#34;732x438&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/aa.png&#34;
			width=&#34;732&#34;
			height=&#34;438&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/aa_huc7c0fda3e1a58e30459cc92c7e704eb1_442887_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/aa_huc7c0fda3e1a58e30459cc92c7e704eb1_442887_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;a_beautiful_painting_of_mysterious_hard_sci-fi_city_at_sunset_clouds_neon_light_Cyberpunk_Magnificent_Greg_Rutkowski_artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;a_beautiful_painting_of_mysterious_hard_sci-fi_city_at_sunset_clouds_neon_light_Cyberpunk_Magnificent_Greg_Rutkowski_artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 164; 
			flex-basis: 395px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/Gurney.png&#34; data-size=&#34;727x441&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/Gurney.png&#34;
			width=&#34;727&#34;
			height=&#34;441&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/Gurney_hudb41ae815dc886e639faad6927e24700_488825_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/Gurney_hudb41ae815dc886e639faad6927e24700_488825_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;A_Moonlit_Night_On_The_Spring_River_Greg_Rutkowski_James_Gurney_Artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A_Moonlit_Night_On_The_Spring_River_Greg_Rutkowski_James_Gurney_Artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;br&gt;
ps:你可能难以想象，他的英文出自《春江花月夜》↑&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 165; 
			flex-basis: 396px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/The.png&#34; data-size=&#34;729x441&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/The.png&#34;
			width=&#34;729&#34;
			height=&#34;441&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/The_hud85a1b68218c2832f0eda41de8337f3f_519532_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/The_hud85a1b68218c2832f0eda41de8337f3f_519532_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;The_peach_blossom_lover_plants_peach_trees_in_days_fine_Greg_Rutkowski_James_Gurney_Artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;The_peach_blossom_lover_plants_peach_trees_in_days_fine_Greg_Rutkowski_James_Gurney_Artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;br&gt;
ps:你可能难以想象，他的英文出自唐寅的《桃花庵歌》“桃花仙人种桃树” ↑&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 165; 
			flex-basis: 397px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/chunjiang.png&#34; data-size=&#34;726x438&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/chunjiang.png&#34;
			width=&#34;726&#34;
			height=&#34;438&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/chunjiang_hu185441241326638446cae9d50a00cfdd_507576_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/chunjiang_hu185441241326638446cae9d50a00cfdd_507576_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;A_Moonlit_Night_On_The_Spring_Riverromantic_In_the_morning_Greg_Rutkowski_James_Gurney_Artstation_160&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A_Moonlit_Night_On_The_Spring_Riverromantic_In_the_morning_Greg_Rutkowski_James_Gurney_Artstation_160&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;br&gt;
ps:你可能难以想象，他的英文出自《春江花月夜》↑ &lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 167; 
			flex-basis: 401px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/renjian.png&#34; data-size=&#34;739x442&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/renjian.png&#34;
			width=&#34;739&#34;
			height=&#34;442&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/renjian_hu3cf4696608d098394a7d787ab0891042_528197_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/renjian_hu3cf4696608d098394a7d787ab0891042_528197_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Change_is_the_WayGreat_seas_have_turned_into_fieldsTrending_on_artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Change_is_the_WayGreat_seas_have_turned_into_fieldsTrending_on_artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;br&gt;
ps:你可能难以想象，他的英文出自【人间正道是沧桑】↑&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 166; 
			flex-basis: 399px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry.png&#34; data-size=&#34;734x441&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry.png&#34;
			width=&#34;734&#34;
			height=&#34;441&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry_hu829ff27670732ab1c894e3f69a29609b_502882_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry_hu829ff27670732ab1c894e3f69a29609b_502882_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Cherry_blossoms_grand_palaces_above_clouds_rivers_sunshine_dream_Greg_Rutkowski_James_Gurney_Artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Cherry_blossoms_grand_palaces_above_clouds_rivers_sunshine_dream_Greg_Rutkowski_James_Gurney_Artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 168; 
			flex-basis: 404px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry2.png&#34; data-size=&#34;739x438&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry2.png&#34;
			width=&#34;739&#34;
			height=&#34;438&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry2_hud0ddbd73ac71be0ebba682dec347f5c6_597770_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/cherry2_hud0ddbd73ac71be0ebba682dec347f5c6_597770_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Cherry_blossoms_village_river_sunshine_dream_Greg_Rutkowski_James_Gurney_Artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Cherry_blossoms_village_river_sunshine_dream_Greg_Rutkowski_James_Gurney_Artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 166; 
			flex-basis: 400px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/light.png&#34; data-size=&#34;1280x768&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/light.png&#34;
			width=&#34;1280&#34;
			height=&#34;768&#34;
			srcset=&#34;https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/light_hu0063c7a84883bab5857c98c452ef4eb3_978613_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/disco-diffusion%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E8%B5%8F/light_hu0063c7a84883bab5857c98c452ef4eb3_978613_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;In_the_morning_light_some_ancient_Chinese_buildings_on_the_mountains_sakura_mysterious_and_serene_landscape_clouds_river_Ivan_Aivazovsky_artstation_200&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;In_the_morning_light_some_ancient_Chinese_buildings_on_the_mountains_sakura_mysterious_and_serene_landscape_clouds_river_Ivan_Aivazovsky_artstation_200&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>python中多进程、多线程概念的进阶探讨</title>
        <link>https://sanbuphy.github.io/p/python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8E%A2%E8%AE%A8/</link>
        <pubDate>Sun, 24 Apr 2022 19:23:03 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8E%A2%E8%AE%A8/</guid>
        <description>&lt;p&gt;// TODO: &lt;br&gt;
//加入协程相关内容     &lt;br&gt;
// 资源安全性&lt;br&gt;
//         进程、线程间通信方式  &lt;br&gt;
// 如何捕获子线程异常&lt;/p&gt;
&lt;h2 id=&#34;简单理解进程和线程&#34;&gt;简单理解进程和线程&lt;/h2&gt;
&lt;h3 id=&#34;什么是进程&#34;&gt;什么是进程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一个任务就是一个进程，是操作系统资源分配的基本单位。&lt;/strong&gt;&lt;br&gt;
例如打开浏览器，打开word，打开游戏、QQ等等，都是独立的任务，它们各自为一个或者多个进程。&lt;br&gt;
这里要注意的是，同一种任务打开多个，分别属于不同进程，例如chrome打开多个标签，实际上它创建了多个进程。
“运行”的程序才可以称为进程。未运行的程序仅仅是一些指令和数据的集合，并非进程。&lt;/p&gt;
&lt;h3 id=&#34;什么是线程&#34;&gt;什么是线程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;线程可以看作一个任务的各项子任务，是操作系统直接的执行单元。&lt;/strong&gt;&lt;br&gt;
例如播放器，既要解码视频、也要解码音频，所以在进程下存在多线程。在一个进程下一定存在一个线程，可以称它为主线程。&lt;/p&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;操作系统创建进程时，会单独为每一个进程分配各自的资源，进程与进程之间相互隔离。进程在执行过程中拥有独立的内存单元，而多个线程共享内存。    &lt;br&gt;
可见，操作系统执行的粒度是线程，分配资源的粒度是进程，我们的多任务操作系统，在单核CPU上是在各个线程上不断切换而达到目的，而在多核CPU上则多个任务可以创建多个进程来完成，同时也可以创建多个线程来完成，线程是操作系统直接的执行单元。能同时执行多个线程任务。 &lt;br&gt;
值得注意的是，在python中，由于全局解释器锁的存在，线程并没有发挥并行计算的作用，而是提供了并发的能力。（只能在一个cpu核上运行）&lt;/p&gt;
&lt;h2 id=&#34;进程与线程的比较&#34;&gt;进程与线程的比较&lt;/h2&gt;
&lt;h3 id=&#34;进程的优缺点&#34;&gt;进程的优缺点&lt;/h3&gt;
&lt;p&gt;多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程。   &lt;br&gt;
但是缺点是&lt;strong&gt;创建进程的代价非常大&lt;/strong&gt; ，因为操作系统要给每个进程分配固定的资源，并且，操作系统对进程的总数会有一定的限制，若进程过多，&lt;strong&gt;操作系统调度都会存在问题，会造成假死状态。&lt;/strong&gt;。不过，进程与进程之间是完全隔离的，进程A崩溃了完全不会影响到进程B。&lt;/p&gt;
&lt;h3 id=&#34;线程的优缺点&#34;&gt;线程的优缺点&lt;/h3&gt;
&lt;p&gt;多线程优点是效率较高一些，但是致命的缺点是&lt;strong&gt;任何一个线程崩溃都可能造成整个进程的崩&lt;/strong&gt;溃，因为它们共享了进程的内存资源池，没有自己单独的内存地址空间，指针数据的错误可以导致任何同地址空间内其他线程的崩溃，包括进程。&lt;/p&gt;
&lt;h2 id=&#34;进一步理解进程和线程可选&#34;&gt;进一步理解进程和线程（可选）&lt;/h2&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;h4 id=&#34;进程的组成&#34;&gt;进程的组成&lt;/h4&gt;
&lt;p&gt;当一个程序被载入内存并成为一个进程后，它会占用一部分存储空间，此空间会分为 4 个区域：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 70; 
			flex-basis: 168px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8E%A2%E8%AE%A8/pic1.png&#34; data-size=&#34;324x462&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8E%A2%E8%AE%A8/pic1.png&#34;
			width=&#34;324&#34;
			height=&#34;462&#34;
			srcset=&#34;https://sanbuphy.github.io/p/python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8E%A2%E8%AE%A8/pic1_hu13122d3c1dbbef932b1399d2f830bd0e_32351_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8E%A2%E8%AE%A8/pic1_hu13122d3c1dbbef932b1399d2f830bd0e_32351_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
这 4 个区域的作用分别是：
栈（Stack）：存储局部变量、函数参数等临时数据。
堆（Heap）：进程在执行期间可以动态申请这部分空间。
数据区（Data）：存储全局变量和静态变量。
文本区（Text）：存储进程要执行的机器指令代码。&lt;/p&gt;
&lt;h4 id=&#34;进程的生命周期&#34;&gt;进程的生命周期&lt;/h4&gt;
&lt;h2 id=&#34;python中的gil全局解释器锁&#34;&gt;python中的GIL全局解释器锁&lt;/h2&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;h2 id=&#34;检查个人电脑的最大进程线程数&#34;&gt;检查个人电脑的最大进程、线程数&lt;/h2&gt;
&lt;p&gt;不同电脑的配置状况决定了一个系统能够运行多少进程以及对应的线程数，简单粗暴的方法是用实例代码来检测到底能运行多少进程和线程：（一般情况下不要过于离谱即可）   &lt;br&gt;
不过需要注意的是，不同任务处理所需要占用的内存和cpu使用率是不同的，需要具体情况具体分析，但通常情况下的使用不会出现大问题（除非你考虑到数据共享安全性，想让一组线程执行完后再启动下一轮，那就要根据实际情况设计最大线程并加上线程锁；等到获取到的这些数据处理后才能继续处理下一轮数据；或者使用大小限定队列与线程池）		
&lt;strong&gt;多进程测试代码&lt;/strong&gt;  
首先，你可以用这个语句（linux与mac）进行直接查看:&lt;code&gt;ubuntu&amp;gt; ps aux | wc -l&lt;/code&gt;,如果查询失败或者想要看到更直观的结果可以使用以下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#!/usr/bin/python
 
import os
import sys
import re
import threading
import signal
import time
 
g_exit = 0
num  = 0
 
def sig_process(sig, frame):
	global g_exit
	g_exit = 1
 
def sub_process(data):
	while not g_exit:
		time.sleep(1)
		print data
 
def process():
	num = int(sys.argv[1])
	all_process = []
 
	for i in range(num):
		try:
			pid = os.fork()
		except:
			pid = -1
 
		if pid &amp;lt; 0:
			print &#39;error in fork&#39;
			all_process.append(-1)
		elif 0 == pid:
			sub_process(i)
			os._exit(0)
		else:
			all_process.append(pid)
 
	while not g_exit:
		time.sleep(100)
 
	for i in range(num):
		if -1 == all_process[i]:
			continue
		os.waitpid(all_process[i], 0)
 
def main():
	if len(sys.argv) != 2:
		print &#39;wrong number parameter&#39;
		return 0
 
	signal.signal(signal.SIGINT, sig_process)
	process()
 
if __name__ == &#39;__main__&#39;:
	main()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;多线程测试代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#!/usr/bin/python
 
import os
import sys
import re
import threading
import signal
import time
 
g_exit = 0
num  = 0
 
def sig_process(sig, frame):
	global g_exit
	g_exit = 1
 
def sub_process(data):
	while not g_exit:
		time.sleep(1)
		print data
 
def process():
	num = int(sys.argv[1])
	all_thread = []
 
	for i in range(num):
		try:
			td = threading.Thread(target = sub_process, args=(i,))
			td.start()
		except:
			all_thread.append(-1)
			continue
 
		all_thread.append(td)
 
	while not g_exit:
		time.sleep(100)
 
	for i in range(num):
		if isinstance(all_thread[i], int):
			continue
		all_thread[i].join()
 
def main():
	if len(sys.argv) != 2:
		print &#39;wrong number parameter&#39;
		return 0
 
	signal.signal(signal.SIGINT, sig_process)
	process()
 
 
if __name__ == &#39;__main__&#39;:
	main()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/soyabean555999/article/details/79108680&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Python多线程与多进程学习&amp;mdash;-概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_43540515/article/details/114793287&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;操作系统，进程，线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/22397613?sort=created&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;线程崩溃是否会造成进程崩溃&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/feixiaoxing/article/details/78565542&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;python编程（你的电脑能够执行多少线程和进程）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_45621200/article/details/120905195&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;python主线程捕获子线程异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.biancheng.net/os/process.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;操作系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>详解机器/深度学习中常见评价指标</title>
        <link>https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</link>
        <pubDate>Tue, 12 Apr 2022 20:53:41 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</guid>
        <description>&lt;p&gt;待进一步完善&amp;hellip;龟速填坑中&lt;/p&gt;
&lt;h1 id=&#34;评价指标的基石&#34;&gt;评价指标的基石&lt;/h1&gt;
&lt;p&gt;所有复杂问题都是简单问题的重复， &lt;br&gt;
为了理解所有指标，首先需了解“四大天王”与“三大护法”&lt;/p&gt;
&lt;h2 id=&#34;四大天王tpfp-tnfn&#34;&gt;四大天王——TP|FP TN|FN&lt;/h2&gt;
&lt;p&gt;我们认为positive代表了阳性（或者说正样本），   &lt;br&gt;
而Negative代表了阴性（负样本)，那么在二分类中我们根据猜测的对错很容易排列出2x2种情况：   &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;True&lt;/th&gt;
&lt;th&gt;False&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Positive&lt;/td&gt;
&lt;td&gt;TP(猜对了阳)&lt;/td&gt;
&lt;td&gt;FP(猜错了阳)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Negative&lt;/td&gt;
&lt;td&gt;TN(猜对了阴)&lt;/td&gt;
&lt;td&gt;FN(猜错了阴)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中&lt;strong&gt;左半边&lt;/strong&gt;表示真值和我的猜测一致（猜对了），&lt;strong&gt;右半边&lt;/strong&gt;表示真值和我的猜测不一致（猜错了）；&lt;br&gt;
&lt;strong&gt;上半边&lt;/strong&gt;表示猜测阳性的全体 $P$，&lt;strong&gt;下半边&lt;/strong&gt;表示猜测阴性的全体$N$。&lt;br&gt;
&lt;strong&gt;TP+FN&lt;/strong&gt;表示真值阳性的全体，&lt;strong&gt;TN+FP&lt;/strong&gt;表示真值阴性的全体。&lt;/p&gt;
&lt;h2 id=&#34;三大护法preaccrecall&#34;&gt;三大护法——Pre、ACC、Recall&lt;/h2&gt;
&lt;p&gt;根据四大金刚，我们容易得出常见模型中的三个评价指标，
(为什么不能只看一个呢？因为容易被“浮云遮望眼”)&lt;/p&gt;
&lt;h3 id=&#34;preprecision-精确率又称查准率&#34;&gt;Pre(Precision 精确率又称查准率)&lt;/h3&gt;
&lt;p&gt;精确和准确在中文上看起来是一个意思，但实际上有微小的区别；   &lt;br&gt;
我们可以通过投标的例子来理解什么是精确，什么是准确。     &lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 108; 
			flex-basis: 259px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre.png&#34; data-size=&#34;443x410&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre.png&#34;
			width=&#34;443&#34;
			height=&#34;410&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre_hu293cc79c30269c7ee26490aff220e369_50239_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre_hu293cc79c30269c7ee26490aff220e369_50239_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;精确率是度量信噪的一种方式，是对偏差程度的反应（标准差大就不精确）&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;精确率是度量信噪的一种方式，是对偏差程度的反应（标准差大就不精确）&lt;/figcaption&gt;
	
&lt;/figure&gt;
从上图可知，精确率高的数据其标准差较小，也就是“我投中了，投中的差别不大”;在二分类中或者说判断是否阳性中，我们关注的重点是在我对阳性的判断中，是否判断对了(存不存在错判阳性的偏差）；如果精确率高，就说明我预测阳性偏差小，阳性就是真的阳性，较少出差错。     &lt;br&gt;
总结来说，精确率高指的是“我对正例判断出差错（偏差）的情况怎么样？”，也就是： &lt;br&gt;
$$
Precision = \frac{TP}{P} = \frac{TP}{TP+FP}
$$ &lt;br&gt;
精确率越高，说明我对正例/阳性判断的偏差越小，也就是TP占总判断阳性中的比例越大。
这时候可能会有聪明的同学问了，那为什么我们不考虑对负例判断的偏差呢，比如构建一个TN/TN+FN的指标？ &lt;br&gt;
其实是有的，一般的，Pre还有更深入的名字叫“positive predictive value (PPV)”，显然也有对应的“Negative predictive value (NPV) ” 只是因为负样本通常较少，正样本较多；所以把PPV作为一个更常用的指标，归为精确率。&lt;/p&gt;
&lt;h3 id=&#34;accaccuracy-准确率&#34;&gt;ACC(Accuracy 准确率)&lt;/h3&gt;
&lt;p&gt;为什么说精准但“精确不一定准确呢”？&lt;br&gt;
你可以这么想，精密仪器显然是为了误差小，那精密仪器一定能得到准确结果吗？————答案是不一定，比如你没有调零!(做过大物实验的朋友都知道~)     &lt;br&gt;
没有调零就好像y=kx+b中多了一个b，也就是投标图像中的“整体偏移真值” （下图的上半部分）    &lt;br&gt;
虽然很精确，但很不准确！！   &lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 159; 
			flex-basis: 383px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre-acc.png&#34; data-size=&#34;651x407&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre-acc.png&#34;
			width=&#34;651&#34;
			height=&#34;407&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre-acc_hu8a5893a2dc9a5dc60e3917fd76bdb1c7_115874_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E8%AF%A6%E8%A7%A3%E6%9C%BA%E5%99%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/pre-acc_hu8a5893a2dc9a5dc60e3917fd76bdb1c7_115874_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;左半侧更不准确，右半侧更准确&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;左半侧更不准确，右半侧更准确&lt;/figcaption&gt;
	
&lt;/figure&gt;
准确率更容易理解，准确率考虑的是更“全局”的结果是否正确， &lt;br&gt;
也就是在我所有预测的结果中，我到底预测的“好不好”，
即：
$$
Accuracy = \frac{TP+TN}{所有预测} = \frac{TP+TN}{TP+FP+TN+FN}
$$&lt;/p&gt;
&lt;h3 id=&#34;recall召回率又称查全率&#34;&gt;Recall(召回率又称查全率)&lt;/h3&gt;
&lt;p&gt;顾名思义，查全的意思就是“我查的全不全”，我是否把所有的阳性覆盖到了（阳性全体为P），&lt;/p&gt;
&lt;p&gt;$$
Recall =  \frac{TP}{阳性全体}=  \frac{TP}{TP+FN}
$$
&lt;strong&gt;有时候查全率很高，但精确率很低。&lt;/strong&gt;     &lt;br&gt;
比如我有3个阳性，97个阴性。我预测100个全为阳性（此时P=100且TP=3，FP=97），0个阴性；此时查全率为：3/3=100% ！&lt;br&gt;
但此时精确率为：3%。。。。。这显然是没有意义的。   &lt;br&gt;
&lt;strong&gt;有时候精确率很高，但查全率很低。&lt;/strong&gt;     &lt;br&gt;
比如我还是有3个阳性，97个阴性。我刚好预测对某1个为阳性（此时P=1且TP=1，FP=0），99个阴性；此时精确率为：100% ！   &lt;br&gt;
但此时查全率为：33.333%。。。。。这显然也是意义不大的。  &lt;br&gt;
&lt;strong&gt;查全率与精确率存在互逆关系&lt;/strong&gt;&lt;br&gt;
我们能够隐约发现查全率和精确率的互逆关系，但究竟是为什么呢？ &lt;br&gt;
仔细观察可以发现，Recall和Pre只在分母有差别，其中Recall的分母是TP+FN【不变量】，而Pre的分母是TP+FP【可变量】。&lt;br&gt;
为了提高Recall，我们需要增大TP，而分母不变； &lt;br&gt;
但Pre中如果TP增加了FP也会跟着增加（我需要判断的东西变多了，精确率会下降，错误的概率会变大），分子的TP增加小于分母的TP+FP总体的增加。所以查全率和精确率是互逆的。&lt;/p&gt;
&lt;h2 id=&#34;f1rpcrocauc&#34;&gt;F1、RPC、Roc、AUC&lt;/h2&gt;
&lt;p&gt;在充分了解了四大金刚与三大护法后，我们进一步来研究他们的衍生变体：&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/xys430381_1/article/details/90770520&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;机器学习基础&amp;mdash;分类与检测的评价指标&amp;mdash;AP，mAP，PRC曲线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/240435991&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;分类问题中的一些指标概念-Roc|AUC|Pre|Recall|ACC|AP|mAP|F1总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.pianshen.com/article/4398957319/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;分类器的ROC曲线及相关指标（ROC、AUC、ACC）详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/DOwFP4Qk4A415N8t8ibhAw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MCC — 机器学习中优于F1-score和accuracy的一个性能评价指标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://towardsdatascience.com/should-i-look-at-precision-recall-or-specificity-sensitivity-3946158aace1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Data Science in Medicine — Precision &amp;amp; Recall or Specificity &amp;amp; Sensitivity?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>C/C&#43;&#43;在Windows下的环境配置流程和运行方法</title>
        <link>https://sanbuphy.github.io/p/c/c-%E5%9C%A8windows%E4%B8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E5%92%8C%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95/</link>
        <pubDate>Sun, 20 Mar 2022 16:28:01 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/c/c-%E5%9C%A8windows%E4%B8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E5%92%8C%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95/</guid>
        <description>&lt;p&gt;笔者因为要使用opencv c++版的需求，需要给家里的电脑配c/cpp的运行环境，
如果是Linux无脑Clion即可，windows上稍微有一些麻烦，附上全流程：&lt;/p&gt;
&lt;p&gt;【6月份回来看感到很搞笑，注：这是笔者刚开始玩c/cpp的纯粹青涩文章&amp;hellip;..】&lt;/p&gt;
&lt;p&gt;首先请按照这个博主的安装教程走一遍流程&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/77645306&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;c++ c语言安装流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果顺利的安装好环境，接下来就是运行环节，首先随便新建一个C或者cpp文件，可参考；
C语言的版本：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;windows.h&amp;gt;
int main()
{
 printf(&amp;quot;Hello World\n&amp;quot;);
 system(&amp;quot;pause&amp;quot;);
 return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C++的版本：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt; 
using namespace std;  

int main()
{  
    cout &amp;lt;&amp;lt; &amp;quot;Hello Vscode&amp;quot; &amp;lt;&amp;lt; endl;  
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来就是最重要的部分，我们有两种办法编译好文件运行，
第一种办法（直接编译）：
在终端中进入对应文件夹，输入gcc xxx.c   或者g++ xxxx.cpp
即可将文件编译成exe，然后直接终端中输入exe文件名字即可查看效果！
如果你想运行后直接看跳出的结果，可以按照开头知乎链接的答主方法操作。&lt;/p&gt;
&lt;p&gt;第二种方法（间接编译）：我们要做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在上面菜单栏找到终端，选择配置生成任务，选择对应的文件（gcc或者g++  有可能只显示c++ 但点进去后会出现gcc)&lt;/li&gt;
&lt;li&gt;左侧找到运行与调试在上面框框中点开，然后选择工作区对应的文件夹添加配置（会生成.vscode文件夹，内部就是配置文件！），或者直接运行中找到添加配置，然后同样找到对应gcc g++即可（gcc或者g++  有可能只显示c++ 但点进去后会出现gcc)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果第二种方法配置出现问题了（launch或者task），你可以把.vscode文件夹删除，重新配置即可。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>考研，找工作的那些事</title>
        <link>https://sanbuphy.github.io/p/%E8%80%83%E7%A0%94%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
        <pubDate>Mon, 21 Feb 2022 21:18:24 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E8%80%83%E7%A0%94%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
        <description>&lt;p&gt;本文源于和大学时期舍友分享毒打经验(被毒打)&lt;/p&gt;
&lt;h2 id=&#34;找工作的怪象与形成的本源最重要的&#34;&gt;找工作的怪象与形成的本源【最重要的】&lt;/h2&gt;
&lt;h3 id=&#34;产业分布我该去哪&#34;&gt;产业分布——我该去哪？&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;一线：互联网企业、高新技术企业   ————  房价很高 容不下肉身  
二三线：事业单位、国企、各种你懂编制（研究所、老师。。。。。）  —————— 房价不算特别高 可能容不下灵魂    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;建议对自己想去的地方有个目的性，趁早考虑。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;学校和社会生活的差距&#34;&gt;学校和社会生活的差距&lt;/h2&gt;
&lt;h3 id=&#34;思想上的准备落后&#34;&gt;思想上的准备落后&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;   1. 考公务员
   2. 当老师
   3. 事业单位  。。。。。  其实是对找工作没有概念 【学校和社会生活的差距导致围城】 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;社会上温情确实更少一些&#34;&gt;社会上温情确实更少一些&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    1.抱大腿？大腿你遇不到，小腿不想理你
    2.跨部门的事情，基本是踢皮球
    3. *在外面很难找男/女朋友* 1. 考虑现实 2.考虑远近 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中心思想：你要真正断奶，为自己负责，为自己选择（来自家里人的建议，来自老师的建议，来自同学的建议）。&lt;/p&gt;
&lt;h3 id=&#34;一个毛病追求生活的最优解&#34;&gt;一个毛病————追求生活的最优解&lt;/h3&gt;
&lt;p&gt;——————不可能！   生活其实没有最优解，只有不同阶段的局部最优
——————追随心的声音&lt;/p&gt;
&lt;h4 id=&#34;问题我们应该用现在的回报去估计将来的收入曲线吗&#34;&gt;问题：我们应该用现在的回报去估计将来的收入曲线吗？&lt;/h4&gt;
&lt;p&gt;预测基本不可能——————追随心的声音&lt;/p&gt;
&lt;h2 id=&#34;怎么更好的获得回报获得资料工作岗位的需求&#34;&gt;怎么更好的获得回报/获得资料(工作岗位的需求)&lt;/h2&gt;
&lt;p&gt;假设：现在我要去追求二线的某某工作：
1、我要转行吗？做什么？怎么做？
我是电子信息硕士生，不转行&lt;/p&gt;
&lt;p&gt;2、我要做本行吗？做什么？怎么做？&lt;/p&gt;
&lt;h3 id=&#34;第一步信息获取&#34;&gt;第一步：信息获取&lt;/h3&gt;
&lt;p&gt;【获得信息是第一步的关键！】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我导师研究的是什么，我的老师有什么资源——（学术的资源、人脉的资源（公司的联系））
【我能获得什么？】&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;获得对应的学识&lt;/li&gt;
&lt;li&gt;获得对应公司的内推机会&lt;/li&gt;
&lt;li&gt;获得学长学姐的信息&lt;/li&gt;
&lt;li&gt;了解公司的内部好坏和福利（比如宁德时代的一些黑历史）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;学长学姐和历年就业去向表————找出最优秀的学长学姐 问他们是怎么过的，怎么努力的，怎么去获取资源的（可以请咖啡或者约面谈或者邮件或者微信，相信同校的学长学姐！）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第二步选择方向避免最坏的情况追求好一些的情况但不存在最好的情况&#34;&gt;第二步：选择方向（避免最坏的情况，追求好一些的情况，但不存在最好的情况）&lt;/h3&gt;
&lt;p&gt;电气工程师？做算法工程师？去国家电网？还是去当小学老师？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给出可能的几个方向&lt;/li&gt;
&lt;li&gt;求交集&lt;/li&gt;
&lt;li&gt;各种找工作的网站 按照  1、关键词 2、城市 遍历每一家公司的招工需求—————获得待遇情况，或者是去搜索待遇曲线以及和学长学姐信息对比。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;第三步根据方向-努力获取信息后努力&#34;&gt;第三步：根据方向 努力！获取信息后努力！&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;【根据社招的要求，去做校招，千万不要沦落到社招！】&lt;/em&gt;
&lt;em&gt;【现在的国情就是校招yyds，应届生yyds，请搞清楚应届生有什么福利（落户政策，人才引进)!!!!!!!!!!!!!!!!!!!!】&lt;/em&gt;
&lt;em&gt;【必须利用好应届生的身份，否则会后悔一辈子】&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自己做个文档（工作方需要什么经历，看重学生的什么素质，招工需要什么技术栈(ASIC\会验证会测试\会FPGA\会python使用EDA验证等）
举个例子：
岗位职责： 1、深入了解ASIC设计及验证流程，可根据芯片设计规格书，编写验证需求，可搭建验证平台并完成验证用例和回归; 2、执行验证计划，编写验证用例，开展递归测试，完成问题的调试和修复； 3、负责芯片IP集成验证以及IP模块验证，有高速接口验证经验者优先; 4、负责SOC系统级验证，并收集、分析和提高验证覆盖率; 5、熟悉FPGA芯片架构，可协助测试工程师完成芯片测试工作。 任职要求： 1、微电子电子工程通信计算机等相关专业硕士及以上学历； 2、熟悉system *** 、OVMUVM等能独立搭建可重用的系统验证平台; 3、熟练掌握perl 、python等脚本语言熟练使用EDA验证工具(如VCS、NCsim等)； 工作认真、积极主动、严谨、敬业、有较强的沟通能力与团队组织协调能力。福利待遇：国企福利，六险二金，做五休二，餐费补助，交通补助，全勤奖，项目津贴，年终奖，健身房，羽乒馆等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;针对技术栈去努力提高，顺便找志同道合的人【群友、交流群、学长学姐（拉学弟学妹下水）】&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第四步社交同样重要&#34;&gt;第四步：社交同样重要！&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;学长学姐&lt;/li&gt;
&lt;li&gt;交流群 群友。。。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么要实习&#34;&gt;为什么要实习&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面试造火箭——实际上拧螺丝 【台积电的例子】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果在小厂。。。你可能要一个人干三个人的活&lt;/li&gt;
&lt;li&gt;如果在大厂。。。拧螺丝！&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公司需要的是啥（什么价值？需要你产生什么价值，给公司带来什么，自己的可替代性强不强）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;弥补学校与社会的鸿沟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;攒经验，刷履历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向小朱学习！！！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;舔狗的艺术&#34;&gt;舔狗的艺术&lt;/h2&gt;
&lt;p&gt;（找一切机会向优秀的大佬们学习）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比起以后不能多请老婆喝一杯奶茶的委屈，比起以后不能多给儿子买一根棒棒糖的委屈，自己舔狗又有什么委屈的？&lt;/li&gt;
&lt;li&gt;说不定就舔到了呢？  都是小概率事件，值得尝试！&lt;/li&gt;
&lt;li&gt;不被理睬才是最正常的现象，如果有就带上感谢！没有也没关系，这很正常！&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;面子的问题怎么解决反正几十年后大家都入土了没什么好怕的&#34;&gt;面子的问题怎么解决————反正几十年后大家都入土了，没什么好怕的&lt;/h4&gt;
&lt;h2 id=&#34;战胜遗忘的方法&#34;&gt;战胜遗忘的方法：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;复习&lt;/li&gt;
&lt;li&gt;复习&lt;/li&gt;
&lt;li&gt;复习
（推荐一款app  memory helper 根据遗忘曲线安排你应该什么时候复习什么 免费！）&lt;/li&gt;
&lt;li&gt;干中学为什么忘得慢？ 因为你天天都得干&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;做这些的目的是&#34;&gt;做这些的目的是。。。？&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;青春一去不复返！&lt;/li&gt;
&lt;li&gt;获得更好的报酬&lt;/li&gt;
&lt;li&gt;看到更好的自己&lt;/li&gt;
&lt;li&gt;活在短暂未来的自己&lt;/li&gt;
&lt;li&gt;比起炒股，你能做好的也就是这些了&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>完美安装paddle、PPOCRLabel、eiseg(linux)</title>
        <link>https://sanbuphy.github.io/p/%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85paddleppocrlabeleiseglinux/</link>
        <pubDate>Sat, 19 Feb 2022 20:45:40 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E5%AE%8C%E7%BE%8E%E5%AE%89%E8%A3%85paddleppocrlabeleiseglinux/</guid>
        <description>&lt;p&gt;中心思想：遇事不决，降低版本 （numpy,paddlepaddle,opencv）&lt;/p&gt;
&lt;h3 id=&#34;以防万一的操作&#34;&gt;以防万一的操作&lt;/h3&gt;
&lt;p&gt;1.安装PyQt5&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install python3-pyqt5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.安装qt-designer&lt;/p&gt;
&lt;p&gt;&lt;code&gt; sudo apt-get install qt5-default qttools5-dev-tools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#命令行输入designer可测试是否安装成功&lt;/p&gt;
&lt;h2 id=&#34;推荐安装流程从新建虚拟环境到安装一条龙服务&#34;&gt;推荐安装流程（从新建虚拟环境到安装一条龙服务）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;请严格按照顺序！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#[装错了想卸载重装，把install改成uninstall 不要加包括-i在内后面的信息即可]&lt;/p&gt;
&lt;p&gt;#创建虚拟环境&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda create -n 改成你的虚拟环境名字 python=3.7&lt;/code&gt;   【3.7别打3.9】&lt;/p&gt;
&lt;p&gt;#进入虚拟环境&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda activate 改成刚才你的虚拟环境名字&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#装坏了想炸掉虚拟环境（&lt;strong&gt;慎重&lt;/strong&gt;别打错了）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda remove -n 你的虚拟环境名字 --all&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#此时你能看到终端左侧显示环境名，接下来安装各类程序&lt;/p&gt;
&lt;p&gt;#注：这里采用百度源作为示范，你也可以使用清华源：&lt;/p&gt;
&lt;p&gt;&lt;code&gt; -i https://pypi.tuna.tsinghua.edu.cn/simple&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#升级pip&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install --upgrade pip -i https://mirror.baidu.com/pypi/simple	&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#以防万一的操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install qtpy -i https://mirror.baidu.com/pypi/simple &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install pyqt5 -i https://mirror.baidu.com/pypi/simple &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#安装paddle &lt;a class=&#34;link&#34; href=&#34;https://github.com/PaddlePaddle/Paddle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github主页面&lt;/a&gt; 【这里采用的是cpu，如果要gpu详细安装过程参考&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/431985052&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gpu怎么看&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;（如果出现问题可以在paddlepaddle后面加上==2.1.0安装旧版本）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python -m pip install paddlepaddle -i https://mirror.baidu.com/pypi/simple&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#安装PPOCRLabel（OCR）  &lt;a class=&#34;link&#34; href=&#34;https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.4/PPOCRLabel/README_ch.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github主页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt; pip install PPOCRLabel -i https://mirror.baidu.com/pypi/simple&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt; pip install  trash-cli -i https://mirror.baidu.com/pypi/simple&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#安装EISeg（图像处理） &lt;a class=&#34;link&#34; href=&#34;https://github.com/PaddlePaddle/PaddleSeg&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github主页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;code&gt;pip install eiseg -i https://mirror.baidu.com/pypi/simple &lt;/code&gt;  #只输入这个就行&lt;/p&gt;
&lt;p&gt;​	&lt;code&gt;pip install paddleseg -i https://mirror.baidu.com/pypi/simple &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#【最后】安装旧版本opencv（如果装了请先卸载）&lt;/p&gt;
&lt;p&gt;&lt;code&gt; pip install opencv-python==4.2.0.32 -i https://mirror.baidu.com/pypi/simple&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#接着测试ocr和eiseg：首先输入&lt;code&gt;PPOCRLabel --lang ch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#如果此时出现一段加载过程，最后出现界面，就说明你安装成功了！！&lt;/p&gt;
&lt;p&gt;#再次输入： &lt;code&gt;eiseg&lt;/code&gt; 这时候大概率已经成功打开！&lt;/p&gt;
&lt;h3 id=&#34;倒霉人请看这&#34;&gt;倒霉人请看这&lt;/h3&gt;
&lt;p&gt;如果eiseg打开不成功可以尝试曲线方案（先安装这些依赖库）：&lt;/p&gt;
&lt;p&gt;(pip不成功就改成conda)&lt;/p&gt;
&lt;p&gt;#首先先把paddleseg的整个项目clone到本地  （以下安装还打不开可以这么做）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda install gdal&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install qtpy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip instal pyqt5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install easydict&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install scikit-image&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这时候再进入即可！  （如果你还是打不开，就clone后进入eiseg子文件，按照&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/435111803&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这个帖子&lt;/a&gt;运行exe.py	）&lt;/p&gt;
&lt;p&gt;最后使用conda deactivate退出虚拟环境！！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>目标检测相关资料汇总</title>
        <link>https://sanbuphy.github.io/p/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</link>
        <pubDate>Tue, 08 Feb 2022 15:28:17 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</guid>
        <description>&lt;p&gt;备注:我正在写一份目标检测&amp;amp;图像异常检测的综述slides，如果有兴趣可以等我出！欢迎邮件催更提建议：physicoada@gmail.com&lt;/p&gt;
&lt;h2 id=&#34;opencv基础&#34;&gt;opencv基础&lt;/h2&gt;
&lt;p&gt;推荐参考：
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV12V411q7Sp/?spm_id_from=333.788&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基于Python的Opencv全系列速成课&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1Hm4y1X7s9/?spm_id_from=333.788&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;3天建立计算机视觉移动应用程序-支持iOS与Android&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV11X4y1N7cQ/?spm_id_from=333.788&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;无人机编程与Python教学&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a class=&#34;link&#34; href=&#34;https://github.com/jasmcaus/opencv-course&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jasmcaus/opencv-course&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;几个大型综述&#34;&gt;几个大型综述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://arxiv.org/abs/1905.05055&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Object Detection in 20 Years: A Survey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关笔记：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/192362333&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/192362333&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_29462849/article/details/118231407&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;综述：目标检测二十年（2001-2021）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ciao/articles/10892921.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;目标检测近5年发展历程概述，从R-CNN到RFBNet（2013&amp;ndash;2018）&lt;/a&gt; (韩国人整的)&lt;/li&gt;
&lt;li&gt;目标检测：Anchor-Free时代 - 陀飞轮的文章 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/62103812&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/62103812&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CVPR 2021 论文大盘点-目标检测篇 - 我爱计算机视觉的文章 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/387510116&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/387510116&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目标检测的精进路径 - mileistone的文章 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/266648028&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/266648028&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目标检测入门，看这篇就够了（上） - 最刚烈的文章 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/60120331&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/60120331&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;国内做深度学习目标检测的有哪些大牛和厉害的课题组？ - Amusi的回答 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/330390445/answer/723973941&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/330390445/answer/723973941&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iccv-2021-结果出炉最新200篇iccv2021论文分方向汇总更新中&#34;&gt;ICCV 2021 结果出炉！最新200篇ICCV2021论文分方向汇总（更新中）&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/392575669&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/392575669&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/354043252&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/354043252&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;7cvpr2021论文分方向盘点&#34;&gt;7.CVPR2021论文分方向盘点&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/extreme-assistant/CVPR2021-Paper-Code-Interpretation#7&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/extreme-assistant/CVPR2021-Paper-Code-Interpretation#7&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一文看尽 27 篇 CVPR2021 2D 目标检测论文 &lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/Ho7qtrpF9FhHGaamkQo6Lw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/Ho7qtrpF9FhHGaamkQo6Lw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CVPR 2020 论文大盘点-目标检测篇&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://bbs.cvmart.net/articles/2732&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://bbs.cvmart.net/articles/2732&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《目标检测》-第24章-YOLO系列的又一集大成者：YOLOX！&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/391396921&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/391396921&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目标检测可以先从成熟框架开始上手，比如mmdetection和detectron2。 如果基础。。。。。。目标检测该怎么学呀，目前研一，老师啥也不会，感觉毕不了业了？ - 小小将的回答 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/510784176/answer/2305603811&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/510784176/answer/2305603811&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;系统地学习目标检测可以遵从下面的学习路线：
1.&lt;strong&gt;学习经典工作&lt;/strong&gt;。经典工作包括RCNN系列（RCNN、Fast RCNN、Faster RCNN），宏观上可以学习到什么是目标检测、目标检测是做什么的，微观上可以学习到诸如Region Proposal Network（后续one-stage工作的基础）、Anchor box等基础技术。这个系列后来被划定为“two-stage”工作，检测精度好、速度要慢一些。随后，再学习早期的YOLO系列工作（YOLOv1、YOLOv2），宏观上可以学习到什么是one-stage目标检测方法、如何进行端到端的训练和推理，同时，学习SSD，可以初次接触到多级检测方法——使用更多的&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/search?q=%e7%89%b9%e5%be%81%e5%9b%be&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7b%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2305881442%7d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;特征图&lt;/a&gt;去检测不同大小的物体。最后，学习FPN、YOLOv3以及RetinaNet（Focal loss），掌握当下主流检测框架“分而治之”方法。学习玩这些经典工作，最好能从中挑选出一至两个工作，进行复现，那么，目标检测就入门了。目标检测该怎么学呀，目前研一，老师啥也不会，感觉毕不了业了？ - Kissrabbit的回答 - 知乎 &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/510784176/answer/2305881442&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/510784176/answer/2305881442&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目标检测（Object Detection）入门概要&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/f290131665/article/details/81012556&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/f290131665/article/details/81012556&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/112640903&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;目标检测位置回归损失函数整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/104236411&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;目标检测回归损失函数简介：SmoothL1/IoU/GIoU/DIoU/CIoU Loss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zijin0802034/article/details/77685438&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;边框回归(Bounding Box Regression)详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/yangyehuisw/article/details/114918951&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Faster RCNN 中检测框位置回归是怎么做的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/27467369&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;目标检测（1）-Selective Search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zyly/p/9259392.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;第三十三节，目标检测之选择性搜索-Selective Search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u011974639/article/details/78053203?locationNum=7&amp;amp;fps=1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Object Detection&amp;ndash;RCNN,SPPNet,Fast RCNN，FasterRCNN论文详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.sohu.com/a/364671359_100007727&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;什么是anchor-based 和anchor free？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>小猫也能看懂的反向传播算法</title>
        <link>https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</link>
        <pubDate>Sat, 29 Jan 2022 16:18:00 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;img src="https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/jeff-rodgers-DaPabnoYMKc-unsplash.jpg" alt="Featured image of post 小猫也能看懂的反向传播算法" /&gt;&lt;p&gt;todo:https://www.cnblogs.com/charlotte77/p/5629865.html
TODO:https://blog.csdn.net/Serins/article/details/121508468
TODO:https://www.bilibili.com/video/BV16x411V7Qg?spm_id_from=333.337.search-card.all.click&lt;/p&gt;
&lt;p&gt;在介绍具体的算法之前，我们得先认识一下神经网络以及为什么要构造这样的神经网络。
注，如果你对神经网络的发展史感兴趣，可参考&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/subconscious/p/5058741.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;神经网络浅讲：从神经元到深度学习&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;神经网络基础&#34;&gt;神经网络基础&lt;/h2&gt;
&lt;p&gt;首先，我们知道人的神经网络是由神经元组成的，每个神经元与其他神经元相连。当某个神经元 “兴奋”时, 就会向相连的神经元发送化学物质，改变这些神经元内的电位；如果某神经元的电位超过了一个“阈值” ( threshold), 那么它就会被激活，即 “兴奋” 起来，接着向向其他神经元发送化学物质。   &lt;br&gt;
我们可以把神经元抽象成“神经单元”，即从&lt;strong&gt;单纯的输入0或1，阶跃函数型激活模式，输出0或1（即点火）&lt;strong&gt;的生物模型；变为&lt;/strong&gt;允许输入任何模型框架内数值，自选激活函数且将结果转化为兴奋度&lt;/strong&gt;的一般模型。 &lt;br&gt;
一般的，我们常用sigmoid函数作为激活函数，如果你想了解其他激活函数，可以自行搜索（网络上真的很多）：  &lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 225; 
			flex-basis: 541px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing1.png&#34; data-size=&#34;708x314&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing1.png&#34;
			width=&#34;708&#34;
			height=&#34;314&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing1_hu96e35c1fb03766fbb920d20802a4cbcd_85711_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing1_hu96e35c1fb03766fbb920d20802a4cbcd_85711_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;MP神经元模型 by：周志华-机器学习&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;MP神经元模型 by：周志华-机器学习&lt;/figcaption&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 214; 
			flex-basis: 514px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing2.png&#34; data-size=&#34;772x360&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing2.png&#34;
			width=&#34;772&#34;
			height=&#34;360&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing2_huf0c7ad51a6d125d3535def1e49e98a0f_53580_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing2_huf0c7ad51a6d125d3535def1e49e98a0f_53580_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;常见激活函数 by：周志华-机器学习&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;常见激活函数 by：周志华-机器学习&lt;/figcaption&gt;
	
&lt;/figure&gt;
由上可知，神经单元可以拆解为三大要素：
$$
\text{输入：} z=w_1x_1+\cdots +w_nx_n+b\cdot 1
\\
\text{输出：} a=f\left( z \right)
\\
\text{激活函数：}f\left( z \right) =\frac{1}{1+e^{-z}}
$$
其中b为偏置（为了形式美观，我们令阈值 $ \theta = -b $ ），b·1的意思是常数1作为b对应的输入值（这样可以在之后将等式写成更美观的矩阵，类似多元回归时把常数放入矩阵的操作）    &lt;br&gt;
有了神经单元，把他们连接后就形成了神经网络（不同层的作用将在下部分给出）
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 136; 
			flex-basis: 326px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing3.PNG&#34; data-size=&#34;565x415&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing3.PNG&#34;
			width=&#34;565&#34;
			height=&#34;415&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing3_hu3f13d4a903d68ecc4c0d4bea7e1ef2fa_116603_480x0_resize_box_3.PNG 480w, https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing3_hu3f13d4a903d68ecc4c0d4bea7e1ef2fa_116603_1024x0_resize_box_3.PNG 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;阶层型神经网络 by：深度学习的数学&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;阶层型神经网络 by：深度学习的数学&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;神经网络的运作原理&#34;&gt;神经网络的运作原理&lt;/h2&gt;
&lt;p&gt;假设，你是一只爱吃“0”与“1”图样猫粮且非常挑食的小猫，出于懒惰，你想让计算机帮自己把这两类图案的猫粮完全区分。在以前，我们学过了分类法的线性回归(逻辑回归)，单纯的二维数据点分类不是件难事，但当我们遇到图像后该怎么办呢？为了方便，我们需要引入上述的神经网络。 &lt;br&gt;
为了引入神经网络，首先需要对猫粮图案处理成计算机可识别的内容，我们可以这样进行编号：（举例图案为4x3的格子）
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 259; 
			flex-basis: 621px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing4.png&#34; data-size=&#34;943x364&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing4.png&#34;
			width=&#34;943&#34;
			height=&#34;364&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing4_hu2e9223918525cf31f51e7561fe0417c1_11841_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing4_hu2e9223918525cf31f51e7561fe0417c1_11841_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;将猫粮的0/1图案使用格子划分&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;将猫粮的0/1图案使用格子划分&lt;/figcaption&gt;
	
&lt;/figure&gt;
其中编号代表有多少个信号源输入，信号输入的大小可以根据黑白设定，给出相应的0/1。（比如黑格子给神经元1的输入，白格子为0的输入）
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 185; 
			flex-basis: 444px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing5.png&#34; data-size=&#34;844x456&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing5.png&#34;
			width=&#34;844&#34;
			height=&#34;456&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing5_hu3230b5ef4a6d3bdc519a46dd3bf63163_135554_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing5_hu3230b5ef4a6d3bdc519a46dd3bf63163_135554_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;将图像信息输入神经网络&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;将图像信息输入神经网络&lt;/figcaption&gt;
	
&lt;/figure&gt;  &lt;br&gt;
在这里为了简化，我们只有简单的三层，一层输入，一层隐藏层（你可以理解为进一步处理数据），一层输出（用于判断结果是0还是1）。我们把它称为&lt;strong&gt;两层神经网络&lt;/strong&gt;（有些地方觉得输入层需要计入，但在此我们采用“因为输入层不活动只是输入”的观点，将输入层排除在层数计算外）    &lt;br&gt;
有了数据输入，接下来便需要进一步认识神经单元的符号语言，从而理解数据在神经网络中是怎么传导的。（此处友情建议复习小节一的神经单元三大要素）
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 228; 
			flex-basis: 547px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing6.png&#34; data-size=&#34;659x289&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing6.png&#34;
			width=&#34;659&#34;
			height=&#34;289&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing6_hu947275a1b30ddb8a3e29420e1516031c_75137_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E5%B0%8F%E7%8C%AB%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/shenjing6_hu947275a1b30ddb8a3e29420e1516031c_75137_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;神经单元的符号语言&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;神经单元的符号语言&lt;/figcaption&gt;
	
&lt;/figure&gt;   如何理解这套符号呢？如图所示，“我们现在所研究的”对象是第L层的第j个神经单元，而他前一层的神经网络即为L-1层，且我们设前一层神经单元的标号为i。根据这套符号以及我们前面学到的神经单元三大要素，我们知道了第L层第j个神经单元的输入为 $ \mathrm{z}_{j}^{l} $，输出为 $ \mathrm{a}_{j}^{l} $ ,其中b为偏置，且L-1层第i个神经单元对L层第j个神经单元的影响权重为 $\mathrm{w}_{ji}^{l}$，激活函数负责把神经单元的“左半边”变成右半边的输出。（注，有些地方权重编号的ji可能互换为ij，但不影响最后结果）&lt;/p&gt;
&lt;p&gt;有了神经网络，我们自然想到它到底有什么用？让我们回望初心——分类，我们的目的是通过模型对样本进行分类；操作是通过对训练集的学习，将某种参数决定下的模型预测值（某种特征）与对应的现实特征比较，让现实和预测的差别尽量小，从而实现分类的效果。而神经网络也是如此，决定分类结果的是输出层，我们可以设输出层（参考上面出现的两层神经网络）的第一个神经单元的输出值 $a_1^3$ 在图样为1的时候接近1（现实目标为1），第二个神经单元的输出值 $a_2^3$在图样为0的时候接近1（显示目标为0），即为：（注意，值为1表示的是神经单元“兴奋”）&lt;/p&gt;
&lt;h3 id=&#34;为什么需要梯度下降法&#34;&gt;为什么需要梯度下降法&lt;/h3&gt;
&lt;h3 id=&#34;前向传播原理&#34;&gt;前向传播原理&lt;/h3&gt;
&lt;h3 id=&#34;反向传播原理&#34;&gt;反向传播原理&lt;/h3&gt;
&lt;h3 id=&#34;一般化处理&#34;&gt;一般化处理&lt;/h3&gt;
&lt;h2 id=&#34;浅析西瓜书中的bp算法&#34;&gt;浅析西瓜书中的BP算法&lt;/h2&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/71892752&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;温故知新——前向传播算法和反向传播算法（BP算法）及其推导&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/jsfantasy/p/12177275.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;反向传播算法详细推导&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV16x411V7Qg?p=2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深度学习之反向传播算法 上/下 Part 3 ver 0.9 beta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《深度学习的数学》 涌井良幸 涌井贞美&lt;/li&gt;
&lt;li&gt;《机器学习 Machine Learning》 周志华&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>机器学习中的信息论基础</title>
        <link>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Sat, 22 Jan 2022 22:34:11 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;img src="https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/michael-sum-LEpfefQf4rU-unsplash.jpg" alt="Featured image of post 机器学习中的信息论基础" /&gt;&lt;p&gt;首先，我们需要认识什么是信息量与信息熵:&lt;/p&gt;
&lt;h2 id=&#34;自信息量&#34;&gt;自信息量&lt;/h2&gt;
&lt;p&gt;通常自信息可以从两个方面来理解:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自信息是事件发生前,事件发生的不确定性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自信息表示事件发生后,事件所包含的信息量。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(比如你看到这，会想问作者也许不是一只猫而是人类————那我当然不是猫，这就没有不确定性可言，没有什么信息量；如果有一天我真的是猫了，那便是大新闻了！！) &lt;br&gt;
自然而然，我们会想到所谓信息量应当与概率有关，且应该可以加合（两个事件发生时带来的信息量应该是分别发生时的和），也就是满足以下特质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$f\left( P \right) &amp;gt;0 \; \; \; \; P\left( x \right) \in \left( 0,1 \right) $&lt;/li&gt;
&lt;li&gt;$f\left( P_A·P_B \right) =f\left( P_A \right) +f\left( P_B \right) $&lt;/li&gt;
&lt;li&gt;$f\left( 1 \right) =0$&lt;/li&gt;
&lt;li&gt;事件发生概率越大，自信息量越小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时我们可以才想到对数会满足这样的性质，于是可以给出：$I\left( x \right) =-\log \left( P\left( x \right) \right) $       &lt;br&gt;
因为在计算机领域中习惯用二进制，所以我们通常以2为底，这样自信息量的单位就为比特bit,——即二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量。而机器学习中常选择以e为底，单位为奈特nats       &lt;br&gt;
你可以通过以下例题来更好的理解自信息量：&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 213; 
			flex-basis: 513px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua3.png&#34; data-size=&#34;849x397&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua3.png&#34;
			width=&#34;849&#34;
			height=&#34;397&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua3_hu8329c2e9843336c3f6e3de434640aacf_63036_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua3_hu8329c2e9843336c3f6e3de434640aacf_63036_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;以2为底的对数符号lb&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;以2为底的对数符号lb&lt;/figcaption&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 136; 
			flex-basis: 328px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua4.png&#34; data-size=&#34;738x539&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua4.png&#34;
			width=&#34;738&#34;
			height=&#34;539&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua4_hu7358e9233fa379eb929803dca2e43690_148517_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua4_hu7358e9233fa379eb929803dca2e43690_148517_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;信息熵&#34;&gt;信息熵&lt;/h2&gt;
&lt;p&gt;接下来，我们将进一步研究什么是信息熵，在前面我们学会了如何衡量一个事件的不确定性，但一个随机变量可能包含的多个事件，我们该如何对这个 &lt;strong&gt;随机变量的不确定性&lt;/strong&gt; 进行刻画呢？   &lt;br&gt;
我们会自然想到求出所有事件的信息量期望，且熵越大，事件的不确定性越强，当满足均匀分布时熵最大(有约束情况下要额外考虑，一阶矩二阶矩不同时的最大熵分布不同，详情可参考最大熵原理）；如果熵值小，证明某个事件发生的概率比较大，随机变量取某个值的概率大，不确定性就小了。(另外，信息熵也可以理解为解除信源不确定性所需要的信息量)
于是我们给出： (其中规定)$0\log 0=0$
$$
H\left( x \right) =-\sum_{i=1}^n{p\left( x_i \right) \log \left( p\left( x_i \right) \right)}
$$
我们可以验证，当n个事件满足等概率分布时其中当结果为logn（n为总数）信息熵达到最大值。   &lt;br&gt;
另外可以给出条件熵(你可以运用条件概率辅助理解)：
$$
H\left( Y|X \right) =-\sum_x{\sum_y{p\left( xy \right) \log P\left( y|x \right) =\sum_x{-\sum_y{P\left( y|x \right) \log P\left( x \right) =\sum_x{P\left( x \right) H\left( Y|x \right)}}}}}
$$&lt;/p&gt;
&lt;h2 id=&#34;相对熵&#34;&gt;相对熵&lt;/h2&gt;
&lt;p&gt;如果我们对于同一个随机变量x有两个单独的概率分布P(x) 和 Q(x)，我们可以使用KL散度（Kullback-Leibler (KL) divergence）或者叫相对熵来衡量这&lt;strong&gt;两个分布的差异情况&lt;/strong&gt;，其中p对q的相对熵写作(在机器学习中，我们可以把P(x)看作真实分布，而Q(x)作为预测的分布)：
$$
D_{KL}\left(p||q \right) =\sum_x{p\left( x \right) \log \frac{p\left( x \right)}{q\left( x \right)}=E_{p\left( x \right)}\log \frac{p\left( x \right)}{q\left( x \right)}}
$$
同时KL散度还满足以下条件：
$$
D_{KL}\left(p||q \right) \ne D_{KL}(q||p)
\\
D_{KL}\left(
p||q\right) \geqslant 0
$$
对于第一个式子，我们可以借助以下内容理解：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 113; 
			flex-basis: 273px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua5.png&#34; data-size=&#34;827x727&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua5.png&#34;
			width=&#34;827&#34;
			height=&#34;727&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua5_hue3bf3906151592c8066971d242d88c99_188105_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/chigua5_hue3bf3906151592c8066971d242d88c99_188105_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;by Deep Learning.Ian Goodfellow and Yoshua Bengio and Aaron Courville&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;by Deep Learning.Ian Goodfellow and Yoshua Bengio and Aaron Courville&lt;/figcaption&gt;
	
&lt;/figure&gt;
用比较通俗的话来说，让我们回到公式之中，且注意到P(x)作为真实分布，Q(x)作为预测的分布；&lt;/p&gt;
&lt;p&gt;$$
D_{KL}\left( p||q \right) =E_{p\left( x \right)}\log \frac{p\left( x \right)}{q\left( x \right)}
$$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当第一种情况，如果P(x)是较大的，那么q(x)也应该较大来保证相对熵最小化；如果P(x)是较小的，那实际上q(x)的大小对相对熵影响不大；所以我们只需要特别注意前者的情况。此时在看图你就可以更加理解了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$
D_{KL}\left( q||p \right) =E_{q\left( x \right)}\log \frac{q\left( x \right)}{p\left( x \right)}
$$&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;当第二种情况，很显然会与第一种情况相反，如果P(x)是较小的，那么q(x)也应该较小来保证相对熵最小化————这就是为什么说图中提到概率小的地方比较重要，而q(x)较大的时候就影响不大了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;交叉熵&#34;&gt;交叉熵&lt;/h2&gt;
&lt;p&gt;接下来我们要了解常用的一种更常用的熵————交叉熵，由前面学到的相对熵可以进一步推导：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
D_{KL}\left( p||q \right) &amp;amp;=\sum_{i=1}^n{p\left( x_{\mathrm{i}} \right) \log \left( \frac{p\left( x_i \right)}{q\left( x_i \right)} \right)}\\
\mathrm{
}&amp;amp;=\sum_{i=1}^n{p\left( x_i \right) \log \left( p\left( x_i \right) \right)}-\sum_{i=1}^n{p\left( x_i \right)}\log \left( q\left( x_i \right) \right)\\
&amp;amp;=-H\left( p \right) -\sum_{i=1}^n{p\left( x_i \right)}\log \left( q\left( x_i \right) \right)\
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;其中第一项我们可通过推导得知是针对真实分布概率p(x)的信息熵，而后一项我们定义为交叉熵；
$$
H\left( p,q \right) =-\sum_{i=1}^n{p\left( x_i \right)}\log \left( q\left( x_i \right) \right)
$$
交叉熵可以理解为，&lt;strong&gt;消除体系不确定性所需要付出的努力大小&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;交叉熵与极大似然估计的联系&#34;&gt;交叉熵与极大似然估计的联系&lt;/h3&gt;
&lt;p&gt;由于真实分布的信息熵是确定的，在优化过程中（最小化相对熵），我们可以把他忽略，只看交叉熵的部分。此外，最小化交叉熵其实与极大似然估计是等价的，具体证明如下：（参考Deep Learning.Ian Goodfellow and Yoshua Bengio and Aaron Courville）       &lt;br&gt;
我们考虑一组含有m个样本的数据集$\mathbf{X}=({ x^{(1)},\cdots ,x^{(m)} }) $,此时可以定义 $ \theta $ 的极大似然为(其中P为模型的联合概率)：(如果你不懂argmax是什么意思可以参考&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/79383099&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;argmax科普&lt;/a&gt;)
$$
\begin{aligned}
\mathbf{\theta }_{ML}&amp;amp;=\underset{\theta}{\mathrm{argmax}}P_{model}\left( \mathbf{X};\theta \right)\\
\mathrm{
}&amp;amp;=\underset{\theta}{\mathrm{argmax}}\prod_{i=1}^m{P_{model}\left( \boldsymbol{x}^{\left( i \right)};\theta \right)}
\end{aligned}
$$
由于乘积不好计算，我们可以取log将他转换为加和形式，取最值时的参数不变；且可以乘上不影响结果的 $ \frac{1}{m} $。
$$
\begin{aligned}
\mathbf{\theta }_{ML}&amp;amp;=\underset{\theta}{\mathrm{argmax}}\sum_{i=1}^m \mathrm{log} {P_{model}\left( \boldsymbol{x}^{\left( i \right)};\theta \right)}\\
\mathrm{
}&amp;amp;=\underset{\theta}{\mathrm{argmax}}\frac{1}{m}\sum_{i=1}^m \mathrm{log} {P_{model}\left( \boldsymbol{x}^{\left( i \right)};\theta \right)}
\end{aligned}
$$
由大数定律可知（算术平均值依概率收敛于期望）：
$$
\frac{1}{m}\sum_{i=1}^m{X_i\longrightarrow} \mu
$$
可以将原式进一步化为：
$$
\begin{aligned}
\mathbf{\theta }_{ML}&amp;amp;=\underset{\theta}{\mathrm{arg}\max}\mathbb{E}_{\mathbf{x}~\hat{p}_{data}}\log P_{model}\left( \boldsymbol{x};\boldsymbol{\theta } \right)\\
&amp;amp;=\underset{\theta}{\mathrm{arg}\max}\sum_x{p\left( x \right) \log q\left( x \right)}\\
&amp;amp;=\underset{\theta}{\mathrm{arg}\min}\left[ -\sum_x{p\left( x \right) \log q\left( x \right)} \right]\\
\end{aligned}
$$
Bravo!!! 此时你惊喜的发现这就是我们前面推导得到的交叉熵公式，至此，对于真实分布和模型分布，我们明白了MLE方法（让似然最大化）等价于两者间交叉熵的最小化。好奇的你也许想问“MLE与KL散度也是共通的吗？”————这个问题你可以自己试试看，就用上式类似办法加常数即可！&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wangguchangqing/p/12068084.html#autoid-0-1-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一文搞懂交叉熵损失&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/kyrieng/p/8694705.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解机器学习中的熵、条件熵、相对熵和交叉熵 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.doc88.com/p-5763943323651.html?r=1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;信息论基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/355150033&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;数字世界逼近现实世界——浅谈分布近似与最大似然估计&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>《机器学习》西瓜书笔记(二)</title>
        <link>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
        <pubDate>Mon, 17 Jan 2022 22:53:41 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
        <description>&lt;p&gt;本文为个人对西瓜书不成熟的一些理解和资料整理，欢迎批评指出意见，谢谢！(可邮箱联系physicoada@gmail.com)&lt;/p&gt;
&lt;h2 id=&#34;西瓜书章节三--线性模型&#34;&gt;西瓜书章节三  线性模型&lt;/h2&gt;
&lt;p&gt;文字版浓缩可参考：&lt;a class=&#34;link&#34; href=&#34;https://github.com/Vay-keen/Machine-learning-learning-notes/blob/master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%284%29--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;周志华机器学习笔记 by:Vay-keen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简略而言，本章主要涉及到三大块内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性回归及极大似然估计&lt;/li&gt;
&lt;li&gt;对数几率回归及交叉熵思想&lt;/li&gt;
&lt;li&gt;二分类线性判别分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数学基础&#34;&gt;数学基础&lt;/h3&gt;
&lt;h4 id=&#34;极大似然估计&#34;&gt;极大似然估计&lt;/h4&gt;
&lt;h4 id=&#34;凸函数&#34;&gt;凸函数&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 70; 
			flex-basis: 169px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua2.jpg&#34; data-size=&#34;2182x3086&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua2.jpg&#34;
			width=&#34;2182&#34;
			height=&#34;3086&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua2_huafcd3297fe575c7ac67533b0df971f22_374632_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua2_huafcd3297fe575c7ac67533b0df971f22_374632_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
本图来自：&lt;a class=&#34;link&#34; href=&#34;https://www.pianshen.com/article/98061511620/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;凸函数的四种判断方法&lt;/a&gt;
多元函数判别法(Hessian矩阵正定性)：&lt;/p&gt;
&lt;p&gt;机器学习中凸函数的好处：函数具有唯一的极小值。这意味着我们求得的模型是全局最优，不会陷入局部最优（想象一下无数波浪的函数，难以在梯度下降中找到最小值）。&lt;/p&gt;
&lt;h4 id=&#34;信息熵相对熵与交叉熵&#34;&gt;信息熵、相对熵与交叉熵&lt;/h4&gt;
&lt;p&gt;请参考数学专栏中的文章（机器学习中的信息论基础）&lt;/p&gt;
&lt;h4 id=&#34;拉格朗日乘子法&#34;&gt;拉格朗日乘子法&lt;/h4&gt;
&lt;h3 id=&#34;线性回归&#34;&gt;线性回归&lt;/h3&gt;
&lt;h4 id=&#34;矩阵推导&#34;&gt;矩阵推导&lt;/h4&gt;
&lt;p&gt;矩阵求导方法及其完整过程请参考我的另外一篇文章：&lt;a class=&#34;link&#34; href=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;矩阵求导建议入门手册&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;极大似然估计法&#34;&gt;极大似然估计法&lt;/h4&gt;
&lt;h3 id=&#34;对数几率回归逻辑回归&#34;&gt;对数几率回归(逻辑回归)&lt;/h3&gt;
&lt;h4 id=&#34;极大似然估计法-1&#34;&gt;极大似然估计法&lt;/h4&gt;
&lt;h3 id=&#34;线性判别分析&#34;&gt;线性判别分析&lt;/h3&gt;
&lt;h3 id=&#34;多分类学习&#34;&gt;多分类学习&lt;/h3&gt;
&lt;h4 id=&#34;ecoc码&#34;&gt;ECOC码&lt;/h4&gt;
&lt;p&gt;在书中，我们会看到这样的一张图：     &lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 223; 
			flex-basis: 536px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua.png&#34; data-size=&#34;894x400&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua.png&#34;
			width=&#34;894&#34;
			height=&#34;400&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua_hub8e31a2bb461476b573f82071999d431_126670_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/chigua_hub8e31a2bb461476b573f82071999d431_126670_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
其中涉及到所谓的海明距离与欧氏距离。
海明距离指的是：对于长度相等的两个字符串，在相同位置上不同字符的个数。&lt;br&gt;
而欧氏距离指的是多维空间中两点间绝对距离：
$
dist\left( X,Y \right) =\sqrt{\sum_{i=1}^n{\left( x_i-y_i \right) ^2}}
$            &lt;br&gt;
由此我们可以计算出图中的数字，对(a)图中可有：
$$
\qquad \text{示例}-1 {\color{red} -1 +1 -1 }+1
\\
C1\text{编码} \ -1 {\color{red} +1 -1 +1 }+1
$$
容易看出海明距离为3，而欧氏距离为
$$
\sqrt{\left( -1-\left( -1 \right) \right) ^2+\left( -1-1 \right) ^2+2^2+2^2+0}=2\sqrt{3}
$$
其他值可以用相同的办法推导得到。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/muyao987/article/details/107197624&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;逻辑回归的原理、推导和常见问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/lsm-boke/p/12242352.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;凸函数、损失函数、线性模型的基本形式、线性回归、w* 的代码实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>矩阵求导简易入门手册</title>
        <link>https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/</link>
        <pubDate>Wed, 12 Jan 2022 21:54:58 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;初始介绍&#34;&gt;初始介绍&lt;/h2&gt;
&lt;h3 id=&#34;符号规定&#34;&gt;符号规定&lt;/h3&gt;
&lt;p&gt;在本文中，我们做如下规定：&lt;br&gt;
Matrix矩阵为：$\mathbf{A}, \mathbf{X}, \mathbf{Y}$ &lt;br&gt;
Vector向量（规定为$\color{red} {列} $向量）为：$ \mathbf{a}, \mathbf{x}, \mathbf{y}$&lt;br&gt;
Scalar标量为：$a, x, y$&lt;/p&gt;
&lt;h3 id=&#34;分子布局&#34;&gt;分子布局&lt;/h3&gt;
&lt;p&gt;在矩阵求导中，我们有两种布局（分子与分母）   &lt;br&gt;
为了方便起见，本文只阐述了分子布局即：&lt;/p&gt;
&lt;p&gt;$$\frac{\partial \mathbf{y}}{\partial {x}}=\left[\begin{array}{c}  \frac{\partial y_{1}}{\partial x}  \\  \frac{\partial y_{2}}{\partial x} \\ \vdots \\  \frac{\partial y_{m}}{\partial x}\end{array}\right]\ \ \
\frac{\partial y}{\partial \mathbf {x}} = \left[\frac{\partial y}{\partial x_{1}} ,\frac{\partial y}{\partial x_{2}}, \cdots ,\frac{\partial y}{\partial x_{n}}\right]$$
分母布局为分子布局的转置。 &lt;br&gt;
&lt;strong&gt;记忆方法：分子列向量分母标量，看作长筒冰淇淋，分母看作小盒子，“能站住”。分子标量分母列向量，则盒子把冰淇淋“压倒了”。或可看最后结果的行数，是分子的行数便是分子布局。&lt;/strong&gt;     &lt;br&gt;
一般的，我们会遇到如下布局,且可用记忆方法配合右图形象理解(下面是结果）：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 126; 
			flex-basis: 303px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing.png&#34; data-size=&#34;415x328&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing.png&#34;
			width=&#34;415&#34;
			height=&#34;328&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing_hu6f83b6254a6e60a05ec81f6ae07e2db0_25597_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing_hu6f83b6254a6e60a05ec81f6ae07e2db0_25597_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;by: Reference 2&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;by: Reference 2&lt;/figcaption&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 243; 
			flex-basis: 585px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing2.png&#34; data-size=&#34;824x338&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing2.png&#34;
			width=&#34;824&#34;
			height=&#34;338&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing2_hu35b1b9fc292f8856c2d4ca726f9b9dc1_6193_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/leixing2_hu35b1b9fc292f8856c2d4ca726f9b9dc1_6193_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;by: Reference 2&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;by: Reference 2&lt;/figcaption&gt;
	
&lt;/figure&gt;
当分子为矢量、矩阵时，结果为分子的行；当分子为标量时，结果是分母转置的行。&lt;/p&gt;
&lt;h3 id=&#34;vector-by-vector&#34;&gt;Vector-by-Vector&lt;/h3&gt;
&lt;p&gt;另外我们有：&lt;/p&gt;
&lt;p&gt;$\mathbf{y}=\begin{bmatrix}
y_1 \\
y_2 \\
\vdots \\
y_m
\end{bmatrix}$
$\mathbf{x}=\begin{bmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{bmatrix}$
由 $ \frac{\partial \mathbf{y}}{\partial \mathbf{x}}$ 运算后产生m行n列矩阵：
$ \frac{\partial \mathbf{y}}{\partial \mathbf{x}} \stackrel{\text { def }}{=}\left[\begin{array}{cccc}\frac{\partial y_{1}}{\partial x_{1}} &amp;amp; \frac{\partial y_{1}}{\partial x_{2}} &amp;amp; \ldots &amp;amp; \frac{\partial y_{1}}{\partial x_{n}} \\ \frac{\partial y_{2}}{\partial x_{1}} &amp;amp; \frac{\partial y_{2}}{\partial x_{2}} &amp;amp; \ldots &amp;amp; \frac{\partial y_{2}}{\partial x_{n}} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\ \frac{\partial y_{m}}{\partial x_{1}} &amp;amp; \frac{\partial y_{m}}{\partial x_{2}} &amp;amp; \ldots &amp;amp; \frac{\partial y_{m}}{\partial x_{n}}\end{array}\right] $  &lt;br&gt;
这种矩阵可被称为&lt;strong&gt;Jacobian matrix&lt;/strong&gt;。
接下来举个例子，若我们有：
$$\mathbf{y}=\begin{bmatrix}
y_1 \\
y_2 \\
\end{bmatrix}
\ \ \ \mathbf{x}=\begin{bmatrix}
x_1 \\
x_2 \\
x_3
\end{bmatrix}\ \ 且y_1=x^2_1-2x_2 \ ,\ y_2=x^2_3-4x_2$$
则能得到:
$$\frac{\partial \mathbf{y}}{\partial \mathbf{x}} =\begin{bmatrix}
2x_1 &amp;amp; -2 &amp;amp; 0 \\
0 &amp;amp; -4 &amp;amp; 2x_3 \\
\end{bmatrix}
$$&lt;/p&gt;
&lt;h3 id=&#34;matrix-by-scalar&#34;&gt;Matrix-by-Scalar&lt;/h3&gt;
&lt;p&gt;同样的，我们可以给出矩阵与向量间的运算关系：     &lt;br&gt;
$ \frac{\partial \mathbf{Y}}{\partial {x}} \stackrel{}{=}\left[\begin{array}{cccc}\frac{\partial Y_{11}}{\partial x} &amp;amp; \frac{\partial Y_{12}}{\partial x} &amp;amp; \ldots &amp;amp; \frac{\partial Y_{1n}}{\partial x} \\ \frac{\partial Y_{21}}{\partial x} &amp;amp; \frac{\partial Y_{22}}{\partial x} &amp;amp; \ldots &amp;amp; \frac{\partial Y_{2n}}{\partial x} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\ \frac{\partial Y_{m1}}{\partial x} &amp;amp; \frac{\partial Y_{m2}}{\partial x} &amp;amp; \ldots &amp;amp; \frac{\partial Y_{mn}}{\partial x}\end{array}\right]$
$ \ \ \ \ \ and \ \ \ \ \frac{\partial y}{\partial\mathbf{X}} \stackrel{}{=}\left[\begin{array}{cccc}\frac{\partial y}{\partial X_{11}} &amp;amp; \frac{\partial y}{\partial X_{21}} &amp;amp; \ldots &amp;amp; \frac{\partial y}{\partial X_{m1}} \\ \frac{\partial y}{\partial X_{12}} &amp;amp; \frac{\partial y}{\partial X_{22}} &amp;amp; \ldots &amp;amp; \frac{\partial y}{\partial X_{m2}} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\ \frac{\partial y}{\partial X_{1n}} &amp;amp; \frac{\partial y}{\partial X_{2n}} &amp;amp; \ldots &amp;amp; \frac{\partial y}{\partial X_{mn}}\end{array}\right] $&lt;br&gt;
可以注意到当矩阵在分母时$\mathrm{X}$已经“被转置”&lt;/p&gt;
&lt;h2 id=&#34;常用求导公式&#34;&gt;常用求导公式&lt;/h2&gt;
&lt;p&gt;注：其中$\mathbf{a},\mathrm{A}$都不是$\mathbf{x}, \mathrm{X}$的函数  &lt;br&gt;
$$\frac{\mathrm{d} \mathbf{a}}{\mathrm{d} x} =\mathbf{0} \tag{1} \qquad  (column \ matrix)$$
$$\frac{\mathrm{d}a }{\mathrm{d} \mathbf{x}} =\mathbf{0}^{\mathrm{T}}  \tag{2} \qquad  (row \ matrix)$$
$$\frac{\mathrm{d}a }{\mathrm{d} \mathbf{X}} =\mathbf{0}^{\mathrm{T}} \tag{3} \qquad  (matrix)$$
$$\frac{\mathrm{d} \mathbf{a} }{\mathrm{d} \mathbf{X}} =\mathbf{0} \tag{4} \qquad  (matrix)$$
$$\frac{\mathrm{d} \mathbf{x} }{\mathrm{d} \mathbf{x}} =\mathbf{I} \tag{5} \qquad  (matrix)$$
若想从“直观上”理解结果为什么会有转置符，可以反复理解 &lt;strong&gt;(1.2)分子布局&lt;/strong&gt; 中的右图
$$\frac{\mathrm{d} \mathbf{a}^{\mathrm{T}}\mathbf{x} }{\mathrm{d} \mathbf{x}}=\frac{\mathrm{d} \mathbf{x}^{\mathrm{T}}\mathbf{a} }{\mathrm{d} \mathbf{x}}=\mathbf{a}^{\mathrm{T}} \tag{6} $$
$$\frac{\mathrm{d} \mathbf{x}^{\mathrm{T}}\mathbf{x} }{\mathrm{d} \mathbf{x}}=2\mathbf{x}^{\mathrm{T}} \tag{7} $$
$$\frac{\mathrm{d} ({\mathbf{x}^{\mathrm{T}}\mathbf{a}})^2 }{\mathrm{d} \mathbf{x}}=2\mathbf{x}^{\mathrm{T}}\mathbf{a}\mathbf{a}^{\mathrm{T}} \tag{8} $$
$$\frac{\mathrm{d} \mathbf{Ax} }{\mathrm{d} \mathbf{x}} =\mathbf{A} \tag{9} $$
$$\frac{\mathrm{d} \mathbf{x}^{\mathrm{T}}\mathbf{A} }{\mathrm{d} \mathbf{x}}=\mathbf{A}^{\mathrm{T}} \tag{10} $$
$$\frac{\mathrm{d} \mathbf{x}^{\mathrm{T}}\mathbf{A}\mathbf{x} }{\mathrm{d} \mathbf{x}}=\mathbf{x}^{\mathrm{T}}(\mathbf{A}+\mathbf{A}^{\mathrm{T}}) \tag{11} $$&lt;/p&gt;
&lt;p&gt;注：其中(11)用到了矩阵求导中的&amp;quot;莱布尼兹法则&amp;quot;（仔细思考前者的行列与后者的行列就可以明白）:
$$\frac{\partial \mathbf u^{\mathrm{T} }\mathbf v}{\partial \mathbf x} =
\mathbf u^{\mathrm{T}} \frac{\partial \mathbf v}{\partial \mathbf x} +
\mathbf v^{\mathrm{T}}\frac{\partial \mathbf u}{\partial \mathbf x}$$&lt;/p&gt;
&lt;h2 id=&#34;实例练习&#34;&gt;实例练习&lt;/h2&gt;
&lt;p&gt;我们会好奇一个问题：为什么大多数求导后以及求导时形式都是转置在前？   &lt;br&gt;
可以这么理解，假设有参数$\mathbf{\Theta } =\begin{bmatrix}
\theta_0\\
\theta_1\\
\theta_2
\end{bmatrix}$
以及列向量$\mathbf{x}=\begin{bmatrix}
1 \\
x_1 \\
x_2
\end{bmatrix}$
我们可以把多元函数表达为$$f(x_1,x_2)=\Theta^{\mathrm{T}} \mathbf{x}=\theta_0 + \theta_1x_1 + \theta_2x_2$$
方便计算，且符合目的。在计算结果直觉中一定要紧紧把握结果与分子（上下拉长）分母（左右拉宽）的关系。&lt;/p&gt;
&lt;h3 id=&#34;多元线性回归推导&#34;&gt;多元线性回归推导&lt;/h3&gt;
&lt;p&gt;在西瓜书第三章开头中，我们需要求解最小error$\ E=(\boldsymbol{y}-\mathbf{X}\boldsymbol{\hat{w}})^{\mathrm{T}}(\boldsymbol{y}-\mathbf{X}\boldsymbol{\hat{w}}) $
对其展开有：$$ \begin{aligned}(\boldsymbol{y}-\mathbf{X}\boldsymbol{\hat{w}})^{\mathrm{T}}(\boldsymbol{y}-\mathbf{X}\boldsymbol{\hat{w}}) &amp;amp;=(\boldsymbol{y}^{\mathrm{T}}-\boldsymbol{\hat{w}}^{\mathrm{T}}\mathbf{X}^{\mathrm{T}})(\boldsymbol{y}-\mathbf{X}\boldsymbol{\hat{w}}) \\
&amp;amp;= \boldsymbol{y}^{\mathrm{T}} \boldsymbol{y}- (\boldsymbol{y}^{\mathrm{T}} \mathbf{X})  \boldsymbol{\hat{w}}-\boldsymbol{\hat{w}}^{\mathrm{T}} (\mathbf{X}^{\mathrm{T}} \boldsymbol{y})
+\boldsymbol{\hat{w}}^{\mathrm{T}} (\mathbf{X}^{\mathrm{T}} \mathbf{X})  \boldsymbol{\hat{w}} \end{aligned}$$&lt;/p&gt;
&lt;p&gt;把括号中看作常数，每一项分别对 $\boldsymbol{\hat{w}}$ 求导，利用公式$(9),(10),(11)$可得: &lt;br&gt;
$$ \frac{\partial \boldsymbol{E}_{\boldsymbol{\hat{w}}} }{\partial \boldsymbol{\hat{w}}} = -\boldsymbol{y}^{\mathrm{T}} \mathbf{X} - \boldsymbol{y}^{\mathrm{T}} \mathbf{X} + \boldsymbol{\hat{w}}^{\mathrm{T}} [\mathbf{X}^{\mathrm{T}} \mathbf{X}+(\mathbf{X}^{\mathrm{T}} \mathbf{X})^{\mathrm{T}}] = -2\boldsymbol{y}^{\mathrm{T}} \mathbf{X} + 2\boldsymbol{\hat{w}}^{\mathrm{T}} \mathbf{X}^{\mathrm{T}} \mathbf{X} $$
令其等于零可得：
$$\boldsymbol{y}^{\mathrm{T}} \mathbf{X} = \boldsymbol{\hat{w}}^{\mathrm{T}} \mathbf{X}^{\mathrm{T}} \mathbf{X}$$
同时转置可得：
$$ \mathbf{X}^{\mathrm{T}} \boldsymbol{y}  = \mathbf{X}^{\mathrm{T}} \mathbf{X} \boldsymbol{\hat{w}}  $$
若此时 $\mathbf{X}^{\mathrm{T}} \mathbf{X}$ 为满秩、非奇异矩阵，我们可以得到：
$$\boldsymbol{\hat{w}}=( \mathbf{X}^{\mathrm{T}} \mathbf{X})^{-1} \mathbf{X}^{\mathrm{T}} \boldsymbol{y}   \\ \ \\ Q.E.D$$&lt;/p&gt;
&lt;h2 id=&#34;上文公式的证明过程&#34;&gt;上文公式的证明过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果你不知道计算结果是否正确，可以使用&lt;a class=&#34;link&#34; href=&#34;http://www.matrixcalculus.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;验算矩阵求导结果是否正确&lt;/a&gt;进行验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;证明(6)
$$
Let \; s=\boldsymbol{a}^T\mathbf{x}={a}_1x_1+\cdots +a_nx_n.\quad Then,\;\frac{\partial s}{\partial x_i}=a_i
\\
So,\:\frac{\mathrm{d} \boldsymbol{a}^{\mathrm{T}}\mathbf{x} }{\mathrm{d} \mathbf{x}}=\frac{\mathrm{d} s}{\mathrm{d} \mathbf{x}}=\left[ \frac{\mathrm{d}s}{\mathrm{d}x_1},\frac{\mathrm{d}s}{\mathrm{d}x_2},\cdots ,\frac{\mathrm{d}s}{\mathrm{d}x_n} \right] =\left[ a_1,a_2,\cdots ,a_n \right] =\boldsymbol{a}^T
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证明(7)
$$
Let \; s=\boldsymbol{\mathbf{x}}^{\mathrm{T}}\mathbf{x}=\sum_i{x_{i}^{2}}. \quad
Then,\;\frac{\partial s}{\partial x_i}=2x_i \\ So, \;\; \frac{\mathrm{d} s}{\mathrm{d} \mathbf{x}}=2\mathbf{x}^{\mathrm{T}}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证明(8)  &lt;br&gt;
当成复合函数即可，相信你可以自己证明！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证明(9)  &lt;br&gt;
比较麻烦的方法，由：
$$
\mathbf{A}\mathbf{x}=\left[ \begin{matrix}
a_{11}&amp;amp;		\cdots&amp;amp;		a_{1n}\\
\vdots&amp;amp;		\ddots&amp;amp;		\vdots\\
a_{n1}&amp;amp;		\cdots&amp;amp;		a_{nn}\\
\end{matrix} \right] \left[ \begin{array}{c}
x_1\\
\vdots\\
x_n\\
\end{array} \right] =\left[ \begin{array}{c}
a_{11}x_1+\cdots +a_{1n}x_n\\
\vdots\\
a_{n1}x_1+\cdots +a_{nn}x_n\\
\end{array} \right]
$$ &lt;br&gt;
再由“分子决定行，分母决定列，分别求导”原则（如果不理解可以返回开头再看一遍）
得到：
$$
\left[ \begin{matrix}
a_{11}&amp;amp;		\cdots&amp;amp;		a_{1n}\\
\vdots&amp;amp;		\ddots&amp;amp;		\vdots\\
a_{n1}&amp;amp;		\cdots&amp;amp;		a_{nn}\\
\end{matrix} \right]=\mathbf{A}
$$
比较简单的方法：（类似上面的证明）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$
Let\,\,  \boldsymbol{s}=\mathbf{A} \mathbf{x}. \;\;  Then,  s_i=\sum_j{\begin{array}{c}
a_{ij}x_j\\
\end{array}}, and\,\,\frac{\partial s_i}{\partial x_j}=a_{ij}.
\\
So, \frac{\mathrm{d} \boldsymbol{s}}{\mathrm{d} \mathbf{x}}=A.
$$&lt;/p&gt;
&lt;p&gt;注释:有些情况（比如矩阵对向量、向量对矩阵、矩阵对矩阵求导）可能存在不好表达的情况（详情参考Reference4)因为列向量对列向量求导本质是用雅可比矩阵定义的。在这里建议直接记住结果,或者用网站验证结果；如果会用张量指标计算也行。如果你想学习更一般地做法，可以参考附录3的文章。&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/sanbuphy/chiguaqunzhong/blob/main/matrix_calculus%20NTU%20.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;matrix_calculus NTU (Po-Chen Wu)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wenku.baidu.com/view/ace84aa564ce0508763231126edb6f1aff0071f2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Matrix Differentiation NUS(Leow Wee Kheng)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/273729929&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;矩阵求导公式的数学推导（矩阵求导——基础篇）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://daiwk.github.io/assets/matrix&amp;#43;vector&amp;#43;derivatives&amp;#43;for&amp;#43;machine&amp;#43;learning.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;机器学习中的矩阵、向量求导&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>《机器学习》西瓜书笔记(一)</title>
        <link>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
        <pubDate>Tue, 11 Jan 2022 20:53:41 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;本文为个人对西瓜书不成熟的一些理解和资料整理，欢迎批评指出意见，谢谢！(可邮箱联系physicoada@gmail.com)&lt;/p&gt;
&lt;h2 id=&#34;西瓜书章节一--绪论&#34;&gt;西瓜书章节一  绪论&lt;/h2&gt;
&lt;p&gt;文字版浓缩可参考：&lt;a class=&#34;link&#34; href=&#34;https://github.com/Vay-keen/Machine-learning-learning-notes/blob/master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%281%29--%E7%BB%AA%E8%AE%BA.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;周志华机器学习笔记1 by:Vay-keen&lt;/a&gt;&lt;br&gt;
简易版思维导图：&lt;a class=&#34;link&#34; href=&#34;https://github.com/Sophia-11/Machine-Learning-Notes/tree/master/ch1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;周志华第一章 by:Sophia-11&lt;/a&gt; &lt;br&gt;
其中一些计算问题:&lt;/p&gt;
&lt;h3 id=&#34;p21-如何理解假设空间&#34;&gt;p21 如何理解假设空间&lt;/h3&gt;
&lt;p&gt;考虑到通配符，假设如文中一般原始参数的取值分别为3，3，3；则总可能值为(3+1)（3+1）（3+1）+1=65种  &lt;br&gt;
或者更复杂一些，可以枚举求得：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/63186122&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;枚举法理解版本空间&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;p22-如何理解版本空间&#34;&gt;p22 如何理解版本空间&lt;/h3&gt;
&lt;p&gt;简单而言，版本空间用于对学习内容进行收敛，是为了收敛假设空间从而使其成为与数据集一致的所有假设的子集集合。本质是缩减假设范围，也就是我们研究问题的范围。操作上可形象理解为“矩阵边界的集合”，有上下界，需要有一定的泛化程度。 &lt;br&gt;
从图上理解：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 203; 
			flex-basis: 487px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-1.png&#34; data-size=&#34;1277x629&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-1.png&#34;
			width=&#34;1277&#34;
			height=&#34;629&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-1_huad3feedb23b3964bb693bb0476f346b0_72292_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-1_huad3feedb23b3964bb693bb0476f346b0_72292_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Photo by WIKI&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Photo by WIKI&lt;/figcaption&gt;
	
&lt;/figure&gt;  &lt;br&gt;
从假设空间的分布缩减理解：&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/5ba037200102&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;version space算法&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;p24-nfl定理的推导理解&#34;&gt;p24 NFL定理的推导理解&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 163; 
			flex-basis: 392px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-2.jpg&#34; data-size=&#34;1103x675&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-2.jpg&#34;
			width=&#34;1103&#34;
			height=&#34;675&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-2_hued8527f6c7ce47642931d657b143adb6_224800_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-2_hued8527f6c7ce47642931d657b143adb6_224800_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Photo by 我自己&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Photo by 我自己&lt;/figcaption&gt;
	
&lt;/figure&gt;
如果还不能理解，可以参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/113126712&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;浅谈NFL没有免费的午餐定理&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cxyzjd.com/article/wyf2017/107669811&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;NFL公式推导&lt;/a&gt;  &lt;br&gt;
如果还不能理解1/2，可参考南瓜书中的真实函数展开&lt;/p&gt;
&lt;h2 id=&#34;西瓜书章节二--模型评估与选择&#34;&gt;西瓜书章节二  模型评估与选择&lt;/h2&gt;
&lt;p&gt;文字浓缩版可参考：&lt;a class=&#34;link&#34; href=&#34;https://github.com/Vay-keen/Machine-learning-learning-notes/blob/master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%282%29--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;性能度量方法&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/Vay-keen/Machine-learning-learning-notes/blob/master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%283%29--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%26%E6%96%B9%E5%B7%AE%26%E5%81%8F%E5%B7%AE.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;假设检验&amp;amp;方差&amp;amp;偏差&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;加强理解查准率查全率以及rocauc&#34;&gt;加强理解查准率、查全率以及ROC、AUC&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/kMD8d5R/article/details/98552574&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一文带你彻底理解ROC曲线和AUC值&lt;/a&gt;     &lt;br&gt;
本文用患病的例子生动形象直观解释了所有概念。
那么，ROC、AUC具体是如何计算的呢？   &lt;br&gt;
请参考南瓜书(2.20)公式，以及(2.21)。&lt;/p&gt;
&lt;h3 id=&#34;p61-如何理解噪声与f独立从而使得最后项为0&#34;&gt;p61 如何理解噪声与f独立从而使得最后项为0&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 83; 
			flex-basis: 199px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-3.jpg&#34; data-size=&#34;930x1117&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-3.jpg&#34;
			width=&#34;930&#34;
			height=&#34;1117&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-3_huc8117000bb929691b7e4c48a4c5416fd_209137_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-3_huc8117000bb929691b7e4c48a4c5416fd_209137_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Photo by 我自己&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Photo by 我自己&lt;/figcaption&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 95; 
			flex-basis: 229px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-4.jpg&#34; data-size=&#34;913x955&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-4.jpg&#34;
			width=&#34;913&#34;
			height=&#34;955&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-4_hufa255f0a000590d94cc0589d7b9444cf_219395_480x0_resize_q75_box.jpg 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/chigua1-4_hufa255f0a000590d94cc0589d7b9444cf_219395_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Photo by 我自己&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Photo by 我自己&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他问题&#34;&gt;其他问题&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.matrix67.com/blog/archives/105&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;什么是P问题、NP问题和NPC问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分内容未补全，慢慢补全&lt;/p&gt;
</description>
        </item>
        <item>
        <title>利用git生成SSH并与github连接</title>
        <link>https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8git%E7%94%9F%E6%88%90ssh%E5%B9%B6%E4%B8%8Egithub%E8%BF%9E%E6%8E%A5/</link>
        <pubDate>Wed, 05 Jan 2022 22:54:06 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E5%88%A9%E7%94%A8git%E7%94%9F%E6%88%90ssh%E5%B9%B6%E4%B8%8Egithub%E8%BF%9E%E6%8E%A5/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在开始菜单，需要使用&lt;strong&gt;管理员&lt;/strong&gt;模式打开git bash&lt;/li&gt;
&lt;li&gt;在linux操作中（比如git）粘贴操作是shift+insert或单击鼠标的滚轮。而复制只要选中即可。（粘贴后修改就很麻烦了，推荐先修改好再粘贴）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;生成ssh账号密码&#34;&gt;生成SSH账号密码&lt;/h2&gt;
&lt;p&gt;如果你是第一次使用,可以先设置git的user name和email：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git config --global user.name &amp;quot;这里改成你的名字&amp;quot;
git config --global user.email  &amp;quot;这里改成你的邮箱&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来即可生成ssh密钥：（注意别把$和#注释部分也给复制进去了，只需要复制考虑$后面的部分）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ssh-keygen -t rsa -b 4096 -C &amp;quot;这里改成你的邮箱&amp;quot;
# -t 密钥方式设定
# -b 密钥强度设定
# -C 注释设定

# 你会看到出现以下信息：
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/ts/.ssh/id_rsa): /Users/ts/.ssh/id_rsa_github # 此时输入你的密钥用户名(可以是邮箱)
Enter passphrase (empty for no passphrase):  #此时输入你的密钥密码
Enter same passphrase again:  # 再次输入密码
#以防万一忘记账户密码，你可以记在其他地方

#看到以下信息，便说明你大概率生成成功
Your identification has been saved in id_rsa_github.
Your public key has been saved in id_rsa_github.pub.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来需要检查我们是不是真的生成成功：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ls -l ~/.ssh
#如果你看到以下信息，就说明已生成成功（没看到config也没关系）
-rw-------  1 ts  staff   938  9 15 22:53 config
-rw-------  1 ts  staff  3326 11  8 21:52 id_rsa_github #私密密钥
-rw-r--r--  1 ts  staff   757 11  8 21:52 id_rsa_github.pub #公开密钥 注意这个要用记事本模式打开，然后在下一步骤中粘贴
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意，这时候可能找不到密钥，但在文件夹中又看得到rsa密钥文件&lt;/strong&gt;，此时可以在不同文件夹（可能生成在某个子类文件夹内）右键打开git bash再输入上述命令，直到能出现以上信息为止。【记住此时的文件夹，在第四步还有用】&lt;/p&gt;
&lt;h2 id=&#34;在github添加ssh-key&#34;&gt;在github添加SSH key&lt;/h2&gt;
&lt;p&gt;这一步比较简单，在github中右上角找到settings，找到SSH and GPG keys，再选择New SSH key，把上一个步骤中的&lt;strong&gt;公开密钥&lt;/strong&gt;内信息全部粘贴到key中，Title可以随便写。最后点击Add key即可完成（如果想看图文操作可以参考reference）&lt;/p&gt;
&lt;h2 id=&#34;最后修改与验证&#34;&gt;最后修改与验证&lt;/h2&gt;
&lt;p&gt;此时回到第二步末尾中的文件夹，输入以下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ vim ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时已在命令行格式中进入文件,粘贴以下讯息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Host github
  HostName github.com
  IdentityFile ~/.ssh/id_rsa_github #指定私密密钥
  User git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;粘贴后（此时还在文件中），我们需要按ESC键跳到命令模式，然后输入下列指令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ :wq
#冒号是必须的，意思是保存文件并退出vi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后修正权限：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ chmod 600 ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们尝试连接，首先确认ssh-agent是否正常运行:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ eval &amp;quot;$(ssh-agent -s)&amp;quot;

Agent pid 32047
# 出现类似信息则表示正常运行

$ ssh-add ~/.ssh/id_rsa_github

Enter passphrase for /Users/ts/.ssh/id_rsa_github: # 此时输入第二步中设定的密码
Identity added: /Users/ts/.ssh/id_rsa_github (/Users/ts/.ssh/id_rsa_github)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后进行连接！&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ssh -T git@github.com

Hi mackerel7! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
#恭喜你，当出现如上信息则表示你已经成功链接！
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qiita.com/0ta2/items/25c27d447378b13a1ac3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHubにssh接続できるようにする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u013778905/article/details/83501204&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub如何配置SSH Key&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>机器学习入门路径及其数学基础</title>
        <link>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Fri, 31 Dec 2021 19:48:48 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;img src="https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-3.jpg" alt="Featured image of post 机器学习入门路径及其数学基础" /&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;机器学习的数学基础&#34;&gt;机器学习的数学基础&lt;/h2&gt;
&lt;p&gt;基础不牢地动山摇，好好打数理基础！但一口吃不成大胖子——
有答主提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;”在很多相关的回答中，我都一再强调不要试图补足数学知识再开始学习机器学习。一般来说，大部分机器学习课程/书籍都要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性代数：矩阵/张量乘法、求逆，奇异值分解/特征值分解，行列式，范数等&lt;/li&gt;
&lt;li&gt;统计与概率：概率分布，独立性与贝叶斯，最大似然（MLE）和最大后验估计（MAP）等&lt;/li&gt;
&lt;li&gt;优化：线性优化，非线性优化(凸优化/非凸优化)以及其衍生的求解方法如梯度下降、牛顿法、基因算法和模拟退火等&lt;/li&gt;
&lt;li&gt;微积分：偏微分，链式法则，矩阵求导等&lt;/li&gt;
&lt;li&gt;信息论、数值理论等&lt;br&gt;
一般人如果想要把这些知识都补全再开始机器学习往往需要很长时间，容易半途而废。而且这些知识是工具不是目的，我们的目标不是成为优化大师。建议在机器学习的过程中哪里不会补哪里，这样更有目的性且耗时更低。”
[本文只包含开源部分的下载链接]&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;线性代数&#34;&gt;线性代数&lt;/h3&gt;
&lt;h4 id=&#34;introduction-to-linear-algebra&#34;&gt;Introduction to Linear Algebra&lt;/h4&gt;
&lt;p&gt;适合入门、相对简单友好的书&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://math.mit.edu/~gs/linearalgebra/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;下载地址&lt;/a&gt;  &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1Sy4y117ot?p=27&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;视频教程&lt;/a&gt;  台湾清华大学 趙啟超教授 &lt;a class=&#34;link&#34; href=&#34;https://ocw.nthu.edu.tw/ocw/index.php?page=course&amp;amp;cid=89&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;课程首页&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;矩阵求导相关&#34;&gt;矩阵求导相关&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;推荐一下我自己写的入门：&lt;a class=&#34;link&#34; href=&#34;https://sanbuphy.github.io/p/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%AE%80%E6%98%93%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;矩阵求导简易入门手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;台湾大学 &lt;a class=&#34;link&#34; href=&#34;http://media.ee.ntu.edu.tw/personal/pcwu/tutorials/matrix_calculus.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Matrix Calculu&lt;/a&gt; by Po-Chen Wu
我个人觉得是简要却齐全的速成ppt。&lt;/li&gt;
&lt;li&gt;查阅手册：&lt;a class=&#34;link&#34; href=&#34;https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;matrixcookbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线计算与验证：&lt;a class=&#34;link&#34; href=&#34;http://www.matrixcalculus.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MatrixCalculus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;线性代数-拓展应用数学系&#34;&gt;线性代数 拓展(应用数学系)&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://ocw.nctu.edu.tw/course_detail.php?bgid=1&amp;amp;gid=1&amp;amp;nid=271#.WKm5gxBCtsA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;線性代數(一) Linear Algebra I&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1e7411E7fq?from=search&amp;amp;seid=11378507849111199637&amp;amp;spm_id_from=333.337.0.0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;视频地址&lt;/a&gt; &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;http://ocw.nctu.edu.tw/course_detail.php?bgid=1&amp;amp;gid=1&amp;amp;nid=361#.WKm5gxBCtsA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;線性代數(二) Linear Algebra II&lt;/a&gt; &lt;br&gt;
课程用书：Linear Algebra, 4th Edition, S. Friedberg, A. Insel and L. Spence, 2003, Prentice Hall.&lt;/p&gt;
&lt;h3 id=&#34;概率论与统计学&#34;&gt;概率论与统计学&lt;/h3&gt;
&lt;h4 id=&#34;洪永淼-概率论与统计学httpswwwbilibilicomvideobv11t411a7bpp4spm_id_frompagedriver&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV11t411A7bp?p=4&amp;amp;spm_id_from=pageDriver&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;洪永淼 概率论与统计学&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://probability.xmu.edu.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;课件与习题解答&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;mathematics-for-machine-learning&#34;&gt;Mathematics for Machine Learning&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mml-book.github.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本书主页&lt;/a&gt;        &lt;a class=&#34;link&#34; href=&#34;https://mml-book.github.io/book/mml-book.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;下载地址&lt;/a&gt;         &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/35449496&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;学习视频及其笔记&lt;/a&gt;    &lt;br&gt;
本书结构：   &lt;br&gt;
&lt;strong&gt;Part I: Mathematical Foundations&lt;/strong&gt; &lt;br&gt;
 Introduction and Motivation&lt;br&gt;
 Linear Algebra &lt;br&gt;
 Analytic Geometry    &lt;br&gt;
 Matrix Decompositions&lt;br&gt;
 Vector Calculus&lt;br&gt;
 Probability and Distribution &lt;br&gt;
 Continuous Optimization&lt;br&gt;
&lt;strong&gt;Part II: Central Machine Learning Problems&lt;/strong&gt;     &lt;br&gt;
 When Models Meet Data&lt;br&gt;
 Linear Regression&lt;br&gt;
 Dimensionality Reduction with Principal Component Analysis &lt;br&gt;
 Density Estimation with Gaussian Mixture Models&lt;br&gt;
 Classification with Support Vector Machines&lt;/p&gt;
&lt;h2 id=&#34;机器学习入门&#34;&gt;机器学习入门&lt;/h2&gt;
&lt;h3 id=&#34;李宏毅2021春机器学习课程&#34;&gt;李宏毅2021春机器学习课程&lt;/h3&gt;
&lt;p&gt;课程地址：
&lt;a class=&#34;link&#34; href=&#34;https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html&lt;/a&gt;&lt;br&gt;
课件和资料Github版：
&lt;a class=&#34;link&#34; href=&#34;https://github.com/Fafa-DL/Lhy_Machine_Learning&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Fafa-DL/Lhy_Machine_Learning&lt;/a&gt;    &lt;br&gt;
可参考笔记：
&lt;a class=&#34;link&#34; href=&#34;https://github.com/unclestrong/DeepLearning_LHY21_Notes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/unclestrong/DeepLearning_LHY21_Notes&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;机器学习实战基于scikit-learn和tensorflow&#34;&gt;机器学习实战：基于Scikit-Learn和TensorFlow&lt;/h3&gt;
&lt;p&gt;好书，看就完了!!（翻译可能有时候不靠谱）
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 83; 
			flex-basis: 200px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-2.png&#34; data-size=&#34;386x463&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-2.png&#34;
			width=&#34;386&#34;
			height=&#34;463&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-2_hub998d424cc0d75d0365888dc6e72c936_147477_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-2_hub998d424cc0d75d0365888dc6e72c936_147477_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
[涉及到的代码]](&lt;a class=&#34;link&#34; href=&#34;https://github.com/ageron/handson-ml2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ageron/handson-ml2&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&#34;python机器学习手册&#34;&gt;python机器学习手册&lt;/h3&gt;
&lt;p&gt;本书的特色是任务制学习&lt;/p&gt;
&lt;h2 id=&#34;机器学习进阶&#34;&gt;机器学习进阶&lt;/h2&gt;
&lt;h3 id=&#34;李航老师-统计学习&#34;&gt;李航老师 统计学习&lt;/h3&gt;
&lt;p&gt;入门选手可参考学习路径&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 97; 
			flex-basis: 234px&#34;
	&gt;
	&lt;a href=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-1.png&#34; data-size=&#34;780x800&#34;&gt;
		&lt;img src=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-1.png&#34;
			width=&#34;780&#34;
			height=&#34;800&#34;
			srcset=&#34;https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-1_hub6836be5e8a9ee25a64bf031be9b591c_130380_480x0_resize_box_3.png 480w, https://sanbuphy.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/knowledge-1_hub6836be5e8a9ee25a64bf031be9b591c_130380_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;Photo by NLP从入门到放弃&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Photo by NLP从入门到放弃&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;深度学习&#34;&gt;深度学习&lt;/h2&gt;
&lt;p&gt;待更新（开摆）&lt;/p&gt;
&lt;h2 id=&#34;计算机视觉&#34;&gt;计算机视觉&lt;/h2&gt;
&lt;p&gt;待更新（开摆）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/29704017&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何用3个月零基础入门「机器学习」？&lt;/a&gt;by微&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1yg411K72z&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;三个月从零入门深度学习，保姆级学习路线图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/pinard/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;刘建平博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>如何运用hugo与github.io搭建个人博客</title>
        <link>https://sanbuphy.github.io/p/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8hugo%E4%B8%8Egithub.io%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Tue, 28 Dec 2021 18:39:12 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8hugo%E4%B8%8Egithub.io%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;前置要求&#34;&gt;前置要求&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;你可能需要学习如何使用git，可参考本博中的教程或观看&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1FE411P7B3?p=2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;狂神git简单教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;你也许也想知道怎么利用GitHub Desktop上传东西到github上，可参考&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/lililuni/article/details/83144090&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub Desktop 的使用教程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;认识hugo&#34;&gt;认识hugo&lt;/h2&gt;
&lt;p&gt;Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。
中文文档地址：  &lt;a class=&#34;link&#34; href=&#34;https://www.gohugo.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.gohugo.org/&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/shulei00/article/details/105611007&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图文安装教程1&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blackstar.pro/posts/%E9%80%9A%E8%BF%87hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图文安装教程2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;hugo的结构&#34;&gt;hugo的结构&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_44397907/article/details/99621517&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hugo的基本用法和页面改造&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://hugo.aiaide.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hugo中文帮助文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;皮肤下载&#34;&gt;皮肤下载&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.gohugo.org/theme/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.gohugo.org/theme/&lt;/a&gt;
注：我用的是&lt;a class=&#34;link&#34; href=&#34;https://github.com/CaiJimmy/hugo-theme-stack/commits?author=hahwul&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hahwul&lt;/a&gt;
写的stack：  &lt;a class=&#34;link&#34; href=&#34;https://github.com/CaiJimmy/hugo-theme-stack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/CaiJimmy/hugo-theme-stack&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.stack.jimmycai.com/zh/configuration/custom-menu.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;主题手册&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;markdown语法检索&#34;&gt;markdown语法检索&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.appinn.com/markdown/#%E5%AE%97%E6%97%A8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.appinn.com/markdown/#%E5%AE%97%E6%97%A8&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://edward852.github.io/post/markdown%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5%E6%B5%8B%E8%AF%95/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;常见的markdown写法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建你的第一个文章&#34;&gt;创建你的第一个文章&lt;/h2&gt;
&lt;p&gt;使用  &lt;code&gt;hugo new xxxxx.md&lt;/code&gt;
注意命名时不可以空格，可以用-代替
然后就可以使用 &lt;code&gt;hugo server &lt;/code&gt;来查看效果啦！&lt;/p&gt;
&lt;h2 id=&#34;发布你的博客&#34;&gt;发布你的博客&lt;/h2&gt;
&lt;p&gt;我们将使用github.io来代替服务器以及域名：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/cbb944131226/article/details/82940224&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;推荐参考教程&lt;/a&gt;
几个注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git要上传或执行的文件可以在文件夹中，右键空白地区点git bash here从而实现目录内操作。&lt;/li&gt;
&lt;li&gt;在linux操作中（比如git）粘贴操作是shift+insert或单击鼠标的滚轮。而复制只要选中即可。&lt;/li&gt;
&lt;li&gt;**【非常重要】**github的域名地址与用户名必须一致，比如你的github名字叫sakura，那么域名必须是sakura.github.io。&lt;/li&gt;
&lt;li&gt;hugo命令 &lt;code&gt;hugo  --baseUrl=&amp;quot;https://改为你的名字.github.io/&amp;quot;&lt;/code&gt;执行完后，会生成一个public文件夹，在public文件中执行1.操作即可推送。&lt;/li&gt;
&lt;li&gt;用git推送的时候 &lt;code&gt;git pull --rebase origin master&lt;/code&gt;语句可能会出错显示没有文件，不用担心，这是因为此时目标仓库是空的，直接下一步最后，你只需要输入对应网址，即可看到自己的宝贝博客了！&lt;/li&gt;
&lt;li&gt;*（可选）如果你想给博客加上评论系统，请参考这样的流程:&lt;a class=&#34;link&#34; href=&#34;https://waline.js.org/guide/get-started.html#html-%E5%BC%95%E5%85%A5-%E5%AE%A2%E6%88%B7%E7%AB%AF&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WALINE&lt;/a&gt;且记得修改config.yaml配置文件中的commit和对应waline项即可&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;更新你的博客&#34;&gt;更新你的博客&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在博客目录下使用 &lt;code&gt;hugo  --baseUrl=&amp;quot;https://改为你的名字.github.io/&amp;quot;&lt;/code&gt;覆盖原来的public文件夹&lt;/li&gt;
&lt;li&gt;进入public文件夹右键git bash&lt;/li&gt;
&lt;li&gt;分别执行 git add . // git commit -m &amp;lsquo;写你的备注&amp;rsquo; // git push&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;可能存在的问题&#34;&gt;可能存在的问题：&lt;/h2&gt;
&lt;h3 id=&#34;界面出现404&#34;&gt;界面出现404&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用Shift+F5强制刷新页面&lt;/li&gt;
&lt;li&gt;检查域名是否和github的名字对应&lt;/li&gt;
&lt;li&gt;github上存放文件的仓库是否只有一个分支（创建时不要勾选生成README.md)&lt;/li&gt;
&lt;li&gt;正常public上传github仓库后会只有一个分支，且包含了public内的所有文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;文章看不到&#34;&gt;文章看不到&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;检查是否格式正确，使用了hugo new xxxx.md&lt;/li&gt;
&lt;li&gt;检查是否包含了 &lt;code&gt;draft: true&lt;/code&gt;，若有则删除或使用 &lt;code&gt;hugo server -D&lt;/code&gt;，若草稿模式开启是看不到文章的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数学公式不显示&#34;&gt;数学公式不显示&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;是否使用了 &lt;code&gt;math: true&lt;/code&gt;，或尝试导入MathJax包，可参考&lt;a class=&#34;link&#34; href=&#34;https://m0t0k1ch1st0ry.com/blog/2017/10/07/mathjax/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo に MathJax を導入して数式を書けるようにする&lt;/a&gt;或者分离式的mathjax调用方法&lt;a class=&#34;link&#34; href=&#34;https://kenbannikki.com/notes/using-mathjax-with-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HugoでMathJaxを使う&lt;/a&gt;MathJax的中文文档：https://www.gohugo.org/doc/tutorials/mathjax/Mathjax的日文文档：https://www.eng.niigata-u.ac.jp/~nomoto/download/mathjax.pdf&lt;/li&gt;
&lt;li&gt;注意此时 &lt;code&gt;\\&lt;/code&gt;换行不成功的话，用 &lt;code&gt;\\\&lt;/code&gt;试试看，有些 &lt;code&gt;\,&lt;/code&gt;的无效也可以用 &lt;code&gt;\\,&lt;/code&gt;代替尝试。&lt;/li&gt;
&lt;li&gt;有时候数学公式正确也会显示不出来，此时你可以检查&lt;strong&gt;代码界面&lt;/strong&gt;或&lt;strong&gt;网页公式处&lt;/strong&gt;是否存在斜体如&amp;quot;&lt;em&gt;_j&lt;/em&gt;&amp;quot;，此时改为&amp;quot;_j&amp;quot;即可恢复正常，特别是_{}时要注意，可以把开始倾斜的代码（找到这里的&amp;quot;_&amp;quot;)改为_{}就可以正常显示。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;文章图片加载很慢&#34;&gt;文章图片加载很慢&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以参考这个文章&lt;a class=&#34;link&#34; href=&#34;https://www.dazhuanlan.com/twofie/topics/1881524&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hugo Content 使用图源、压缩与工具介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;文章头看到了不同的格式比如与---&#34;&gt;文章头看到了不同的格式比如+++与&amp;mdash;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Front Matter支持三种格式，yaml，toml与json方式，你可以参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/sunjinfu19841120/article/details/88956372&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基础文件和头部格式介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;git-push不成功&#34;&gt;git push不成功&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;此时大概率是网络通信有问题，可以关掉git终端后科学上网；重启git 终端后（windows需要，linux系统不需要）再进行push大概率就可以解决问题了；此时无需再进行git init 等初始化操作因为之前已经做完。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>杂七杂八知识库</title>
        <link>https://sanbuphy.github.io/p/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9F%A5%E8%AF%86%E5%BA%93/</link>
        <pubDate>Tue, 28 Dec 2021 18:39:12 +0800</pubDate>
        
        <guid>https://sanbuphy.github.io/p/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9F%A5%E8%AF%86%E5%BA%93/</guid>
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;环境配置相关&#34;&gt;环境配置相关&lt;/h2&gt;
&lt;h3 id=&#34;anaconda&#34;&gt;anaconda&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;anaconda与Jupyter notebook安装教程https://zhuanlan.zhihu.com/p/37093476&lt;/li&gt;
&lt;li&gt;国内的anaconda镜像下载：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&lt;/li&gt;
&lt;li&gt;anaconda更新与下载包的镜像源更换：https://zhuanlan.zhihu.com/p/35985834&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机原理&#34;&gt;计算机原理&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/lyb2518/article/details/90348111&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;从二进制到处理器原理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git小知识&#34;&gt;GIT小知识&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/tEk51NAKjcBQ94F2fCyJJg&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;要熟练使用 Git，恐怕要记住这60个命令&lt;/a&gt;    &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/1da8e5ee0100&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;git 入门小知识&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他数学&#34;&gt;其他数学&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;数学之美番外篇：平凡而又神奇的贝叶斯方法&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
