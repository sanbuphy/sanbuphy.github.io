<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='虚实交错的魔法: 分时多任务'><title>NJU计算机课程基础实验 PA4笔记（大结局）</title>

<link rel='canonical' href='https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='NJU计算机课程基础实验 PA4笔记（大结局）'>
<meta property='og:description' content='虚实交错的魔法: 分时多任务'>
<meta property='og:url' content='https://sanbuphy.github.io/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/'>
<meta property='og:site_name' content='散步的小屋'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='C语言' /><meta property='article:published_time' content='2022-09-16T08:50:40&#43;08:00'/><meta property='article:modified_time' content='2022-09-16T08:50:40&#43;08:00'/>
<meta name="twitter:title" content="NJU计算机课程基础实验 PA4笔记（大结局）">
<meta name="twitter:description" content="虚实交错的魔法: 分时多任务">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6pa/" style="background-color: #2a9d8f; color: #fff;">
                NJU计算机基础实验
            </a>
        
            <a href="/categories/%E7%AC%94%E8%AE%B0/" >
                笔记
            </a>
        
            <a href="/categories/c/" style="background-color: #2a9d8f; color: #fff;">
                C语言
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/">NJU计算机课程基础实验 PA4笔记（大结局）</a>
    </h2>

    
    <h3 class="article-subtitle">
        虚实交错的魔法: 分时多任务
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 16, 2022</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 25 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 132; 
			flex-basis: 316px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP.png" data-size="940x712">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP.png"
			width="940"
			height="712"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP_huf038ba577edd80746ac2e351fb231b7f_213902_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_5ZEUwwhDsP_huf038ba577edd80746ac2e351fb231b7f_213902_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>从这我越来越感受到系统复杂度上升带来的挑战，也明白了抽象的根本目的。</p>
<p>抽象是为了降低复杂度，为了系统能够更好的做大以及稳健和排错。</p>
<p>而且抽象能让你切换不同的“后续程序”进行测试，甚至在大概率正确的载体上进行diff查看到底是哪一层出现了问题（参考各种native）</p>
<p>如何相信抽象是对的？——对每一个抽象层完成后的充分测试。</p>
<p>善用assert是魔法！</p>
<p>（个人能力受限，挂在了2阶的最后pal阶段。。。也许有机会能请教大佬解决一下，这样就可以做第三阶段了，很可惜，但也只能这样了。）</p>
<p>菜得承认，我的能力可能暂时就到此为止了；还是很想做完的，但是从时间成本和能力估计上是不行了。。。</p>
<p>等以后变强了再挑战一次。</p>
<p>2022年9月16日记</p>
<h2 id="上下文切换">上下文切换</h2>
<p><strong>自从有了上下文切换后，程序也就有了进程的概念。（从静止到运动的飞跃 ~~·）</strong></p>
<blockquote>
<p>假设进程A运行的过程中触发了系统调用, 陷入到内核. 根据<code>__am_asm_trap()</code>的代码, A的上下文结构(<code>Context</code>)将会被保存到A的栈上. 在PA3中, 系统调用处理完毕之后, <code>__am_asm_trap()</code>会根据栈上保存的上下文结构来恢复A的上下文.</p>
</blockquote>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 173; 
			flex-basis: 417px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-.png" data-size="1135x653">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-.png"
			width="1135"
			height="653"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-_huf31f56de2e5ca741e461353f125fd95c_98535_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_MHIzmCefz-_huf31f56de2e5ca741e461353f125fd95c_98535_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<blockquote>
<p>如果我们先不着急恢复A的上下文, 而是先将栈顶指针切换到另一个进程B的栈上, 那会发生什么呢? 由于B的栈上存放了之前B保存的上下文结构, 接下来的操作就会根据这一结构来恢复B的上下文. 
上下文切换其实就是不同进程之间的栈切换!</p>
</blockquote>
<h3 id="进程控制块">进程控制块</h3>
<blockquote>
<p>有不少信息都是进程相关的, 除了刚才提到的上下文指针<code>cp</code>之外, 上文提到的栈空间也是如此. 
为了方便对这些进程相关的信息进行管理, 操作系统使用一种叫进程控制块(PCB, process control block)的数据结构, 为每一个进程维护一个PCB.
Nanos-lite使用一个联合体来把其它信息放置在进程堆栈的底部. 代码为每一个进程分配了一个32KB的堆栈, 已经足够使用了, 不会出现栈溢出导致UB. 
在进行上下文切换的时候, <strong>只需要把PCB中的</strong><code>cp</code>指针返回给CTE的<code>__am_irq_handle()</code>函数即可, 剩余部分的代码会根据上下文结构恢复上下文.</p>
</blockquote>
<h3 id="内核线程">内核线程</h3>
<blockquote>
<p>对于刚刚加载完的进程, 我们要怎么切换到它来让它运行起来呢??
答案很简单, 我们只需要在<strong>进程的栈上人工创建一个上下文结构, 使得将来切换的时候可以根据这个结构来正确地恢复上下文即可.</strong>
我们先把Nanos-lite中直接定义的一些测试函数作为程序. Nanos-lite提供了一个测试函数<code>hello_fun()</code>(在<code>nanos-lite/src/proc.c</code>中定义), 
我们接下来的任务就是<strong>为它创建一个上下文, 然后切换到它来执行. 这样的执行流有一个专门的名称, 叫&quot;内核线程&quot;(kernel thread).</strong></p>
<p>创建内核线程的上下文是通过CTE提供的<code>kcontext()</code>函数 (在<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中定义)来实现的,
在Nanos-lite中, 我们可以通过一个<code>context_kload()</code>函数来进行进一步的封装: 它会调用<code>kcontext()</code>来创建上下文, 并把返回的指针记录到PCB的<code>cp</code>中</p>
<p>上下文的创建和切换是CTE的工作, 而具体切换到哪个上下文, 则是由操作系统来决定的, 这项任务叫做进程调度
进程调度是由<code>schedule()</code>函数(在<code>nanos-lite/src/proc.c</code>中定义)来完成的, 它用于返回将要调度的进程上下文. 因此, 我们需要一种方式来记录当前正在运行哪一个进程, 这样我们才能在<code>schedule()</code>中返回另一个进程的上下文</p>
<p>我们让<code>schedule()</code>总是切换到<code>pcb[0]</code>. 注意它的上下文是通过<code>kcontext()</code>创建的, 在<code>schedule()</code>中才决定要切换到它, 然后在CTE的<code>__am_asm_trap()</code>中才真正地恢复这一上下文.</p>
</blockquote>
<p>努力理解了一下，然后写了个汇编，成功点亮~（主要卡在kcontex如何传送area）</p>
<p>这里还要思考一下area到底怎么才是对的。开头地址kstack.start应该拿谁？那段空间应该从哪边开始界定（这也是需要理解的坑）</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 175; 
			flex-basis: 422px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH.png" data-size="1311x745">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH.png"
			width="1311"
			height="745"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH_hubf41834a42365016cbfb0ee37f101bf5_172943_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_dvatOg0DVH_hubf41834a42365016cbfb0ee37f101bf5_172943_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="内核线程的参数">内核线程的参数</h3>
<blockquote>
<p> 我们来创建两个内核线程, 给它们传递不同的参数, 然后在输出的信息中把参数也一同输出, 这样我们就能看到执行流在两个内核线程之间来回切换了!
 我们只需要让<code>kcontext()</code>按照调用约定将<code>arg</code>放置在正确的位置, 将来<code>hello_fun()</code>执行的时候就可以获取正确的参数了.</p>
</blockquote>
<p>感叹这个设计真聪明~</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 139; 
			flex-basis: 334px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG.png" data-size="905x650">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG.png"
			width="905"
			height="650"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG_hu6825840c146c0bb1968a5e6c3a0d7421_240366_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_f4uBNh4SkG_hu6825840c146c0bb1968a5e6c3a0d7421_240366_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h4 id="实现上下文切换2">实现上下文切换(2)</h4>
<blockquote>
<p>根据讲义的上述内容, 实现以下功能:</p>
<ul>
<li>
<p>修改CTE的<code>kcontext()</code>函数, 使其支持参数<code>arg</code>的传递</p>
</li>
<li>
<p>通过<code>kcontext()</code>创建第二个以<code>hello_fun()</code>为入口的内核线程, 并传递不同的参数</p>
</li>
<li>
<p>修改Nanos-lite的<code>schedule()</code>函数, 使其轮流返回两个上下文</p>
</li>
</ul>
<p>你可以自行约定用何种类型来解析参数<code>arg</code>(整数, 字符, 字符串, 指针等皆可), 然后修改<code>hello_fun()</code>中的输出代码, 来按照你约定的方式解析<code>arg</code>. 如果你的实现正确, 你将会看到<code>hello_fun()</code>会轮流输出不同参数的信息.</p>
</blockquote>
<p>这里要想想，riscv用什么方法传参呢？然后思考一下会不会和我们之前的操作有没有冲突（本质是执行顺序的问题，实际上没任何问题）</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 196; 
			flex-basis: 471px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I.png" data-size="1258x640">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I.png"
			width="1258"
			height="640"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I_hu2f96352309cbf87b75e1eed08bd7f30a_339627_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_hcBfJGzs0I_hu2f96352309cbf87b75e1eed08bd7f30a_339627_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>为什么这里叫做内核线程？我的想法是因为他在nanos内部调用实现，并且可以达到快速的执行流切换的效果。</p>
<blockquote>
<p>在真实的操作系统中, 内核中的很多后台任务, 守护服务和驱动程序都是以内核线程的形式存在的. 如果你执行<code>ps aux</code>, 你就会看到系统中有很多COMMAND中带有中括号的内核线程(例如<code>[kthreadd]</code>). 而创建和执行它们的原理, 也是和上面的实验内容非常相似(当然具体实现肯定会有所不同).</p>
</blockquote>
<p>有关一些调用约定：</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 178; 
			flex-basis: 428px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6.png" data-size="1322x741">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6.png"
			width="1322"
			height="741"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6_hu96d4f11f8d37cd358584726cb84f5dbc_136056_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_K0aeZPH-k6_hu96d4f11f8d37cd358584726cb84f5dbc_136056_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h2 id="用户进程">用户进程</h2>
<h4 id="创建用户进程上下文">创建用户进程上下文</h4>
<blockquote>
<p>在PA3的批处理系统中, 我们在<code>naive_uload()</code>中直接通过函数调用转移到用户进程的代码, <strong>那时候使用的还是内核区的栈</strong></p>
</blockquote>
<p>怎么知道的？因为naive_uload跳转的entry本质是在nanos的时候调用函数，出入栈都在内部完成。</p>
<blockquote>
<p><strong>如果内核线程发生了栈溢出, 怎么办?</strong></p>
<p>如果能检测出来, 最好的方法就是触发kernel panic, 因为这时候内核的数据已经不再可信, 如果将一个被破坏的数据写回磁盘, 将会造成无法恢复的毁灭性损坏.</p>
<p>好消息是, 内核线程的正确性可以由内核开发人员来保证, 这至少要比保证那些来路不明的用户进程的正确性要简单多了. 而坏消息则是, 大部分的内核bug都是第三方驱动程序导致的: 栈溢出算是少见的了, 更多的是use-after-free, double-free, 还有难以捉摸的并发bug. 而面对海量的第三方驱动程序, 内核开发人员也难以逐一保证其正确性. 如果你想到一个可以提升驱动程序代码质量的方法, 那就是为计算机系统领域作出贡献了.</p>
</blockquote>
<blockquote>
<p><strong>Nanos-lite和Navy作了一项约定: Nanos-lite把栈顶位置设置到GPRx中</strong>, 然后由Navy里面的<code>_start</code>来<strong>把栈顶位置真正设置到栈指针寄存器中</strong>.</p>
</blockquote>
<p>这里我实现后一直出不来。。（首先记得不能在init加载程序了）</p>
<p>最后发现原来是局部变量和全局的问题（我把参数设置在init，init结束后在stack上的参数自动没了。。。所以就找不到了），最好的方法是直接传入或者是全局变量</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 166; 
			flex-basis: 399px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9.png" data-size="1251x751">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9.png"
			width="1251"
			height="751"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9_hucff7b6b7a0255a3657221407d9ef714c_333414_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_eAmxCBKVP9_hucff7b6b7a0255a3657221407d9ef714c_333414_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>此时有点“一起卡”的感觉，本质是因为pal 的屏幕io的时候就切换去跑hello了。（yield）</p>
<h4 id="问如何验证仙剑奇侠传确实在使用用户栈而不是内核栈">问：如何验证仙剑奇侠传确实在使用用户栈而不是内核栈?</h4>
<p>只要获取pal内部的地址信息在什么范围即可。</p>
<p>还好检查了一下这个，一看发现我的pal还是在内核，直接翻车- -</p>
<p>后面思考了一下发现应该是stack分配的问题。。这点上讲义确实不骗人 老老实实实现就行了。</p>
<p>认真注意这句话：“目前我们让Nanos-lite把<code>heap.end</code>作为用户进程的栈顶, 然后把这个栈顶赋给用户进程的栈指针寄存器就可以了.”</p>
<h3 id="用户进程的参数">用户进程的参数</h3>
<blockquote>
<p>最适合存放参数和环境变量的地方就是用户栈了, 因为在<strong>首次切换到用户进程的时候, 用户栈上的内容就已经可以被用户进程访问. 于是操作系统在加载用户进程的时候</strong>, 还需要负责把<code>argc/argv/envp</code>以及相应的字符串放在用户栈中,
把它们的存放方式和位置作为和用户进程的约定之一, 这样用户进程在<code>_start</code>中就可以根据约定访问它们了.</p>
<p><a class="link" href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc"  title="https://github.com/riscv-non-isa/riscv-elf-psabi-doc"
     target="_blank" rel="noopener"
    >https://github.com/riscv-non-isa/riscv-elf-psabi-doc</a>
ABI手册有一节Process Initialization的内容, **里面详细约定了操作系统需要为用户进程的初始化提供哪些信息. **不过在我们的Project-N系统里面, 我们只需要一个简化版的Process Initialization就够了: 操作系统将<code>argc/argv/envp</code>及其相关内容放置到用户栈上, 然后将GPRx设置为<code>argc</code>所在的地址.</p>
</blockquote>
<p>这里遇到了一个问题，数组一旦作为参数传入后就退化成了指针，我们怎么才能求得正确的大小呢？一个机智的方式是在末尾留个NULL（很多东西都参考了这个设计），这样就可以随意遍历求得数组大小了。</p>
<p>每次操作差点忘记操作栈顶导致翻车，一顿操作猛如虎安排好了用户栈的空间状况，成功跳过开头。（pal的代码写的确实比较通俗）</p>
<h3 id="实现带参数的sys_execve">实现带参数的SYS_execve</h3>
<blockquote>
<p>用户进程的参数还是应该由用户来指定的.最好能有一个方法能把用户指定的参数告诉操作系统, </p>
<p>让操作系统来把指定的参数放到新进程的用户栈里面. </p>
<p>为了实现带参数的<code>SYS_execve</code>, 我们可以在<code>sys_execve()</code>中直接调用<code>context_uload()</code>. 但我们还需要考虑如下的一些细节, 为了方便描述, 我们假设用户进程A将要通过<code>SYS_execve</code>来执行另一个新程序B.</p>
<ul>
<li>
<p>如何在A的执行流中创建用户进程B?</p>
</li>
<li>
<p>如何结束A的执行流?</p>
</li>
</ul>
<p>我们可以从栈底(<code>heap.end</code>)到栈顶(栈指针<code>sp</code>当前的位置)列出用户栈中的内容:</p>
<ul>
<li>
<p>Nanos-lite之前为A传递的用户进程参数(<code>argc/argv/envp</code>)</p>
</li>
<li>
<p>A从<code>_start</code>开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了libos中的<code>execve()</code></p>
</li>
<li>
<p><strong>CTE保存的上下文结构,</strong> 这是由于A在<code>execve()</code>中执行了系统调用自陷指令导致的</p>
</li>
<li>
<p>Nanos-lite从<code>__am_irq_handle()</code>开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了<code>SYS_execve</code>的系统调用处理函数</p>
</li>
</ul>
<p>通过上述分析, 我们得出一个重要的结论: <strong>在加载B时, Nanos-lite使用的是A的用户栈! 这意味着在A的执行流结束之前, A的用户栈是不能被破坏的.</strong> 因此<code>heap.end</code>附近的用户栈是不能被B复用的, 我们应该申请一段新的内存作为B的用户栈</p>
<p>可以让<code>context_uload()</code>统一通过调用<code>new_page()</code>函数来获得用户栈的内存空间. <code>new_page()</code>函数在<code>nanos-lite/src/mm.c</code>中定义, 它会通过一个<code>pf</code>指针来管理堆区, 用于分配一段大小为<code>nr_page * 4KB</code>的连续内存区域, 并返回这段区域的首地址. 我们让<code>context_uload()</code>通过<code>new_page()</code>来分配32KB的内存作为用户栈, 这对PA中的用户程序来说已经足够使用了.</p>
<p>操作系统作为一个特殊的AM应用, 很多时候对动态内存申请却有更严格的要求, 例如申请一段起始地址是4KB整数倍的内存区域, <code>malloc()</code>通常不能满足这样的要求. 因此操作系统一般都会自己来管理堆区, 而不会调用klib中的<code>malloc()</code>. 在操作系统中管理堆区是MM(Memory Manager)模块的工作</p>
</blockquote>
<p>一开始理解错了什么是A还以为hello是A。。。。。然后被提醒后看了好几遍发现原来是这个意思= = （联系一下PA的上文，搞清楚到底是什么进程，这个进程在当下是什么，要换成什么进程）</p>
<p>一顿操作猛如虎成功：</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 178; 
			flex-basis: 428px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf.png" data-size="961x538">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf.png"
			width="961"
			height="538"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf_hu89c0292a312d4e22346b78e5a0994d81_110717_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_PkPnv7phPf_hu89c0292a312d4e22346b78e5a0994d81_110717_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>这里运行nterm又挂了（其他都可以）我哭了- - 又开始排查问题，发现传入argc就会挂。。。具体原因不明，又要继续排查。最后发现是argv飞掉的问题（没有参数的时候如果传入指针拦不住）</p>
<p>总结：你必须搞清楚上下文是怎么从创建到调度的全过程，这样才能理解关键的每一个细节。</p>
<h3 id="运行busybox">运行Busybox</h3>
<p>我的不知道为啥遇到了致命的ld错误。。。。没办法跑</p>
<p>只能放弃了（很神奇的ld符号缺失）</p>
<p>虽然我后面暴力调整了源码可以编译通过了- -但是只能cat之类的基础功能。。。</p>
<p>然后不知道为什么让虚拟机走了几次快照，就可以用了- -只能说计算机真神奇呀。。。</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 109; 
			flex-basis: 263px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd.png" data-size="843x768">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd.png"
			width="843"
			height="768"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd_hu8d58ac57acda53aed754cdf7ab7e0056_178726_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qegJlQ1wUd_hu8d58ac57acda53aed754cdf7ab7e0056_178726_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>WC也完美运行~</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 200; 
			flex-basis: 481px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye.png" data-size="1366x681">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye.png"
			width="1366"
			height="681"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye_huc7dd563df2f31cd43c6ff8efd483cd5c_378066_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_Q3_RZIR6Ye_huc7dd563df2f31cd43c6ff8efd483cd5c_378066_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>—skip也同理完结~ 这阶段最主要的就是麻烦。。很多时候可能一不小心argv就会爆炸。</p>
<p>第一阶段结束,这一阶段的关键就是1：上下文执行流是怎么保存和切换的 2：有关参数的指针小练习</p>
<p>以下几个问题：</p>
<ul>
<li>终端如何读取用户的按键?</li>
</ul>
<p>各种等待键盘事件。。。</p>
<ul>
<li>Shell如何进行命令的解析?</li>
</ul>
<p>可以类似eval,然后要注意argv的维护</p>
<ul>
<li>库函数如何根据命令解析出的字符串搜索到可执行文件?</li>
</ul>
<p>execvp，维护了一个PATH</p>
<ul>
<li>操作系统如何加载执行一个可执行文件?</li>
</ul>
<p>维护参数表进入一个_start，处理后才进行真正的main（上下文切换和跳转）</p>
<h2 id="程序和内存位置很感人的阅读环节">程序和内存位置（很感人的阅读环节）</h2>
<h3 id="绝对代码">绝对代码</h3>
<blockquote>
<p>一般来说, 程序的内存位置是在<a class="link" href="https://en.wikipedia.org/wiki/Link_time"  title="链接时刻(link time)"
     target="_blank" rel="noopener"
    >链接时刻(link time)</a>确定的(Navy-apps中的程序就是这样), 以前的程序员甚至在程序中使用绝对地址来进行内存访问, 这两种代码称为绝对代码(absolute code). </p>
<p>绝对代码会假设程序中的对象(函数和数据)位于某个固定的位置, 绝对代码只能在固定的内存位置才能正确运行.</p>
<p>操作系统在加载时刻分配的空闲内存位置, 并不总是能让这种程序正确运行. </p>
<p>因此, 这个问题的一个解决方案, 就是让操作系统记录程序的加载位置, 当一个程序试图加载到一个已经被使用的内存位置时, 加载将会失败, 操作系统将返回一个错误. 为了避免加载失败, 一个方法是<strong>为每个程序维护多个不同加载地址的版本</strong>, 期望其中有一个版本可以被成功加载.</p>
</blockquote>
<h3 id="可重定位代码">可重定位代码</h3>
<blockquote>
<p>为什么一定要提前确定一个程序的加载位置呢? 如果我们把链接时的重定位阶段往后推迟, 不就可以打破绝对代码的限制了吗?</p>
<p>于是有程序员开发了一类&quot;<a class="link" href="https://en.wikipedia.org/wiki/Self-relocation"  title="自重定位(self-relocation)"
     target="_blank" rel="noopener"
    >自重定位(self-relocation)</a>&ldquo;的特殊程序, 这种程序可以**在开始运行的时候, 先把自己重定位到其它内存位置, **然后再开始真正的运行. 这种重定位类型称为&rdquo;<a class="link" href="https://en.wikipedia.org/wiki/Run_time_%5c%28program_lifecycle_phase%5c%29"  title="运行时(run time)"
     target="_blank" rel="noopener"
    >运行时(run time)</a>重定位&quot;.</p>
<p>但对多任务操作系统来说, 这并没有真正解决问题, 因为程序在运行时刻并不知道重定位的<strong>目标内存位置是否空闲</strong>.</p>
<p>既然只有操作系统才知道内存是否空闲, 那就干脆让加载器来进行重定位吧, 于是有了&quot;<a class="link" href="https://en.wikipedia.org/wiki/Loader_%5c%28computing%5c%29"  title="加载时(load time)"
     target="_blank" rel="noopener"
    >加载时(load time)</a>重定位&quot;的说法. </p>
<p>具体地, <strong>加载器会申请一个空闲的内存位置, 然后将程序加载到这个内存位置, 并把程序重定位到这个内存位置, 之后才会执行这个程序</strong>. 今天的GNU/Linux就是通过这种方式来插入<a class="link" href="https://en.wikipedia.org/wiki/Loadable_kernel_module"  title="内核模块"
     target="_blank" rel="noopener"
    >内核模块</a>的.</p>
</blockquote>
<h3 id="位置无关代码-pic">位置无关代码 PIC</h3>
<blockquote>
<p>有没有方法可以节省重定位的开销, 甚至不进行重定位呢? 但链接时的重定位又可能会产生绝对代码, 这并不是我们所希望的 <strong>. 如果程序中的所有寻址, 都是针对程序位置来进行相对寻址操作, 这样的程序就可以被加载到任意位置执行, 而不会出现绝对代码的问题</strong></p>
<p>这就是<a class="link" href="https://en.wikipedia.org/wiki/Position-independent_code"  title="PIC(position-independent code, 位置无关代码)"
     target="_blank" rel="noopener"
    >PIC(position-independent code, 位置无关代码)</a>的基本思想. 今天的动态库都是PIC, 这样它们就可以被加载到任意的内存位置了. 此外, 如果一个可执行文件全部由PIC组成, 那么它有一个新名字, 叫<a class="link" href="https://en.wikipedia.org/wiki/Position-independent_code#PIE"  title="PIE(position-independent executable, 位置无关可执行文件)"
     target="_blank" rel="noopener"
    >PIE(position-independent executable, 位置无关可执行文件)</a>. 编译器可以通过特定的选项编译出PIE.</p>
<p>PIE之所以能做到位置无关, 其实是要依赖于程序中一个叫<a class="link" href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html"  title="GOT(global offset table, 全局偏移量表)"
     target="_blank" rel="noopener"
    >GOT(global offset table, 全局偏移量表)</a>的数据结构</p>
<p> 但总有一些包含绝对代码的程序, 考虑到兼容问题, 还需要想办法运行它们. 有没有更好的, 一劳永逸的方案呢?</p>
</blockquote>
<h3 id="虚实交错的魔法">虚实交错的魔法</h3>
<blockquote>
<p>绝对代码经过编译链接之后, 程序看到的内存地址就会确定下来了, 加载运行的时候就会让程序使用这一内存地址, 来保证程序可以正确运行. 
一种尝试是<strong>把程序看到的内存和它运行时候真正使用的内存解耦开来</strong>. 这就是虚拟内存的思想.</p>
<p>有了虚拟内存之后, 进程只需要认为自己运行在虚拟地址上就可以了, 真正运行的时候, 才把虚拟地址映射到物理地址. </p>
<p>我们只要**把程序链接到一个固定的虚拟地址, 加载的时候把它们加载到不同的物理地址, 并维护好虚拟地址到物理地址的映射关系, **</p>
</blockquote>
<p>关键：<strong>硬件把物理地址映射成虚拟地址，维护地址映射功能。操作系统决定具体要把虚拟地址映射到哪些物理地址</strong>。</p>
<p>虚拟内存机制是一个<strong>软硬协同</strong>才能工作的机制:  </p>
<ol>
<li>
<p>操作系统加载进程的时候决定要<strong>把进程的虚拟地址映射到哪些物理地址</strong>;</p>
</li>
<li>
<p>等到进程真正运行之前, 还需要<strong>配置MMU, 把之前决定好的映射落实到硬件</strong>上, </p>
</li>
<li>
<p>进程运行的时候, <strong>MMU就会进行地址转换, 把进程的虚拟地址映射</strong>到操作系统希望的物理地址. </p>
</li>
</ol>
<p>（注意到这个映射是进程相关的: 不同的进程有不同的映射,）</p>
<h3 id="分段">分段</h3>
<blockquote>
<p>MMU地址映射最简单的方法就是, 物理地址=虚拟地址+偏移量。即段式虚拟内存管理机制, 简称分段机制. </p>
<p>把物理内存划分成若干个段, 不同的进程就放到不同的段中运行, 进程不需要关心自己具体在哪一个段里面, <strong>操作系统只要让不同的进程使用不同的偏移，进程之间就不会相互干扰</strong></p>
<p>Minix就是这样工作的, 一些简单的嵌入式系统和实时系统, 也是通过分段机制来进行虚存管理.</p>
<p>但是很复杂+性能不高，实际上现在没什么人用这个了。。。。。</p>
</blockquote>
<h2 id="超越容量的界限">超越容量的界限</h2>
<p>这部分我看的有点吃力，参考了一些其他资料：</p>
<p><a class="link" href="https://blog.csdn.net/jinking01/article/details/107098437"  title="https://blog.csdn.net/jinking01/article/details/107098437"
     target="_blank" rel="noopener"
    >https://blog.csdn.net/jinking01/article/details/107098437</a></p>
<p><a class="link" href="https://blog.csdn.net/starter_____/article/details/100998087"  title="https://blog.csdn.net/starter_____/article/details/100998087"
     target="_blank" rel="noopener"
    ><a class="link" href="https://blog.csdn.net/starter"  target="_blank" rel="noopener"
    >https://blog.csdn.net/starter</a>____ _/article/details/100998087</a></p>
<p><a class="link" href="https://www.cnblogs.com/wkfvawl/p/11700301.html"  title="https://www.cnblogs.com/wkfvawl/p/11700301.html"
     target="_blank" rel="noopener"
    >https://www.cnblogs.com/wkfvawl/p/11700301.html</a></p>
<p>为什么 Linux 默认页大小是 4KB</p>
<p><a class="link" href="https://draveness.me/whys-the-design-linux-default-page/"  title="https://draveness.me/whys-the-design-linux-default-page/"
     target="_blank" rel="noopener"
    >https://draveness.me/whys-the-design-linux-default-page/</a></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 481; 
			flex-basis: 1155px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O.png" data-size="761x158">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O.png"
			width="761"
			height="158"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O_hu2b25d731c012c3d86e57bfc163c3d243_14443_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_qrRGhprA9O_hu2b25d731c012c3d86e57bfc163c3d243_14443_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 422; 
			flex-basis: 1013px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV.png" data-size="1140x270">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV.png"
			width="1140"
			height="270"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV_hue566954d002d955be1fd5cdd1e5bedcf_147730_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_wCaizoeQiV_hue566954d002d955be1fd5cdd1e5bedcf_147730_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 166; 
			flex-basis: 400px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG.png" data-size="906x543">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG.png"
			width="906"
			height="543"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG_huff1a274ec48f98d977bbd525804756b0_116391_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_-5aDWkdoQG_huff1a274ec48f98d977bbd525804756b0_116391_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 288; 
			flex-basis: 692px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M.png" data-size="1125x390">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M.png"
			width="1125"
			height="390"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M_hu48316f3178380908df55f2c32e1ce1a2_157709_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_6aV-mruI4M_hu48316f3178380908df55f2c32e1ce1a2_157709_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>其中页目录项和页表项的结构是</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 235; 
			flex-basis: 565px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB.png" data-size="818x347">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB.png"
			width="818"
			height="347"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB_huf796f3770f439a47202c86cddaec60f2_35820_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_NO0r_3mrpB_huf796f3770f439a47202c86cddaec60f2_35820_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<ul>
<li>
<p>present位表示物理页是否可用, 不可用的时候又分两种情况:</p>
<ol>
<li>
<p>物理页面由于交换技术被交换到磁盘中了, Page fault</p>
</li>
<li>
<p>图访问一个未映射的线性地址, 并没有实际的物理页与之相对应, 就是一个非法操作</p>
</li>
</ol>
</li>
<li>
<p>R/W位表示物理页是否可写</p>
</li>
<li>
<p>U/S位表示访问物理页所需要的权限, 如果一个ring 3的进程尝试访问一个ring 0的页面, 当然也会被判定为非法操作</p>
</li>
</ul>
<h3 id="分页">分页</h3>
<blockquote>
<p>事实上, 我们需要一种<strong>按需分配的虚存管理机制</strong>. 之所以分段机制不好实现按需分配, 就是因为段的粒度太大了, 为了实现这一目标, 我们需要反其道而行之: <strong>把连续的存储空间分割成小片段, 以这些小片段为单位进行组织, 分配和管理. 这正是分页机制的核心思想</strong></p>
<p>分页机制引入了一个叫&quot;页表&quot;的结构, <strong>页表中的每一个表项</strong>记录了一个<strong>虚拟页到物理页的映射关系,</strong> 来**把不必连续的物理页面重新组织成连续的虚拟地址空间. **</p>
<p>操作系统首先需要以物理页为单位对内存进行管理. **每当加载程序的时候, 就给程序分配相应的物理页(注意这些物理页之间不必连续), 并为程序准备一个新的页表, 在页表中填写程序用到的虚拟页到这些物理页的映射关系. **</p>
<p>等到程序运行的时候, 操作系统就**把之前为这个程序填写好的页表设置到MMU中, MMU就会根据页表的内容进行地址转换, **把程序的虚拟地址空间映射到操作系统所希望的物理地址空间上.</p>
<p><strong>每一张页目录和页表都有1024个表项, 每个表项的大小都是4字节</strong>, （4k）</p>
<p>除了包含页表(或者物理页)的基地址, 还包含一些标志位信息. 要放在寄存器中是不可能的, <strong>因此它们要放在内存中. 为了找到页目录, i386提供了一个CR3(control register 3)寄存器, 专门用于存放页目录的基地址</strong>. </p>
<p>这样,** 页级地址转换就从CR3开始一步一步地进行, 最终将虚拟地址转换成真正的物理地址, 这个过程称为一次page table walk.**</p>
</blockquote>
<p>总结：操作系统负责写好小纸条和分配关系，MMU负责执行小纸条。</p>
<h4 id="问虚存管理中pic的好处">问：虚存管理中PIC的好处</h4>
<p>我们之前提到, PIC的其中一个好处是可以将代码加载到任意内存位置执行. 如果配合虚存管理, PIC还有什么新的好处呢? (Hint: 动态库已经在享受这些好处了)</p>
<h4 id="问理解分页细节">问：理解分页细节</h4>
<ul>
<li>i386不是一个32位的处理器吗, 为什么表项中的基地址信息只有20位, 而不是32位?</li>
</ul>
<p>答：页表信息表示本身需要2^12的空间，即4kb</p>
<ul>
<li>手册上提到表项(包括CR3)中的基地址都是物理地址, 物理地址是必须的吗? 能否使用虚拟地址?</li>
</ul>
<p>整个页表的基址存放在 CR3 <a class="link" href="https://www.zhihu.com/search?q=%e5%af%84%e5%ad%98%e5%99%a8%5c&amp;search_source=Entity%5c&amp;hybrid_search_source=Entity%5c&amp;hybrid_search_extra=%7b%22sourceType%22:%22answer%22,%22sourceId%22:1951840374%7d"  title="寄存器"
     target="_blank" rel="noopener"
    >寄存器</a>里。CR3 存放的是<strong>物理地址</strong>，这是整个地址转换最根本的基础。在系统初始化时，<strong>CR3 必须填入物理地址</strong>，否则没办法进行地址转换了。这个东西是要让 MMU &ldquo;看&quot;的，它是个硬件，只能看得懂物理地址。</p>
<p>每个<strong>页表项（PML4E, PDPTE, PDE，PTE）里的</strong><a class="link" href="https://www.zhihu.com/search?q=%e5%9f%ba%e5%9d%80%5c&amp;search_source=Entity%5c&amp;hybrid_search_source=Entity%5c&amp;hybrid_search_extra=%7b%22sourceType%22:%22answer%22,%22sourceId%22:1951840374%7d"  title="基址"
     target="_blank" rel="noopener"
    ><strong>基址</strong></a><strong>，都是物理地址</strong>。</p>
<p>但是，整个<strong>页转换表结构</strong>是存放内存里，属于虚拟地址。也就是：<strong>页转换表结构需要进行内存映射。</strong></p>
<ul>
<li>为什么不采用一级页表? 或者说采用一级页表会有什么缺点?</li>
</ul>
<p>当虚拟空间巨大的时候，页表项增多，页表本身占据的空间也会非常庞大。</p>
<p>对于32位虚拟地址空间，假设页面大小为4K，页表项大小为4字节：</p>
<p>一个进程有4G/4k = 2^20个页面
因为一个页面需要一个页表项来对应，所以，进程的页表项个数也为2^20个
不难得出该进程的页表占用了 2^20 * 4 / 4096(4k) = 1024个页面的大小</p>
<p>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p>
<h4 id="问空指针真的是空的吗">问：空指针真的是&quot;空&quot;的吗?</h4>
<blockquote>
<p>程序设计课上老师告诉你, 当一个指针变量的值等于NULL时, 代表空, 不指向任何东西. 仔细想想, 真的是这样吗? 当程序对空指针解引用的时候, 计算机内部具体都做了些什么? 你对空指针的本质有什么新的认识?</p>
</blockquote>
<ul>
<li>
<p>进程试图访问一个未映射的线性地址, 并没有实际的物理页与之相对应，出现错误。</p>
</li>
<li>
<p>或者访问没有权限的地址页，导致直接出错。</p>
</li>
</ul>
<ol>
<li>
<p>Linux 中，每个进程空间的 0x0 虚拟地址开始的线性区(memory region)都会被映射到一个用户态没有访问权限的页上。通过这样的映射，内核可以保证没有别的页会映射到这个区域。</p>
</li>
<li>
<p>编译器把空指针当做 0 对待，开心地让你去访问空指针。</p>
</li>
<li>
<p>缺页异常处理程序被调用，因为在 0x0 的页没有在物理内存里面。</p>
</li>
<li>
<p>缺页异常处理程序发现你没有访问的权限。</p>
</li>
<li>
<p>内核发送 SIGSEGV 信号给进程，该信号默认是让进程自杀。</p>
</li>
</ol>
<p>出自<a class="link" href="https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer-Usually-the-process-terminates-Does-the-reaction-depend-on-the-operating-system-or-is-it-controlled-by-the-compiler-Is-it-mandatory-that-NULL-always-be-defined-as-%e2%80%9c0%e2%80%9d-with-proper-casting"  title="https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer-Usually-the-process-terminates-Does-the-reaction-depend-on-the-operating-system-or-is-it-controlled-by-the-compiler-Is-it-mandatory-that-NULL-always-be-defined-as-“0”-with-proper-casting"
     target="_blank" rel="noopener"
    >https://www.quora.com/What-actually-happens-when-dereferencing-a-NULL-pointer-Usually-the-process-terminates-Does-the-reaction-depend-on-the-operating-system-or-is-it-controlled-by-the-compiler-Is-it-mandatory-that-NULL-always-be-defined-as-“0”-with-proper-casting</a></p>
<p>这个文章不错，Linux C程序真的不能访问NULL指针吗：</p>
<p><a class="link" href="https://cloud.tencent.com/developer/article/1536302"  title="https://cloud.tencent.com/developer/article/1536302"
     target="_blank" rel="noopener"
    >https://cloud.tencent.com/developer/article/1536302</a></p>
<h3 id="状态机视角下的虚存管理机制">状态机视角下的虚存管理机制</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 245; 
			flex-basis: 589px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH.png" data-size="1107x451">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH.png"
			width="1107"
			height="451"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH_hu1d0f7d935267d9bc3bdf5a6d141dd1ef_43740_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_vfH_AKJVMH_hu1d0f7d935267d9bc3bdf5a6d141dd1ef_43740_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><code>fvm()</code>函数可以认为是系统寄存器<code>SR</code>的一部分, 操作系统通过修改<code>SR</code>来对虚存进行管理</p>
<h3 id="在分页机制上运行nanos-lite">在分页机制上运行Nanos-lite</h3>
<blockquote>
<p>为了让<code>map()</code>填写的映射生效, 我们还需要在NEMU中实现分页机制. 具体地, 我们需要实现以下两点:</p>
<ul>
<li>
<p>如何<strong>判断CPU当前是否处于分页模式</strong>?</p>
</li>
<li>
<p><strong>分页地址转换的具体过程</strong>应该如何实现?</p>
</li>
</ul>
<p>但这两点都是ISA相关的, 于是NEMU将它们抽象成相应的API:</p>
<p>// 检查当前系统状态下对内存区间为[vaddr, vaddr + len), 类型为type的访问是否需要经过地址转换.</p>
<p>int isa_mmu_check(vaddr_t vaddr, int len, int type);</p>
<p>// 对内存区间为[vaddr, vaddr + len), 类型为type的内存访问进行地址转换</p>
<p>paddr_t isa_mmu_translate(vaddr_t vaddr, int len, int type);</p>
<p>riscv32的Sv32分页机制和x86非常类似, 只不过寄存器的名字和页表项结构有所不同: <strong>在riscv32中, 页目录基地址和分页使能位都是位于satp寄存器中</strong>. 至于页表项结构的差异, 这里就不详细说明了, 还是RTFM吧.</p>
<p>你需要理解分页地址转换的过程, 然后实现<code>isa_mmu_check()</code>(在<code>nemu/src/isa/$ISA/include/isa-def.h</code>中定义) 和<code>isa_mmu_translate()</code>(在<code>nemu/src/isa/$ISA/system/mmu.c</code>中定义), </p>
<p>你可以查阅NEMU的ISA相关API说明文档来了解它们的行为. 另外由于我们不打算实现保护机制, 在<code>isa_mmu_translate()</code>的实现中, </p>
<p><strong>你务必使用assertion检查页目录项和页表项的present/valid位, 如果发现了一个无效的表项, 及时终止NEMU的运行, 否则调试将会非常困难. 这通常是由于你的实现错误引起的, 请检查实现的正确性.</strong></p>
</blockquote>
<p>我参考了一些其他的关于页表叙述：</p>
<p><a class="link" href="https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie"  title="https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie"
     target="_blank" rel="noopener"
    >https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie</a></p>
<p>csr寄存器：</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 628; 
			flex-basis: 1507px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-.png" data-size="603x96">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-.png"
			width="603"
			height="96"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-_hu5ae7974e7795137e194962f891749850_11703_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_QLlucmBrA-_hu5ae7974e7795137e194962f891749850_11703_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>地址和页表项的构成：</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 204; 
			flex-basis: 491px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr.png" data-size="502x245">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr.png"
			width="502"
			height="245"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr_hub7feb1f484dd4dae97756911a5fdb502_28460_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_yKFGRhH6Mr_hub7feb1f484dd4dae97756911a5fdb502_28460_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 170; 
			flex-basis: 409px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL.png" data-size="898x526">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL.png"
			width="898"
			height="526"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL_hub966a67dfa6019d0196aa292bb848497_232572_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_SBY7t_OXZL_hub966a67dfa6019d0196aa292bb848497_232572_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 368; 
			flex-basis: 885px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln.png" data-size="948x257">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln.png"
			width="948"
			height="257"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln_hue20d95dc73925030ce1e496687897bf9_83750_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_I-UyQ2c5Ln_hue20d95dc73925030ce1e496687897bf9_83750_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>此时一种最简单的解决方案是：<strong>将全部物理内存区域映射到虚拟地址空间</strong>。此时虚拟地址和物理地址之间会有一种简单的对应关系，称为 <strong>线性映射</strong> ，具体关系式如下：</p>
<p>virtual address = physical address + offset</p>
<p>具体的页表转换过程：</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 101; 
			flex-basis: 244px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ.png" data-size="768x753">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ.png"
			width="768"
			height="753"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ_hu1d90819e8c5d71e3fa036cb72fa91db7_131405_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image__AdDT9hPFZ_hu1d90819e8c5d71e3fa036cb72fa91db7_131405_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 628; 
			flex-basis: 1507px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb.png" data-size="603x96">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb.png"
			width="603"
			height="96"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb_hu5ae7974e7795137e194962f891749850_11703_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_LcFD84fGBb_hu5ae7974e7795137e194962f891749850_11703_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 419; 
			flex-basis: 1006px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE.png" data-size="566x135">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE.png"
			width="566"
			height="135"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE_hue778b952d82f3a208f4fffb29dad70f8_19269_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_mslOe1adIE_hue778b952d82f3a208f4fffb29dad70f8_19269_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>注意到riscv32 中所有页面都是 4k 对齐，因此任何页表基地址的低 12 位一定是 0 。这使得我们在保存页表基址的时候只需要保存其高 22 位（PPN）。</p>
<p>我思考了很久页目录项的每一项怎么实现………然后小伙伴提醒不需要那么复杂，只要最简单的地址索引就好… 顿时泪流满面。</p>
<p>然后我们还要知道一点就是，map只需要实现填写一级和二级页表，然后一级就是用VA，二级是用VA+PA（图上都有，一个是正向思考一个是反向思考！）</p>
<p>如果你感到很困难，把这个过程的每一步写下来（第一步做什么，第二部做什么，都要细化！写得出来才是懂了，没写出来就没真的懂。）</p>
<p>而且还要注意看看map的循环，具体的源码是怎么样走的，要注意是顺序映射，所以不需要考虑很多花里胡哨的问题。（什么时候才要创造新页表？看循环其实就知道了。）</p>
<p>此时还要注意一个点：</p>
<p><figure 
	>
	<a href="/image/%5c%29IC6-7NK6%7bNEV%5c~L4Z1%5c%29%5c%29%5c[EK_MGtEixiOTm.png" >
		<img src="/image/%5c%29IC6-7NK6%7bNEV%5c~L4Z1%5c%29%5c%29%5c[EK_MGtEixiOTm.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>对于不同isa的映射，我们跑的算是客户程序（所有的都是am上的客户程序），然后真正的转换到物理 还要guest到host（这个问题很坑）。其实就是一个问题：</p>
<blockquote>
<p><strong>硬件层你怎么解引用？？怎么获取软件的信息？？？要用什么才能读取到软件的信息？？怎么read</strong>？ <strong>这是非常关键且重要的问题，怎么在nemu实现“解引用”</strong></p>
</blockquote>
<p>调不出来，想哭，发现是我的页表项加法有点问题（感觉是指针之类的运算问题），然后一个个仔细修改，发现问题出在最后的页表项，一顿尝试后终于调出来了 哭瞎QWQ 太好哭了</p>
<p>实在绷不住了，借用了阿尼亚的mmu进行diff各种神奇的段错误。</p>
<p>还要注意的是，在页表相关计算的时候要记得转换一下指针。。。别用指针做加法运算。。</p>
<p>这东西让我怀疑了自己100次是不是不适合做PA</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 202; 
			flex-basis: 485px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr.png" data-size="1497x740">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr.png"
			width="1497"
			height="740"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr_hu5817c50bd051ab32da10af54d23892e2_158942_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_n6YBsASDbr_hu5817c50bd051ab32da10af54d23892e2_158942_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 214; 
			flex-basis: 514px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9.png" data-size="1607x750">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9.png"
			width="1607"
			height="750"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9_hu00be0c56a40f36188929aca41c114c2a_227820_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_2Gtt85VZB9_hu00be0c56a40f36188929aca41c114c2a_227820_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="在分页机制上运行用户进程">在分页机制上运行用户进程</h3>
<blockquote>
<p>目前这个地址空间除了内核映射之外就没有其它内容了, 具体可以参考<code>abstract-machine/am/src/$ISA/nemu/vme.c</code>.</p>
<p>不过, 此时<code>loader()</code><strong>不能直接把用户进程加载</strong>到内存位置<code>0x40000000</code>附近了, 因为这个地址<strong>并不在内核的虚拟地址空间中, 内核不能直接访问它</strong>. <code>loader()</code>要做的事情是, 获取程序的大小之后, <strong>以页为单位进行加载</strong>:</p>
<ul>
<li>
<p>申请一页空闲的物理页</p>
</li>
<li>
<p>通过<code>map()</code>把这一物理页映射到用户进程的虚拟地址空间中. 由于AM native实现了权限检查, 为了让程序可以在AM native上正确运行, 你调用<code>map()</code>的时候需要将<code>prot</code>设置成可读可写可执行</p>
</li>
<li>
<p><strong>从文件中读入一页的内容到这一物理页中</strong></p>
</li>
</ul>
<p>这一切都是为了让用户进程在将来可以正确地运行:** 用户进程在将来使用虚拟地址访问内存, 在loader为用户进程维护的映射下, 虚拟地址被转换成物理地址, 通过这一物理地址访问到的物理内存, 恰好就是用户进程想要访问的数据.**</p>
<p>另一个<strong>需要考虑的问题是用户栈,</strong> 和<code>loader()</code>类似, 我们需要把<code>new_page()</code>申请得到的物理页通过<code>map()</code>映射到用户进程的虚拟地址空间中. 我们<strong>把用户栈的虚拟地址安排在用户进程虚拟地址空间的末尾</strong>, 你可以通过<code>as.area.end</code>来得到末尾的位置, 然后把用户栈的物理页映射到<code>[as.area.end - 32KB, as.area.end)</code>这段虚拟地址空间.</p>
<p>最后, 为了让这一地址空间生效, 我们还需要将它落实到MMU中. 具体地, 我们希望在CTE恢复进程上下文的时候来切换地址空间. 为此, 我们需要将进程的地址空间描述符指针<code>as-&gt;ptr</code>加入到上下文中, 框架代码已经实现了这一功能(见<code>abstract-machine/am/include/arch/$ISA-nemu.h</code>), 在x86中这一成员为<code>cr3</code>, 而在mips32/riscv32中则为<code>pdir</code>. 你还需要</p>
<ul>
<li>
<p>修改<code>ucontext()</code>的实现, 在创建的用户进程上下文中设置地址空间描述符指针</p>
</li>
<li>
<p>在<code>__am_irq_handle()</code>的开头调用<code>__am_get_cur_as()</code> (在<code>abstract-machine/am/src/$ISA/nemu/vme.c</code>中定义), 来将当前的地址空间描述符指针保存到上下文中</p>
</li>
<li>
<p>在<code>__am_irq_handle()</code>返回前调用<code>__am_switch()</code> (在<code>abstract-machine/am/src/$ISA/nemu/vme.c</code>中定义)来切换地址空间, 将被调度进程的地址空间落实到MMU中</p>
</li>
</ul>
</blockquote>
<p>这里遇到的第一个大坑就是怎么优雅的改写loader（差点忘了具体程序头表的成分了，又去看书复习了一遍。。。）</p>
<p>然后又忘了as里面其实是有个ptr的。。。。</p>
<p>写loader实在蚌埠住了（浮躁了），开始抱大腿（卡在具体页读取思路上）</p>
<p>此时我又被vaddr_ifetch没实现卡了一晚上 - -。。。。。（一直到不了mmu，直接说我要访问的地方飘了。。。。）出现了超边界提示。通过排查指令可以知道我们执行前会进行fetch_decode——isa_fetch_decode——instr_fetch——vaddr_ifetch，就发现了问题源。。</p>
<p>然后发现神奇mepc之类都为0的问题。。。。开始怀疑上下文是不是有问题。。。一顿操作猛如虎调了一下用户栈相关，解决</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 176; 
			flex-basis: 424px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn.png" data-size="1212x686">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn.png"
			width="1212"
			height="686"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn_hu441b2c5dadc414125370ee62186c1811_276474_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_KDFqVfPErn_hu441b2c5dadc414125370ee62186c1811_276474_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>这里要重新实现一下sbrk的映射</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 142; 
			flex-basis: 341px"
	>
	<a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF.png" data-size="915x643">
		<img src="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF.png"
			width="915"
			height="643"
			srcset="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF_hu647e640f8bfb98ec734200328e392e9c_217301_480x0_resize_box_3.png 480w, /p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa4%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BB%93%E5%B1%80/image/image_zn9oKvz0YF_hu647e640f8bfb98ec734200328e392e9c_217301_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>（笔者在这一阶段打出了GG）</p>
<h4 id="问内核映射的作用">问：内核映射的作用</h4>
<blockquote>
<p>对于x86和riscv32, 在<code>protect()</code>中创建地址空间的时候, 有一处代码用于拷贝内核映射:</p>
<p>// map kernel space</p>
<p>memcpy(updir, kas.ptr, PGSIZE);</p>
<p>尝试注释这处代码, 重新编译并运行, 你会看到发生了错误. 请解释为什么会发生这个错误.</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%BA%8C/">
        
        

        <div class="article-details">
            <h2 class="article-title">NJU计算机课程基础实验 PA3笔记（二）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa3%E7%AC%94%E8%AE%B0%E4%B8%80/">
        
        

        <div class="article-details">
            <h2 class="article-title">NJU计算机课程基础实验 PA3笔记（一）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%BA%8C/">
        
        

        <div class="article-details">
            <h2 class="article-title">NJU计算机课程基础实验 PA2笔记（二）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa2%E7%AC%94%E8%AE%B0%E4%B8%80/">
        
        

        <div class="article-details">
            <h2 class="article-title">NJU计算机课程基础实验 PA2笔记（一）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/nju%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C-pa1%E7%AC%94%E8%AE%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">NJU计算机课程基础实验 PA1笔记</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>
<div id="waline" class="waline-container"></div>
<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
    .waline-container .vcount {
        color: var(--card-text-color-main);
    }
</style><script>
    
    new Waline({"dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"lang":"zh-CN","locale":{"admin":"Admin"},"requiredMeta":["name","email"],"serverURL":"https://waline-e20v24xbr-sanbuphy.vercel.app/","visitor":true});
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2021 - 
        
        2022 散步的小屋
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#上下文切换">上下文切换</a>
      <ol>
        <li><a href="#进程控制块">进程控制块</a></li>
        <li><a href="#内核线程">内核线程</a></li>
        <li><a href="#内核线程的参数">内核线程的参数</a>
          <ol>
            <li><a href="#实现上下文切换2">实现上下文切换(2)</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#用户进程">用户进程</a>
      <ol>
        <li>
          <ol>
            <li><a href="#创建用户进程上下文">创建用户进程上下文</a></li>
            <li><a href="#问如何验证仙剑奇侠传确实在使用用户栈而不是内核栈">问：如何验证仙剑奇侠传确实在使用用户栈而不是内核栈?</a></li>
          </ol>
        </li>
        <li><a href="#用户进程的参数">用户进程的参数</a></li>
        <li><a href="#实现带参数的sys_execve">实现带参数的SYS_execve</a></li>
        <li><a href="#运行busybox">运行Busybox</a></li>
      </ol>
    </li>
    <li><a href="#程序和内存位置很感人的阅读环节">程序和内存位置（很感人的阅读环节）</a>
      <ol>
        <li><a href="#绝对代码">绝对代码</a></li>
        <li><a href="#可重定位代码">可重定位代码</a></li>
        <li><a href="#位置无关代码-pic">位置无关代码 PIC</a></li>
        <li><a href="#虚实交错的魔法">虚实交错的魔法</a></li>
        <li><a href="#分段">分段</a></li>
      </ol>
    </li>
    <li><a href="#超越容量的界限">超越容量的界限</a>
      <ol>
        <li><a href="#分页">分页</a>
          <ol>
            <li><a href="#问虚存管理中pic的好处">问：虚存管理中PIC的好处</a></li>
            <li><a href="#问理解分页细节">问：理解分页细节</a></li>
            <li><a href="#问空指针真的是空的吗">问：空指针真的是&quot;空&quot;的吗?</a></li>
          </ol>
        </li>
        <li><a href="#状态机视角下的虚存管理机制">状态机视角下的虚存管理机制</a></li>
        <li><a href="#在分页机制上运行nanos-lite">在分页机制上运行Nanos-lite</a></li>
        <li><a href="#在分页机制上运行用户进程">在分页机制上运行用户进程</a>
          <ol>
            <li><a href="#问内核映射的作用">问：内核映射的作用</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
